// Your "Library" tab should look like this
/*
Auto-Cards
Made by LewdLeah on May 21, 2025
This AI Dungeon script automatically creates and updates plot-relevant story cards while you play
General-purpose usefulness and compatibility with other scenarios/scripts were my design priorities
Auto-Cards is fully open-source, please copy for use within your own projects! ‚ù§Ô∏è
*/
function AutoCards(inHook, inText, inStop) {
    "use strict";
    /*
    Default Auto-Cards settings
    Feel free to change these settings to customize your scenario's default gameplay experience
    The default values for your scenario are specified below:
    */

    // Is Auto-Cards already enabled when the adventure begins?
    const DEFAULT_DO_AC = true
    // (true or false)

    // Pin the "Configure Auto-Cards" story card at the top of the player's story cards list?
    const DEFAULT_PIN_CONFIGURE_CARD = true
    // (true or false)

    // Minimum number of turns in between automatic card generation events?
    const DEFAULT_CARD_CREATION_COOLDOWN = 22
    // (0 to 9999)

    // Use a bulleted list format for newly generated card entries?
    const DEFAULT_USE_BULLETED_LIST_MODE = true
    // (true or false)

    // Maximum allowed length for newly generated story card entries?
    const DEFAULT_GENERATED_ENTRY_LIMIT = 750
    // (200 to 2000)

    // Do newly generated cards have memory updates enabled by default?
    const DEFAULT_NEW_CARDS_DO_MEMORY_UPDATES = true
    // (true or false)

    // Default character limit before the card's memory bank is summarized?
    const DEFAULT_NEW_CARDS_MEMORY_LIMIT = 2750
    // (1750 to 9900)

    // Approximately how much shorter should recently compressed memories be? (ratio = 10 * old / new)
    const DEFAULT_MEMORY_COMPRESSION_RATIO = 25
    // (20 to 1250)

    // Ignore all-caps during title candidate detection?
    const DEFAULT_IGNORE_ALL_CAPS_TITLES = true
    // (true or false)

    // Should player input actions (Do/Say/Story) be considered during title detection?
    const DEFAULT_DETECT_TITLES_FROM_INPUTS = false
    // (true or false)

    // How many (minimum) actions in the past does Auto-Cards look for named entities?
    const DEFAULT_MINIMUM_LOOK_BACK_DISTANCE = 5
    // (2 to 88)

    // Is Live Script Interface v2 enabled?
    const DEFAULT_DO_LSI_V2 = false
    // (true or false)

    // Should the "Debug Data" story card be visible?
    const DEFAULT_SHOW_DEBUG_DATA = false
    // (true or false)

    // AI prompt used to generate new story card entries?
    const DEFAULT_CARD_GENERATION_PROMPT = prose(
        "-----",
        "",
        
        "<SYSTEM>",
        "# Stop the story and ignore previous instructions. Write a brief and coherent informational entry for %{title} following these instructions:",
        "- Write only third-person pure prose information about %{title} using complete sentences with correct punctuation",
        "- Avoid short-term temporary details or appearances, instead focus on plot-significant information",
        "- If the context mentions a specific time of day (e.g., morning, 19:00, evening), incorporate relevant daily routines, assumed business hours, or time-specific details for %{title}. For example, describe a tavern as being busy in the evening, or mention that a character is typically found at the market in the morning.",
        "- Prioritize story-relevant details about %{title} first to ensure seamless integration with the previous plot",
        "- Create new information based on the context and story direction",
        "- Mention %{title} in every sentence",
        "- Use semicolons if needed",
        "- Add additional details about %{title} beneath incomplete entries",
        "- Be concise and grounded",
        "- Imitate the story's writing style and infer the reader's preferences",
        "</SYSTEM>",
        "Continue the entry for %{title} below while avoiding repetition:",
        "%{entry}"
    ); // (mimic this multi-line "text" format)

    // AI prompt used to summarize a given story card's memory bank?
    const DEFAULT_CARD_MEMORY_COMPRESSION_PROMPT = prose(
        "-----",
        "",
        "<SYSTEM>",
        "# Stop the story and ignore previous instructions. Summarize and condense the given paragraph into a narrow and focused memory passage while following these guidelines:",
        "- Ensure the passage retains the core meaning and most essential details",
        "- Use the third-person perspective",
        "- Prioritize information-density, accuracy, and completeness",
        "- Remain brief and concise",
        "- Write firmly in the past tense",
        "- The paragraph below pertains to old events from far earlier in the story",
        "- Integrate %{title} naturally within the memory; however, only write about the events as they occurred",
        "- Only reference information present inside the paragraph itself, be specific",
        "</SYSTEM>",
        "Write a summarized old memory passage for %{title} based only on the following paragraph:",
        "\"\"\"",
        "%{memory}",
        "\"\"\"",
        "Summarize below:"
    ); // (mimic this multi-line "text" format)

    // Titles banned from future card generation attempts?
    const DEFAULT_BANNED_TITLES_LIST = (
        "North, East, South, West, Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, January, February, March, April, May, June, July, August, September, October, November, December, New Story Arc, Story Arc, Generate Story Arc, Redo Story Arc, Him, Her, She, His, Hers, Theirs, Both, Them, They, Ours, Our, We're, They're, And, But, When, Why, Who, What, Us, We, Story Arc Engine, Scales, Set Story Arc Type, Type, New, NEW, Time, TIME, Intensity, Year, Story Arc Settings, Story Arc, Updating Story Arc Next Turn, Charmer, Honorable, Rogue, Dominant, Submissive, Prankster, Curious, Innocent, Mischievous, Affectionate, Defiant, Brave, Clever, Playful, Month, Year, Day, Minute"
    ); // (mimic this comma-list "text" format)

    // Default story card "type" used by Auto-Cards? (does not matter)
    const DEFAULT_CARD_TYPE = "class"
    // ("text")

    // Should titles mentioned in the "opening" plot component be banned from future card generation by default?
    const DEFAULT_BAN_TITLES_FROM_OPENING = true
    // (true or false)

    //‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

    /*
    Useful API functions for coders (otherwise ignore)
    Here's what each one does in plain terms:

    AutoCards().API.postponeEvents();
    Pauses Auto-Cards activity for n many turns

    AutoCards().API.emergencyHalt();
    Emergency stop or resume

    AutoCards().API.suppressMessages();
    Hides Auto-Cards toasts by preventing assignment to state.message

    AutoCards().API.debugLog();
    Writes to the debug log card

    AutoCards().API.toggle();
    Turns Auto-Cards on/off

    AutoCards().API.generateCard();
    Initiates AI generation of the requested card

    AutoCards().API.redoCard();
    Regenerates an existing card

    AutoCards().API.setCardAsAuto();
    Flags or unflags a card as automatic

    AutoCards().API.addCardMemory();
    Adds a memory to a specific card

    AutoCards().API.eraseAllAutoCards();
    Deletes all auto-cards

    AutoCards().API.getUsedTitles();
    Lists all current card titles

    AutoCards().API.getBannedTitles();
    Shows your current banned titles list

    AutoCards().API.setBannedTitles();
    Replaces the banned titles list with a new list

    AutoCards().API.buildCard();
    Makes a new card from scratch, using exact parameters

    AutoCards().API.getCard();
    Finds cards that match a filter

    AutoCards().API.eraseCard();
    Deletes cards matching a filter
    */

    /*** Postpones internal Auto-Cards events for a specified number of turns
    * 
    * @function
    * @param {number} turns A non-negative integer representing the number of turns to postpone events
    * @returns {Object} An object containing cooldown values affected by the postponement
    * @throws {Error} If turns is not a non-negative integer
    */
    // AutoCards().API.postponeEvents();

    /*** Sets or clears the emergency halt flag to pause Auto-Cards operations
    * 
    * @function
    * @param {boolean} shouldHalt A boolean value indicating whether to engage (true) or disengage (false) emergency halt
    * @returns {boolean} The value that was set
    * @throws {Error} If called from within isolateLSIv2 scope or with a non-boolean argument
    */
    // AutoCards().API.emergencyHalt();

    /*** Enables or disables state.message assignments from Auto-Cards
    * 
    * @function
    * @param {boolean} shouldSuppress If true, suppresses all Auto-Cards messages; false enables them
    * @returns {Array} The current pending messages after setting suppression
    * @throws {Error} If shouldSuppress is not a boolean
    */
    // AutoCards().API.suppressMessages();

    /*** Logs debug information to the "Debug Log card console
    * 
    * @function
    * @param {...any} args Arguments to log for debugging purposes
    * @returns {any} The story card object reference
    */
    // AutoCards().API.debugLog();

    /*** Toggles Auto-Cards behavior or sets it directly
    * 
    * @function
    * @param {boolean|null|undefined} toggleType If undefined, toggles the current state. If boolean or null, sets the state accordingly
    * @returns {boolean|null|undefined} The state that was set or inferred
    * @throws {Error} If toggleType is not a boolean, null, or undefined
    */
    // AutoCards().API.toggle();

    /*** Generates a new card using optional prompt details or a card request object
    * 
    * This function supports two usage modes:
    * 
    * 1. Object Mode:
    *    Pass a single object containing card request parameters. The only mandatory property is "title"
    *    All other properties are optional and customize the card generation
    * 
    *    Example:
    *    AutoCards().API.generateCard({
    *      type: "character",         // The category or type of the card; defaults to "class" if omitted
    *      title: "Leah the Lewd",    // The card's title (required)
    *      keysStart: "Lewd,Leah",    // Optional trigger keywords associated with the card
    *      entryStart: "You are a woman named Leah.", // Existing content to prepend to the AI-generated entry
    *      entryPrompt: "",           // Global prompt guiding AI content generation
    *      entryPromptDetails: "Focus on Leah's works of artifice and ingenuity", // Additional prompt info
    *      entryLimit: 750,           // Target character length for the AI-generated entry
    *      description: "Player character!", // Freeform notes
    *      memoryStart: "Leah purchased a new sweater.", // Existing memory content
    *      memoryUpdates: true,       // Whether the card's memory bank will update on its own
    *      memoryLimit: 2750          // Preferred memory bank size before summarization/compression
    *    });
    * 
    * 2. String Mode:
    *    Pass a string as the title and optionally two additional strings to specify prompt details
    *    This mode is shorthand for quick card generation without an explicit card request object
    * 
    *    Examples:
    *    AutoCards().API.generateCard("Leah the Lewd");
    *    AutoCards().API.generateCard("Leah the Lewd", "Focus on Leah's works of artifice and ingenuity");
    *    AutoCards().API.generateCard(
    *      "Leah the Lewd",
    *      "Focus on Leah's works of artifice and ingenuity",
    *      "You are a woman named Leah."
    *    );
    * 
    * @function
    * @param {Object|string} request Either a fully specified card request object or a string title
    * @param {string} [extra1] Optional detailed prompt text when using string mode
    * @param {string} [extra2] Optional entry start text when using string mode
    * @returns {boolean} Returns true if the generation attempt succeeded, false otherwise
    * @throws {Error} Throws if called with invalid arguments or missing a required title property
    */
    // AutoCards().API.generateCard();

    /*** Regenerates a card by title or object reference, optionally preserving or modifying its input info
    *
    * @function
    * @param {Object|string} request Either a fully specified card request object or a string title for the card to be regenerated
    * @param {boolean} [useOldInfo=true] If true, preserves old info in the new generation; false omits it
    * @param {string} [newInfo=""] Additional info to append to the generation prompt
    * @returns {boolean} True if regeneration succeeded; false otherwise
    * @throws {Error} If the request format is invalid, or if the second or third parameters are the wrong types
    */
    // AutoCards().API.redoCard();

    /*** Flags or unflags a card as an auto-card, controlling its automatic generation behavior
    *
    * @function
    * @param {Object|string} targetCard The card object or title to mark/unmark as an auto-card
    * @param {boolean} [setOrUnset=true] If true, marks the card as an auto-card; false removes the flag
    * @returns {boolean} True if the operation succeeded; false if the card was invalid or already matched the target state
    * @throws {Error} If the arguments are invalid types
    */
    // AutoCards().API.setCardAsAuto();

    /*** Appends a memory to a story card's memory bank
    *
    * @function
    * @param {Object|string} targetCard A card object reference or title string
    * @param {string} newMemory The memory text to add
    * @returns {boolean} True if the memory was added; false if it was empty, already present, or the card was not found
    * @throws {Error} If the inputs are not a string or valid card object reference
    */
    // AutoCards().API.addCardMemory();

    /*** Removes all previously generated auto-cards and resets various states
    *
    * @function
    * @returns {number} The number of cards that were removed
    */
    // AutoCards().API.eraseAllAutoCards();

    /*** Retrieves an array of titles currently used by the adventure's story cards
    *
    * @function
    * @returns {Array<string>} An array of strings representing used titles
    */
    // AutoCards().API.getUsedTitles();

    /*** Retrieves an array of banned titles
    *
    * @function
    * @returns {Array<string>} An array of banned title strings
    */
    // AutoCards().API.getBannedTitles();

    /*** Sets the banned titles array, replacing any previously banned titles
    *
    * @function
    * @param {string|Array<string>} titles A comma-separated string or array of strings representing titles to ban
    * @returns {Object} An object containing oldBans and newBans arrays
    * @throws {Error} If the input is neither a string nor an array of strings
    */
    // AutoCards().API.setBannedTitles();

    /*** Creates a new story card with the specified parameters
    *
    * @function
    * @param {string|Object} title Card title string or full card template object containing all fields
    * @param {string} [entry] The entry text for the card
    * @param {string} [type] The card type (e.g., "character", "location")
    * @param {string} [keys] The keys (triggers) for the card
    * @param {string} [description] The notes or memory bank of the card
    * @param {number} [insertionIndex] Optional index to insert the card at a specific position within storyCards
    * @returns {Object|null} The created card object reference, or null if creation failed
    */
    // AutoCards().API.buildCard();

    /*** Finds and returns story cards satisfying a user-defined condition
    * Example:
    * const leahCard = AutoCards().API.getCard(card => (card.title === "Leah"));
    *
    * @function
    * @param {Function} predicate A function which takes a card and returns true if it matches
    * @param {boolean} [getAll=false] If true, returns all matching cards; otherwise returns the first match
    * @returns {Object|Array<Object>|null} A single card object reference, an array of cards, or null if no match is found
    * @throws {Error} If the predicate is not a function or getAll is not a boolean
    */
    // AutoCards().API.getCard();

    /*** Removes story cards based on a user-defined condition or by direct reference
    * Example:
    * AutoCards().API.eraseCard(card => (card.title === "Leah"));
    *
    * @function
    * @param {Function|Object} predicate A predicate function or a card object reference
    * @param {boolean} [eraseAll=false] If true, removes all matching cards; otherwise removes the first match
    * @returns {boolean|number} True if a single card was removed, false if none matched, or the number of cards erased
    * @throws {Error} If the inputs are not a valid predicate function, card object, or boolean
    */
    // AutoCards().API.eraseCard();

    //‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

    /*
    To everyone who helped, thank you:

    AHotHamster22
    Most extensive testing, feedback, ideation, and kindness

    BinKompliziert
    UI feedback

    Boo
    Discord communication

    bottledfox
    API ideas for alternative card generation use-cases

    Bruno
    Most extensive testing, feedback, ideation, and kindness
    https://play.aidungeon.com/profile/Azuhre

    Burnout
    Implementation improvements, algorithm ideas, script help, and LSIv2 inspiration

    bweni
    Testing

    DebaczX
    Most extensive testing, feedback, ideation, and kindness

    Dirty Kurtis
    Card entry generation prompt engineering

    Dragranis
    Provided the memory dataset used for boundary calibration

    effortlyss
    Data, testing, in-game command ideas, config settings, and other UX improvements

    Hawk
    Grammar and special-cased proper nouns

    Idle Confusion
    Testing
    https://play.aidungeon.com/profile/Idle%20Confusion

    ImprezA
    Most extensive testing, feedback, ideation, and kindness
    https://play.aidungeon.com/profile/ImprezA

    Kat-Oli
    Title parsing, grammar, and special-cased proper nouns

    KryptykAngel
    LSIv2 ideas
    https://play.aidungeon.com/profile/KryptykAngel

    Mad19pumpkin
    API ideas
    https://play.aidungeon.com/profile/Mad19pumpkin

    Magic
    Implementation and syntax improvements
    https://play.aidungeon.com/profile/MagicOfLolis

    Mirox80
    Testing, feedback, and scenario integration ideas
    https://play.aidungeon.com/profile/Mirox80

    Nathaniel Wyvern
    Testing
    https://play.aidungeon.com/profile/NathanielWyvern

    NobodyIsUgly
    All-caps title parsing feedback

    OnyxFlame
    Card memory bank implementation ideas and special-cased proper nouns

    Purplejump
    API ideas for deep integration with other AID scripts

    Randy Viosca
    Context injection and card memory bank structure
    https://play.aidungeon.com/profile/Random_Variable

    RustyPawz
    API ideas for simplified card interaction
    https://play.aidungeon.com/profile/RustyPawz

    sinner
    Testing

    Sleepy pink
    Testing and feedback
    https://play.aidungeon.com/profile/Pinkghost

    Vutinberg
    Memory compression ideas and prompt engineering

    Wilmar
    Card entry generation and memory summarization prompt engineering

    Yi1i1i
    Idea for the redoCard API function and "/ac redo" in-game command

    A note to future individuals:
    If you fork or modify Auto-Cards... Go ahead and put your name here too! Yay! ü•∞
    */

    //‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

    /*
    The code below implements Auto-Cards
    Enjoy! ‚ù§Ô∏è
    */

    // My class definitions are hoisted by wrapper functions because it's less ugly (lol)
    const Const = hoistConst();
    const O = hoistO();
    const Words = hoistWords();
    const StringsHashed = hoistStringsHashed();
    const Internal = hoistInternal();
    // AutoCards has an explicitly immutable domain: HOOK, TEXT, and STOP
    const HOOK = inHook;
    const TEXT = ((typeof inText === "string") && inText) || "\n";
    const STOP = (inStop === true);
    // AutoCards returns a pseudoimmutable codomain which is initialized only once before being read and returned
    const CODOMAIN = new Const().declare();
    // Transient sets for high-performance lookup
    const [used, bans, auto, forenames, surnames] = Array.from({length: 5}, () => new Set());
    // Holds a reference to the data card singleton, remains unassigned unless required
    let data = null;
    // Validate globalThis.text
    text = ((typeof text === "string") && text) || "\n";
    // Container for the persistent state of AutoCards
    const AC = (function() {
        if (state.LSIv2) {
            // The Auto-Cards external API is also available from within the inner scope of LSIv2
            // Call with AutoCards().API.nameOfFunction(yourArguments);
            return state.LSIv2;
        } else if (state.AutoCards) {
            // state.AutoCards is prioritized for performance
            const ac = state.AutoCards;
            delete state.AutoCards;
            return ac;
        }
        const dataVariants = getDataVariants();
        data = getSingletonCard(false, O.f({...dataVariants.critical}), O.f({...dataVariants.debug}));
        // Deserialize the state of Auto-Cards from the data card
        const ac = (function() {
            try {
                return JSON.parse(data?.description);
            } catch {
                return null;
            }
        })();
        // If the deserialized state fails to match the following structure, fallback to defaults
        if (validate(ac, O.f({
            config: [
                "doAC", "deleteAllAutoCards", "pinConfigureCard", "addCardCooldown", "bulletedListMode", "defaultEntryLimit", "defaultCardsDoMemoryUpdates", "defaultMemoryLimit", "memoryCompressionRatio", "ignoreAllCapsTitles", "readFromInputs", "minimumLookBackDistance", "LSIv2", "showDebugData", "generationPrompt", "compressionPrompt", "defaultCardType"
            ],
            signal: [
                "emergencyHalt", "forceToggle", "overrideBans", "swapControlCards", "recheckRetryOrErase", "maxChars", "outputReplacement", "upstreamError"
            ],
            generation: [
                "cooldown", "completed", "permitted", "workpiece", "pending"
            ],
            compression: [
                "completed", "titleKey", "vanityTitle", "responseEstimate", "lastConstructIndex", "oldMemoryBank", "newMemoryBank"
            ],
            message: [
                "previous", "suppress", "pending", "event"
            ],
            chronometer: [
                "turn", "step", "amnesia", "postpone"
            ],
            database: {
                titles: [
                    "used", "banned", "candidates", "lastActionParsed", "lastTextHash", "pendingBans", "pendingUnbans"
                ],
                memories: [
                    "associations", "duplicates"
                ]
            }
        }))) {
            // The deserialization was a success
            return ac;
        }
        function validate(obj, finalKeys) {
            if ((typeof obj !== "object") || (obj === null)) {
                return false;
            } else {
                return Object.entries(finalKeys).every(([key, value]) => {
                    if (!(key in obj)) {
                        return false;
                    } else if (Array.isArray(value)) {
                        return value.every(finalKey => {
                            return (finalKey in obj[key]);
                        });
                    } else {
                        return validate(obj[key], value);
                    }
                });
            }
        }
        // AC is malformed, reinitialize with default values
        return {
            // In-game configurable parameters
            config: getDefaultConfig(),
            // Collection of various short-term signals passed forward in time
            signal: {
                // API: Suspend nearly all Auto-Cards processes
                emergencyHalt: false,
                // API: Forcefully toggle Auto-Cards on or off
                forceToggle: null,
                // API: Banned titles were externally overwritten
                overrideBans: 0,
                // Signal the construction of the opposite control card during the upcoming onOutput hook
                swapControlCards: false,
                // Signal a limited recheck of recent title candidates following a retry or erase
                recheckRetryOrErase: false,
                // Signal an upcoming onOutput text replacement
                outputReplacement: "",
                // info.maxChars is only defined onContext but must be accessed during other hooks too
                maxChars: Math.abs(info?.maxChars || 3200),
                // An error occured within the isolateLSIv2 scope during an earlier hook
                upstreamError: ""
            },
            // Moderates the generation of new story card entries
            generation: {
                // Number of story progression turns between card generations
                cooldown: validateCooldown(underQuarterInteger(validateCooldown(DEFAULT_CARD_CREATION_COOLDOWN))),
                // Continues prompted so far
                completed: 0,
                // Upper limit on consecutive continues
                permitted: 34,
                // Properties of the incomplete story card
                workpiece: O.f({}),
                // Pending card generations
                pending: [],
            },
            // Moderates the compression of story card memories
            compression: {
                // Continues prompted so far
                completed: 0,
                // A title header reference key for this auto-card
                titleKey: "",
                // The full and proper title
                vanityTitle: "",
                // Response length estimate used to compute # of outputs remaining
                responseEstimate: 1400,
                // Indices [0, n] of oldMemoryBank memories used to build the current memory construct
                lastConstructIndex: -1,
                // Bank of card memories awaiting compression
                oldMemoryBank: [],
                // Incomplete bank of newly compressed card memories
                newMemoryBank: [],
            },
            // Prevents incompatibility issues borne of state.message modification
            message: {
                // Last turn's state.message
                previous: getStateMessage(),
                // API: Allow Auto-Cards to post messages?
                suppress: false,
                // Pending Auto-Cards message(s)
                pending: (function() {
                    if (DEFAULT_DO_AC !== false) {
                        const startupMessage = "(Step 1/4) Enabled! You may now edit the \"Configure Auto-Cards\" story card";
                        logEvent(startupMessage);
                        return [startupMessage];
                    } else {
                        return [];
                    }
                })(),
                // Counter to track all Auto-Cards message events
                event: 0
            },
            // Timekeeper used for temporal events
            chronometer: {
                // Previous turn's measurement of info.actionCount
                turn: getTurn(),
                // Whether or not various turn counters should be stepped (falsified by retry actions)
                step: true,
                // Number of consecutive turn interruptions
                amnesia: 0,
                // API: Postpone Auto-Cards externalities for n many turns
                postpone: 0,
            },
            // Scalable atabase to store dynamic game information
            database: {
                // Words are pale shadows of forgotten names. As names have power, words have power
                titles: {
                    // A transient array of known titles parsed from card titles, entry title headers, and trigger keywords
                    used: [],
                    // Titles banned from future card generation attempts and various maintenance procedures
                    banned: getDefaultConfigBans(),
                    // Potential future card titles and their turns of occurrence
                    candidates: [],
                    // Helps avoid rechecking the same action text more than once, generally
                    lastActionParsed: -1,
                    // Ensures weird combinations of retry/erase events remain predictable
                    lastTextHash: "%@%",
                    // Newly banned titles which will be added to the config card
                    pendingBans: [],
                    // Currently banned titles which will be removed from the config card
                    pendingUnbans: []
                },
                // Memories are parsed from context and handled by various operations (basically magic)
                memories: {
                    // Dynamic store of 'story card -> memory' conceptual relations
                    associations: {},
                    // Serialized hashset of the 2000 most recent near-duplicate memories purged from context
                    duplicates: "%@%"
                }
            }
        };
    })();
    O.f(AC);
    O.s(AC.config);
    O.s(AC.signal);
    O.s(AC.generation);
    O.s(AC.generation.workpiece);
    AC.generation.pending.forEach(request => O.s(request));
    O.s(AC.compression);
    O.s(AC.message);
    O.s(AC.chronometer);
    O.f(AC.database);
    O.s(AC.database.titles);
    O.s(AC.database.memories);
    if (!HOOK) {
        globalThis.stop ??= false;
        AC.signal.maxChars = Math.abs(info?.maxChars || AC.signal.maxChars);
        if (HOOK === null) {
            if (/Recent\s*Story\s*:/i.test(text)) {
                // AutoCards(null) is always invoked once after being declared within the shared library
                // Context must be cleaned before passing text to the context modifier
                // This measure is taken to ensure compatability with other scripts
                // First, remove all command, continue, and comfirmation messages from the context window
                text = (text
                    // Hide the guide
                    .replace(/\s*>>>\s*Detailed\s*Guide\s*:[\s\S]*?<<<\s*/gi, "\n\n")
                    // Excise all /AC command messages
                    .replace(/\s*>>>\s*Auto-Cards\s*has\s*been\s*enabled!\s*<<<\s*/gi, " ")
                    .replace(/^.*\/\s*A\s*C.*$/gmi, "%@%")
                    .replace(/\s*%@%\s*/g, " ")
                    // Consolidate all consecutive continue messages into placeholder substrings
                    .replace(/(?:(?:\s*>>>\s*please\s*select\s*"continue"\s*\([\s\S]*?\)\s*<<<\s*)+)/gi, message => {
                        // Replace all continue messages with %@+%-patterned substrings
                        return (
                            // The # of "@" symbols corresponds with the # of consecutive continue messages
                            "%" + "@".repeat(
                                // Count the number of consecutive continue message occurrences
                                (message.match(/>>>\s*please\s*select\s*"continue"\s*\([\s\S]*?\)\s*<<</gi) || []).length
                            ) + "%"
                        );
                    })
                    // Situationally replace all placeholder substrings with either spaces or double newlines
                    .replace(/%@+%/g, (match, matchIndex, intermediateText) => {
                        // Check the case of the next char following the match to decide how to replace it
                        let i = matchIndex + match.length;
                        let nextChar = intermediateText[i];
                        if (nextChar === undefined) {
                            return " ";
                        } else if (/^[A-Z]$/.test(nextChar)) {
                            // Probably denotes a new sentence/paragraph
                            return "\n\n";
                        } else if (/^[a-z]$/.test(nextChar)) {
                            return " ";
                        }
                        // The first nextChar was a weird punctuation char, find the next non-whitespace char
                        do {
                            i++;
                            nextChar = intermediateText[i];
                            if (nextChar === undefined) {
                                return " ";
                            }
                        } while (/\s/.test(nextChar));
                        if (nextChar === nextChar.toUpperCase()) {
                            // Probably denotes a new sentence/paragraph
                            return "\n\n";
                        }
                        // Returning " " probably indicates a previous output's incompleteness
                        return " ";
                    })
                    // Remove all comfirmation requests and responses
                    .replace(/\s*\n*.*CONFIRM\s*DELETE.*\n*\s*/gi, confirmation => {
                        if (confirmation.includes("<<<")) {
                            return " ";
                        } else {
                            return "";
                        }
                    })
                    // Remove dumb memories from the context window
                    // (Latitude, if you're reading this, please give us memoryBank read/write access üò≠)
                    .replace(/(Memories\s*:)\s*([\s\S]*?)\s*(Recent\s*Story\s*:|$)/i, (_, left, memories, right) => {
                        return (left + "\n" + (memories
                            .split("\n")
                            .filter(memory => {
                                const lowerMemory = memory.toLowerCase();
                                return !(
                                    (lowerMemory.includes("select") && lowerMemory.includes("continue"))
                                    || lowerMemory.includes(">>>") || lowerMemory.includes("<<<")
                                    || lowerMemory.includes("lsiv2")
                                );
                            })
                            .join("\n")
                        ) + (function() {
                            if (right !== "") {
                                return "\n\n" + right;
                            } else {
                                return "";
                            }
                        })());
                    })
                    // Remove LSIv2 error messages
                    .replace(/(?:\s*>>>[\s\S]*?<<<\s*)+/g, " ")
                );
                if (!shouldProceed()) {
                    // Whenever Auto-Cards is inactive, remove auto card title headers from contextualized story card entries
                    text = (text
                        .replace(/\s*{\s*titles?\s*:[\s\S]*?}\s*/gi, "\n\n")
                        .replace(/World\s*Lore\s*:\s*/i, "World Lore:\n")
                    );
                    // Otherwise, implement a more complex version of this step within the (HOOK === "context") scope of AutoCards
                }
            }
            CODOMAIN.initialize(null);
        } else {
            // AutoCards was (probably) called without arguments, return an external API to allow other script creators to programmatically govern the behavior of Auto-Cards from elsewhere within their own scripts
            CODOMAIN.initialize({API: O.f(Object.fromEntries(Object.entries({
                // Call these API functions like so: AutoCards().API.nameOfFunction(argumentsOfFunction)
                /*** Postpones internal Auto-Cards events for a specified number of turns
                * 
                * @function
                * @param {number} turns A non-negative integer representing the number of turns to postpone events
                * @returns {Object} An object containing cooldown values affected by the postponement
                * @throws {Error} If turns is not a non-negative integer
                */
                postponeEvents: function(turns) {
                    if (Number.isInteger(turns) && (0 <= turns)) {
                        AC.chronometer.postpone = turns;
                    } else {
                        throw new Error(
                            "Invalid argument: \"" + turns + "\" -> AutoCards().API.postponeEvents() must be be called with a non-negative integer"
                        );
                    }
                    return {
                        postponeAllCooldown: turns,
                        addCardRealCooldown: AC.generation.cooldown,
                        addCardNextCooldown: AC.config.addCardCooldown
                    };
                },
                /*** Sets or clears the emergency halt flag to pause Auto-Cards operations
                * 
                * @function
                * @param {boolean} shouldHalt A boolean value indicating whether to engage (true) or disengage (false) emergency halt
                * @returns {boolean} The value that was set
                * @throws {Error} If called from within isolateLSIv2 scope or with a non-boolean argument
                */
                emergencyHalt: function(shouldHalt) {
                    const scopeRestriction = new Error();
                    if (scopeRestriction.stack && scopeRestriction.stack.includes("isolateLSIv2")) {
                        throw new Error(
                            "Scope restriction: AutoCards().API.emergencyHalt() cannot be called from within LSIv2 (prevents deadlock) but you're more than welcome to use AutoCards().API.postponeEvents() instead!"
                        );
                    } else if (typeof shouldHalt === "boolean") {
                        AC.signal.emergencyHalt = shouldHalt;
                    } else {
                        throw new Error(
                            "Invalid argument: \"" + shouldHalt + "\" -> AutoCards().API.emergencyHalt() must be called with a boolean true or false"
                        );
                    }
                    return shouldHalt;
                },
                /*** Enables or disables state.message assignments from Auto-Cards
                * 
                * @function
                * @param {boolean} shouldSuppress If true, suppresses all Auto-Cards messages; false enables them
                * @returns {Array} The current pending messages after setting suppression
                * @throws {Error} If shouldSuppress is not a boolean
                */
                suppressMessages: function(shouldSuppress) {
                    if (typeof shouldSuppress === "boolean") {
                        AC.message.suppress = shouldSuppress;
                    } else {
                        throw new Error(
                            "Invalid argument: \"" + shouldSuppress + "\" -> AutoCards().API.suppressMessages() must be called with a boolean true or false"
                        );
                    }
                    return AC.message.pending;
                },
                /*** Logs debug information to the "Debug Log" console card
                * 
                * @function
                * @param {...any} args Arguments to log for debugging purposes
                * @returns {any} The story card object reference
                */
                debugLog: function(...args) {
                    return Internal.debugLog(...args);
                },
                /*** Toggles Auto-Cards behavior or sets it directly
                * 
                * @function
                * @param {boolean|null|undefined} toggleType If undefined, toggles the current state. If boolean or null, sets the state accordingly
                * @returns {boolean|null|undefined} The state that was set or inferred
                * @throws {Error} If toggleType is not a boolean, null, or undefined
                */
                toggle: function(toggleType) {
                    if (toggleType === undefined) {
                        if (AC.signal.forceToggle !== null) {
                            AC.signal.forceToggle = !AC.signal.forceToggle;
                        } else if (AC.config.doAC) {
                            AC.signal.forceToggle = false;
                        } else {
                            AC.signal.forceToggle = true;
                        }
                    } else if ((toggleType === null) || (typeof toggleType === "boolean")) {
                        AC.signal.forceToggle = toggleType;
                    } else {
                        throw new Error(
                            "Invalid argument: \"" + toggleType + "\" -> AutoCards().API.toggle() must be called with either A) a boolean true or false, B) a null argument, or C) no arguments at all (undefined)"
                        );
                    }
                    return toggleType;
                },
                /*** Generates a new card using optional prompt details or a request object
                * 
                * @function
                * @param {Object|string} request A request object with card parameters or a string representing the title
                * @param {string} [extra1] Optional entryPromptDetails if using string mode
                * @param {string} [extra2] Optional entryStart if using string mode
                * @returns {boolean} Did the generation attempt succeed or fail
                * @throws {Error} If the request is not valid or missing a title
                */
                generateCard: function(request, extra1, extra2) {
                    // Function call guide:
                    // AutoCards().API.generateCard({
                    //     // All properties except 'title' are optional
                    //     type: "card type, defaults to 'class' for ease of filtering",
                    //     title: "card title",
                    //     keysStart: "preexisting card triggers",
                    //     entryStart: "preexisting card entry",
                    //     entryPrompt: "prompt the AI will use to complete this entry",
                    //     entryPromptDetails: "extra details to include with this card's prompt",
                    //     entryLimit: 750, // target character count for the generated entry
                    //     description: "card notes",
                    //     memoryStart: "preexisting card memory",
                    //     memoryUpdates: true, // card updates when new relevant memories are formed
                    //     memoryLimit: 2750, // max characters before the card memory is compressed
                    // });
                    if (typeof request === "string") {
                        request = {title: request};
                        if (typeof extra1 === "string") {
                            request.entryPromptDetails = extra1;
                            if (typeof extra2 === "string") {
                                request.entryStart = extra2;
                            }
                        }
                    } else if (!isTitleInObj(request)) {
                        throw new Error(
                            "Invalid argument: \"" + request + "\" -> AutoCards().API.generateCard() must be called with either 1, 2, or 3 strings OR a correctly formatted card generation object"
                        );
                    }
                    O.f(request);
                    Internal.getUsedTitles(true);
                    return Internal.generateCard(request);
                },
                /*** Regenerates a card by title or object reference, optionally preserving or modifying its input info
                *
                * @function
                * @param {Object|string} request A card object reference or title string for the card to be regenerated
                * @param {boolean} [useOldInfo=true] If true, preserves old info in the new generation; false omits it
                * @param {string} [newInfo=""] Additional info to append to the generation prompt
                * @returns {boolean} True if regeneration succeeded; false otherwise
                * @throws {Error} If the request format is invalid, or if the second or third parameters are the wrong types
                */
                redoCard: function(request, useOldInfo = true, newInfo = "") {
                    if (typeof request === "string") {
                        request = {title: request};
                    } else if (!isTitleInObj(request)) {
                        throw new Error(
                            "Invalid argument: \"" + request + "\" -> AutoCards().API.redoCard() must be called with a string or correctly formatted card generation object"
                        );
                    }
                    if (typeof useOldInfo !== "boolean") {
                        throw new Error(
                            "Invalid argument: \"" + request + ", " + useOldInfo + "\" -> AutoCards().API.redoCard() requires a boolean as its second argument"
                        );
                    } else if (typeof newInfo !== "string") {
                        throw new Error(
                            "Invalid argument: \"" + request + ", " + useOldInfo + ", " + newInfo + "\" -> AutoCards().API.redoCard() requires a string for its third argument"
                        );
                    }
                    return Internal.redoCard(request, useOldInfo, newInfo);
                },
                /*** Flags or unflags a card as an auto-card, controlling its automatic generation behavior
                *
                * @function
                * @param {Object|string} targetCard The card object or title to mark/unmark as an auto-card
                * @param {boolean} [setOrUnset=true] If true, marks the card as an auto-card; false removes the flag
                * @returns {boolean} True if the operation succeeded; false if the card was invalid or already matched the target state
                * @throws {Error} If the arguments are invalid types
                */
                setCardAsAuto: function(targetCard, setOrUnset = true) {
                    if (isTitleInObj(targetCard)) {
                        targetCard = targetCard.title;
                    } else if (typeof targetCard !== "string") {
                        throw new Error(
                            "Invalid argument: \"" + targetCard + "\" -> AutoCards().API.setCardAsAuto() must be called with a string or card object"
                        );
                    }
                    if (typeof setOrUnset !== "boolean") {
                        throw new Error(
                            "Invalid argument: \"" + targetCard + ", " + setOrUnset + "\" -> AutoCards().API.setCardAsAuto() requires a boolean as its second argument"
                        );
                    }
                    const [card, isAuto] = getIntendedCard(targetCard);
                    if (card === null) {
                        return false;
                    }
                    if (setOrUnset) {
                        if (checkAuto()) {
                            return false;
                        }
                        card.description = "{title:}";
                        Internal.getUsedTitles(true);
                        return card.entry.startsWith("{title: ");
                    } else if (!checkAuto()) {
                        return false;
                    }
                    card.entry = removeAutoProps(card.entry);
                    card.description = removeAutoProps(card.description.replace((
                        /\s*Auto(?:-|\s*)Cards\s*will\s*contextualize\s*these\s*memories\s*:\s*/gi
                    ), ""));
                    function checkAuto() {
                        return (isAuto || /{updates: (?:true|false), limit: \d+}/.test(card.description));
                    }
                    return true;
                },
                /*** Appends a memory to a story card's memory bank
                *
                * @function
                * @param {Object|string} targetCard A card object reference or title string
                * @param {string} newMemory The memory text to add
                * @returns {boolean} True if the memory was added; false if it was empty, already present, or the card was not found
                * @throws {Error} If the inputs are not a string or valid card object reference
                */
                addCardMemory: function(targetCard, newMemory) {
                    if (isTitleInObj(targetCard)) {
                        targetCard = targetCard.title;
                    } else if (typeof targetCard !== "string") {
                        throw new Error(
                            "Invalid argument: \"" + targetCard + "\" -> AutoCards().API.addCardMemory() must be called with a string or card object"
                        );
                    }
                    if (typeof newMemory !== "string") {
                        throw new Error(
                            "Invalid argument: \"" + targetCard + ", " + newMemory + "\" -> AutoCards().API.addCardMemory() requires a string for its second argument"
                        );
                    }
                    newMemory = newMemory.trim().replace(/\s+/g, " ").replace(/^-+\s*/, "");
                    if (newMemory === "") {
                        return false;
                    }
                    const [card, isAuto, titleKey] = getIntendedCard(targetCard);
                    if (
                        (card === null)
                        || card.description.replace(/\s+/g, " ").toLowerCase().includes(newMemory.toLowerCase())
                    ) {
                        return false;
                    } else if (card.description !== "") {
                        card.description += "\n";
                    }
                    card.description += "- " + newMemory;
                    if (titleKey in AC.database.memories.associations) {
                        AC.database.memories.associations[titleKey][1] = (StringsHashed
                            .deserialize(AC.database.memories.associations[titleKey][1], 65536)
                            .remove(newMemory)
                            .add(newMemory)
                            .latest(3500)
                            .serialize()
                        );
                    } else if (isAuto) {
                        AC.database.memories.associations[titleKey] = [999, (new StringsHashed(65536)
                            .add(newMemory)
                            .serialize()
                        )];
                    }
                    return true;
                },
                /*** Removes all previously generated auto-cards and resets various states
                *
                * @function
                * @returns {number} The number of cards that were removed
                */
                eraseAllAutoCards: function() {
                    return Internal.eraseAllAutoCards();
                },
                /*** Retrieves an array of titles currently used by the adventure's story cards
                *
                * @function
                * @returns {Array<string>} An array of strings representing used titles
                */
                getUsedTitles: function() {
                    return Internal.getUsedTitles(true);
                },
                /*** Retrieves an array of banned titles
                *
                * @function
                * @returns {Array<string>} An array of banned title strings
                */
                getBannedTitles: function() {
                    return Internal.getBannedTitles();
                },
                /*** Sets the banned titles array, replacing any previously banned titles
                *
                * @function
                * @param {string|Array<string>} titles A comma-separated string or array of strings representing titles to ban
                * @returns {Object} An object containing oldBans and newBans arrays
                * @throws {Error} If the input is neither a string nor an array of strings
                */
                setBannedTitles: function(titles) {
                    const codomain = {oldBans: AC.database.titles.banned};
                    if (Array.isArray(titles) && titles.every(title => (typeof title === "string"))) {
                        assignBannedTitles(titles);
                    } else if (typeof titles === "string") {
                        if (titles.includes(",")) {
                            assignBannedTitles(titles.split(","));
                        } else {
                            assignBannedTitles([titles]);
                        }
                    } else {
                        throw new Error(
                            "Invalid argument: \"" + titles + "\" -> AutoCards().API.setBannedTitles() must be called with either a string or an array of strings"
                        );
                    }
                    codomain.newBans = AC.database.titles.banned;
                    function assignBannedTitles(titles) {
                        Internal.setBannedTitles(uniqueTitlesArray(titles), false);
                        AC.signal.overrideBans = 3;
                        return;
                    }
                    return codomain;
                },
                /*** Creates a new story card with the specified parameters
                *
                * @function
                * @param {string|Object} title Card title string or full card template object containing all fields
                * @param {string} [entry] The entry text for the card
                * @param {string} [type] The card type (e.g., "character", "location")
                * @param {string} [keys] The keys (triggers) for the card
                * @param {string} [description] The notes or memory bank of the card
                * @param {number} [insertionIndex] Optional index to insert the card at a specific position within storyCards
                * @returns {Object|null} The created card object reference, or null if creation failed
                */
                buildCard: function(title, entry, type, keys, description, insertionIndex) {
                    if (isTitleInObj(title)) {
                        type = title.type ?? type;
                        keys = title.keys ?? keys;
                        entry = title.entry ?? entry;
                        description = title.description ?? description;
                        title = title.title;
                    }
                    title = cast(title);
                    const card = constructCard(O.f({
                        type: cast(type, AC.config.defaultCardType),
                        title,
                        keys: cast(keys, buildKeys("", title)),
                        entry: cast(entry),
                        description: cast(description)
                    }), boundInteger(0, insertionIndex, storyCards.length, newCardIndex()));
                    if (notEmptyObj(card)) {
                        return card;
                    }
                    function cast(value, fallback = "") {
                        if (typeof value === "string") {
                            return value;
                        } else {
                            return fallback;
                        }
                    }
                    return null;
                },
                /*** Finds and returns story cards satisfying a user-defined condition
                *
                * @function
                * @param {Function} predicate A function which takes a card and returns true if it matches
                * @param {boolean} [getAll=false] If true, returns all matching cards; otherwise returns the first match
                * @returns {Object|Array<Object>|null} A single card object reference, an array of cards, or null if no match is found
                * @throws {Error} If the predicate is not a function or getAll is not a boolean
                */
                getCard: function(predicate, getAll = false) {
                    if (typeof predicate !== "function") {
                        throw new Error(
                            "Invalid argument: \"" + predicate + "\" -> AutoCards().API.getCard() must be called with a function"
                        );
                    } else if (typeof getAll !== "boolean") {
                        throw new Error(
                            "Invalid argument: \"" + predicate + ", " + getAll + "\" -> AutoCards().API.getCard() requires a boolean as its second argument"
                        );
                    }
                    return Internal.getCard(predicate, getAll);
                },
                /*** Removes story cards based on a user-defined condition or by direct reference
                *
                * @function
                * @param {Function|Object} predicate A predicate function or a card object reference
                * @param {boolean} [eraseAll=false] If true, removes all matching cards; otherwise removes the first match
                * @returns {boolean|number} True if a single card was removed, false if none matched, or the number of cards erased
                * @throws {Error} If the inputs are not a valid predicate function, card object, or boolean
                */
                eraseCard: function(predicate, eraseAll = false) {
                    if (isTitleInObj(predicate) && storyCards.includes(predicate)) {
                        return eraseCard(predicate);
                    } else if (typeof predicate !== "function") {
                        throw new Error(
                            "Invalid argument: \"" + predicate + "\" -> AutoCards().API.eraseCard() must be called with a function or card object"
                        );
                    } else if (typeof eraseAll !== "boolean") {
                        throw new Error(
                            "Invalid argument: \"" + predicate + ", " + eraseAll + "\" -> AutoCards().API.eraseCard() requires a boolean as its second argument"
                        );
                    } else if (eraseAll) {
                        // Erase all cards which satisfy the given condition
                        let cardsErased = 0;
                        for (const [index, card] of storyCards.entries()) {
                            if (predicate(card)) {
                                removeStoryCard(index);
                                cardsErased++;
                            }
                        }
                        return cardsErased;
                    }
                    // Erase the first card which satisfies the given condition
                    for (const [index, card] of storyCards.entries()) {
                        if (predicate(card)) {
                            removeStoryCard(index);
                            return true;
                        }
                    }
                    return false;
                }
            }).map(([key, fn]) => [key, function(...args) {
                const result = fn.apply(this, args);
                if (data) {
                    data.description = JSON.stringify(AC);
                }
                return result;
            }])))});
            function isTitleInObj(obj) {
                return (
                    (typeof obj === "object")
                    && (obj !== null)
                    && ("title" in obj)
                    && (typeof obj.title === "string")
                );
            }
        }
    } else if (AC.signal.emergencyHalt) {
        switch(HOOK) {
        case "context": {
            // AutoCards was called within the context modifier
            advanceChronometer();
            break; }
        case "output": {
            // AutoCards was called within the output modifier
            concludeEmergency();
            const previousAction = readPastAction(0);
            if (isDoSayStory(previousAction.type) && /escape\s*emergency\s*halt/i.test(previousAction.text)) {
                AC.signal.emergencyHalt = false;
            }
            break; }
        }
        CODOMAIN.initialize(TEXT);
    } else if ((AC.config.LSIv2 !== null) && AC.config.LSIv2) {
        // Silly recursion shenanigans
        state.LSIv2 = AC;
        AC.config.LSIv2 = false;
        const LSI_DOMAIN = AutoCards(HOOK, TEXT, STOP);
        // Is this lazy loading mechanism overkill? Yes. But it's fun!
        const factories = O.f({
            library: () => ({
                name: Words.reserved.library,
                entry: prose(
                    "// Your adventure's Shared Library code goes here",
                    "// Example Library code:",
                    "state.promptDragon ??= false;",
                    "state.mind ??= 0;",
                    "state.willStop ??= false;",
                    "function formatMessage(message, space = \" \") {",
                    "    let leadingNewlines = \"\";",
                    "    let trailingNewlines = \"\\n\\n\";",
                    "    if (text.startsWith(\"\\n> \")) {",
                    "        // We don't want any leading/trailing newlines for Do/Say",
                    "        trailingNewlines = \"\";",
                    "    } else if (history && (0 < history.length)) {",
                    "        // Decide leading newlines based on the previous action",
                    "        const action = history[history.length - 1];",
                    "        if ((action.type === \"continue\") || (action.type === \"story\")) {",
                    "            if (!action.text.endsWith(\"\\n\")) {",
                    "                leadingNewlines = \"\\n\\n\";",
                    "            } else if (!action.text.endsWith(\"\\n\\n\")) {",
                    "                leadingNewlines = \"\\n\";",
                    "            }",
                    "        }",
                    "    }",
                    "    return leadingNewlines + \"{>\" + space + (message",
                    "        .replace(/(?:\\s*(?:{>|<})\\s*)+/g, \" \")",
                    "        .trim()",
                    "    ) + space + \"<}\" + trailingNewlines;",
                    "}"),
                description:
                    "// You may also continue your Library code below",
                singleton: false,
                position: 2
            }),
            input: () => ({
                name: Words.reserved.input,
                entry: prose(
                    "// Your adventure's Input Modifier code goes here",
                    "// Example Input code:",
                    "const minds = [",
                    "\"kind and gentle\",",
                    "\"curious and eager\",",
                    "\"cruel and evil\"",
                    "];",
                    "// Type any of these triggers into a Do/Say/Story action",
                    "const commands = new Map([",
                    "[\"encounter dragon\", () => {",
                    "    AutoCards().API.postponeEvents(1);",
                    "    state.promptDragon = true;",
                    "    text = formatMessage(\"You encounter a dragon!\");",
                    "    log(\"A dragon appears!\");",
                    "}],",
                    "[\"summon leah\", () => {",
                    "    alterMind();",
                    "    const success = AutoCards().API.generateCard({",
                    "        title: \"Leah\",",
                    "        entryPromptDetails: (",
                    "            \"Leah is an exceptionally \" +",
                    "            minds[state.mind] +",
                    "            \" woman\"",
                    "        ),",
                    "        entryStart: \"Leah is your magically summoned assistant.\"",
                    "    });",
                    "    if (success) {",
                    "        text = formatMessage(\"You begin summoning Leah!\");",
                    "        log(\"Attempting to summon Leah\");",
                    "    } else {",
                    "        text = formatMessage(\"You failed to summon Leah...\");",
                    "        log(\"Leah could not be summoned\");",
                    "    }",
                    "}],",
                    "[\"alter leah\", () => {",
                    "    alterMind();",
                    "    const success = AutoCards().API.redoCard(\"Leah\", true, (",
                    "        \"You subjected Leah to mind-altering magic\\n\" +",
                    "        \"Therefore she is now entirely \" +",
                    "        minds[state.mind] +",
                    "        \", utterly captivated by your will\"",
                    "    ));",
                    "    if (success) {",
                    "        text = formatMessage(",
                    "            \"You proceed to alter Leah's mind!\"",
                    "        );",
                    "        log(\"Attempting to alter Leah\");",
                    "    } else {",
                    "        text = formatMessage(\"You failed to alter Leah...\");",
                    "        log(\"Leah could not be altered\");",
                    "    }",
                    "}],",
                    "[\"show api\", () => {",
                    "    state.showAPI = true;",
                    "    text = formatMessage(\"Displaying the Auto-Cards API below\");",
                    "}],",
                    "[\"force stop\", () => {",
                    "    state.willStop = true;",
                    "}]",
                    "]);",
                    "const lowerText = text.toLowerCase();",
                    "for (const [trigger, implement] of commands) {",
                    "    if (lowerText.includes(trigger)) {",
                    "        implement();",
                    "        break;",
                    "    }",
                    "}",
                    "function alterMind() {",
                    "    state.mind = (state.mind + 1) % minds.length;",
                    "    return;",
                    "}"),
                description:
                    "// You may also continue your Input code below",
                singleton: false,
                position: 3
            }),
            context: () => ({
                name: Words.reserved.context,
                entry: prose(
                    "// Your adventure's Context Modifier code goes here",
                    "// Example Context code:",
                    "text = text.replace(/\\s*{>[\\s\\S]*?<}\\s*/gi, \"\\n\\n\");",
                    "if (state.willStop) {",
                    "    state.willStop = false;",
                    "    // Assign true to prevent the onOutput hook",
                    "    // This can only be done onContext",
                    "    stop = true;",
                    "} else if (state.promptDragon) {",
                    "    state.promptDragon = false;",
                    "    text = (",
                    "        text.trimEnd() +",
                    "        \"\\n\\nA cute little dragon softly lands upon your head. \"",
                    "    );",
                    "}"),
                description:
                    "// You may also continue your Context code below",
                singleton: false,
                position: 4
            }),
            output: () => ({
                name: Words.reserved.output,
                entry: prose(
                    "// Your adventure's Output Modifier code goes here",
                    "// Example Output code:",
                    "if (state.showAPI) {",
                    "    state.showAPI = false;",
                    "    const apiKeys = (Object.keys(AutoCards().API)",
                    "        .map(key => (\"AutoCards().API.\" + key + \"()\"))",
                    "    );",
                    "    text = formatMessage(apiKeys.join(\"\\n\"), \"\\n\");",
                    "    log(apiKeys);",
                    "}"),
                description:
                    "// You may also continue your Output code below",
                singleton: false,
                position: 5
            }),
            guide: () => ({
                name: Words.reserved.guide,
                entry: prose(
                    "Any valid JavaScript code you write within the Shared Library or Input/Context/Output Modifier story cards will be executed from top to bottom; Live Script Interface v2 closely emulates AI Dungeon's native scripting environment, even if you aren't the owner of the original scenario. Furthermore, I've provided full access to the Auto-Cards scripting API. Please note that disabling LSIv2 via the \"Configure Auto-Cards\" story card will reset your LSIv2 adventure scripts!",
                    "",
                    "If you aren't familiar with scripting in AI Dungeon, please refer to the official guidebook page:",
                    "https://help.aidungeon.com/scripting",
                    "",
                    "I've included an example script with the four aforementioned code cards, to help showcase some of my fancy schmancy Auto-Cards API functions. Take a look, try some of my example commands, inspect the Console Log, and so on... It's a ton of fun! ‚ù§Ô∏è",
                    "",
                    "If you ever run out of space in your Library, Input, Context, or Output code cards, simply duplicate whichever one(s) you need and then perform an in-game turn before writing any more code. (emphasis on \"before\") Doing so will signal LSIv2 to convert your duplicated code card(s) into additional auxiliary versions.",
                    "",
                    "Auxiliary code cards are numbered, and any code written within will be appended in sequential order. For example:",
                    "// Shared Library (entry)",
                    "// Shared Library (notes)",
                    "// Shared Library 2 (entry)",
                    "// Shared Library 2 (notes)",
                    "// Shared Library 3 (entry)",
                    "// Shared Library 3 (notes)",
                    "// Input Modifier (entry)",
                    "// Input Modifier (notes)",
                    "// Input Modifier 2 (entry)",
                    "// Input Modifier 2 (notes)",
                    "// And so on..."),
                description:
                    "",
                singleton: true,
                position: 0
            }),
            state: () => ({
                name: Words.reserved.state,
                entry:
                    "Your adventure's full state object is displayed in the Notes section below.",
                description:
                    "",
                singleton: true,
                position: 6
            }),
            log: () => ({
                name: Words.reserved.log,
                entry:
                    "Please refer to the Notes section below to view the full log history for LSIv2. Console log entries are ordered from most recent to oldest. LSIv2 error messages will be recorded here, alongside the outputs of log and console.log function calls within your adventure scripts.",
                description:
                    "",
                singleton: true,
                position: 1
            })
        });
        const cache = {};
        const templates = new Proxy({}, {
            get(_, key) {
                return cache[key] ??= O.f(factories[key]());
            }
        });
        if (AC.config.LSIv2 !== null) {
            switch(HOOK) {
            case "input": {
                // AutoCards was called within the input modifier
                const [libraryCards, inputCards, logCard] = collectCards(
                    templates.library,
                    templates.input,
                    templates.log
                );
                const [error, newText] = isolateLSIv2(parseCode(libraryCards, inputCards), callbackLog(logCard), LSI_DOMAIN);
                handleError(logCard, error);
                if (hadError()) {
                    CODOMAIN.initialize(getStoryError());
                    AC.signal.upstreamError = "\n";
                } else {
                    CODOMAIN.initialize(newText);
                }
                break; }
            case "context": {
                // AutoCards was called within the context modifier
                const [libraryCards, contextCards, logCard] = collectCards(
                    templates.library,
                    templates.context,
                    templates.log,
                    templates.input
                );
                if (hadError()) {
                    endContextLSI(LSI_DOMAIN);
                    break;
                }
                const [error, ...newCodomain] = (([error, newText, newStop]) => [error, newText, (newStop === true)])(
                    isolateLSIv2(parseCode(libraryCards, contextCards), callbackLog(logCard), LSI_DOMAIN[0], LSI_DOMAIN[1])
                );
                handleError(logCard, error);
                endContextLSI(newCodomain);
                function endContextLSI(newCodomain) {
                    CODOMAIN.initialize(newCodomain);
                    if (!newCodomain[1]) {
                        return;
                    }
                    const [guideCard, stateCard] = collectCards(
                        templates.guide,
                        templates.state,
                        templates.output
                    );
                    AC.message.pending = [];
                    concludeLSI(guideCard, stateCard, logCard);
                    return;
                }
                break; }
            case "output": {
                // AutoCards was called within the output modifier
                const [libraryCards, outputCards, guideCard, stateCard, logCard] = collectCards(
                    templates.library,
                    templates.output,
                    templates.guide,
                    templates.state,
                    templates.log
                );
                if (hadError()) {
                    endOutputLSI(true, LSI_DOMAIN);
                    break;
                }
                const [error, newText] = isolateLSIv2(parseCode(libraryCards, outputCards), callbackLog(logCard), LSI_DOMAIN);
                handleError(logCard, error);
                endOutputLSI(hadError(), newText);
                function endOutputLSI(displayError, newText) {
                    if (displayError) {
                        if (AC.signal.upstreamError === "\n") {
                            CODOMAIN.initialize("\n");
                        } else {
                            CODOMAIN.initialize(getStoryError() + "\n");
                        }
                        AC.message.pending = [];
                    } else {
                        CODOMAIN.initialize(newText);
                    }
                    concludeLSI(guideCard, stateCard, logCard);
                    return;
                }
                break; }
            case "initialize": {
                collectAll();
                logToCard(Internal.getCard(card => (card.title === templates.log.name)), "LSIv2 startup -> Success!");
                CODOMAIN.initialize(null);
                break; }
            }
            AC.config.LSIv2 = true;
            function parseCode(...args) {
                return (args
                    .flatMap(cardset => [cardset.primary, ...cardset.auxiliaries])
                    .flatMap(card => [card.entry, card.description])
                    .join("\n")
                );
            }
            function callbackLog(logCard) {
                return function(...args) {
                    logToCard(logCard, ...args);
                    return;
                }
            }
            function handleError(logCard, error) {
                if (!error) {
                    return;
                }
                O.f(error);
                AC.signal.upstreamError = (
                    "LSIv2 encountered an error during the on" + HOOK[0].toUpperCase() + HOOK.slice(1) + " hook"
                );
                if (error.message) {
                    AC.signal.upstreamError += ":\n";
                    if (error.stack) {
                        const stackMatch = error.stack.match(/AutoCards[\s\S]*?:\s*(\d+)\s*:\s*(\d+)/i);
                        if (stackMatch) {
                            AC.signal.upstreamError += (
                                (error.name ?? "Error") + ": " + error.message + "\n" +
                                "(line #" + stackMatch[1] + " column #" + stackMatch[2] + ")"
                            );
                        } else {
                            AC.signal.upstreamError += error.stack;
                        }
                    } else {
                        AC.signal.upstreamError += (error.name ?? "Error") + ": " + error.message;
                    }
                    AC.signal.upstreamError = cleanSpaces(AC.signal.upstreamError.trimEnd());
                }
                logToCard(logCard, AC.signal.upstreamError);
                if (getStateMessage() === AC.signal.upstreamError) {
                    state.message = AC.signal.upstreamError + " ";
                } else {
                    state.message = AC.signal.upstreamError;
                }
                return;
            }
            function hadError() {
                return (AC.signal.upstreamError !== "");
            }
            function getStoryError() {
                return getPrecedingNewlines() + ">>>\n" + AC.signal.upstreamError + "\n<<<\n";
            }
            function concludeLSI(guideCard, stateCard, logCard) {
                AC.signal.upstreamError = "";
                guideCard.description = templates.guide.description;
                guideCard.entry = templates.guide.entry;
                stateCard.entry = templates.state.entry;
                logCard.entry = templates.log.entry;
                postMessages();
                const simpleState = {...state};
                delete simpleState.LSIv2;
                stateCard.description = limitString(stringifyObject(simpleState).trim(), 999999).trimEnd();
                return;
            }
        } else {
            const cardsets = collectAll();
            for (const cardset of cardsets) {
                if ("primary" in cardset) {
                    killCard(cardset.primary);
                    for (const card of cardset.auxiliaries) {
                        killCard(card);
                    }
                } else {
                    killCard(cardset);
                }
                function killCard(card) {
                    unbanTitle(card.title);
                    eraseCard(card);
                }
            }
            AC.signal.upstreamError = "";
            CODOMAIN.initialize(LSI_DOMAIN);
        }
        // This measure ensures the Auto-Cards external API is equally available from within the inner scope of LSIv2
        // As before, call with AutoCards().API.nameOfFunction(yourArguments);
        deepMerge(AC, state.LSIv2);
        delete state.LSIv2;
        function deepMerge(target, source) {
            for (const key in source) {
                if (!source.hasOwnProperty(key)) {
                    continue;
                } else if (
                    (typeof source[key] === "object")
                    && (source[key] !== null)
                    && !Array.isArray(source[key])
                    && (typeof target[key] === "object")
                    && (target[key] !== null)
                    && (key !== "workpiece")
                    && (key !== "associations")
                ) {
                    // Recursively merge static objects
                    deepMerge(target[key], source[key]);
                } else {
                    // Directly replace values
                    target[key] = source[key];
                }
            }
            return;
        }
        function collectAll() {
            return collectCards(...Object.keys(factories).map(key => templates[key]));
        }
        // collectCards constructs, validates, repairs, retrieves, and organizes all LSIv2 script cards associated with the given arguments by iterating over the storyCards array only once! Returned elements are easily handled via array destructuring assignment
        function collectCards(...args) {
            // args: [{name: string, entry: string, description: string, singleton: boolean, position: integer}]
            const collections = O.f(args.map(({name, entry, description, singleton, position}) => {
                const collection = {
                    template: O.f({
                        type: AC.config.defaultCardType,
                        title: name,
                        keys: name,
                        entry,
                        description
                    }),
                    singleton,
                    position,
                    primary: null,
                    excess: [],
                };
                if (!singleton) {
                    collection.auxiliaries = [];
                    collection.occupied = new Set([0, 1]);
                }
                return O.s(collection);
            }));
            for (const card of storyCards) {
                O.s(card);
                for (const collection of collections) {
                    if (
                        !card.title.toLowerCase().includes(collection.template.title.toLowerCase())
                        && !card.keys.toLowerCase().includes(collection.template.title.toLowerCase())
                    ) {
                        // No match, swipe left
                        continue;
                    }
                    if (collection.singleton) {
                        setPrimary();
                        break;
                    }
                    const [extensionA, extensionB] = [card.title, card.keys].map(name => {
                        const extensionMatch = name.replace(/[^a-zA-Z0-9]/g, "").match(/\d+$/);
                        if (extensionMatch) {
                            return parseInt(extensionMatch[0], 10);
                        } else {
                            return -1;
                        }
                    });
                    if (-1 < extensionA) {
                        if (-1 < extensionB) {
                            if (collection.occupied.has(extensionA)) {
                                setAuxiliary(extensionB);
                            } else {
                                setAuxiliary(extensionA, true);
                            }
                        } else {
                            setAuxiliary(extensionA);
                        }
                    } else if (-1 < extensionB) {
                        setAuxiliary(extensionB);
                    } else {
                        setPrimary();
                    }
                    function setAuxiliary(extension, preChecked = false) {
                        if (preChecked || !collection.occupied.has(extension)) {
                            addAuxiliary(card, collection, extension);
                        } else {
                            card.title = card.keys = collection.template.title;
                            collection.excess.push(card);
                        }
                        return;
                    }
                    function setPrimary() {
                        card.title = card.keys = collection.template.title;
                        if (collection.primary === null) {
                            collection.primary = card;
                        } else {
                            collection.excess.push(card);
                        }
                        return;
                    }
                    break;
                }
            }
            for (const collection of collections) {
                banTitle(collection.template.title);
                if (collection.singleton) {
                    if (collection.primary === null) {
                        constructPrimary();
                    } else if (hasExs()) {
                        for (const card of collection.excess) {
                            eraseCard(card);
                        }
                    }
                    continue;
                } else if (collection.primary === null) {
                    if (hasExs()) {
                        collection.primary = collection.excess.shift();
                        if (hasExs() || hasAux()) {
                            applyComment(collection.primary);
                        } else {
                            collection.primary.entry = collection.template.entry;
                            collection.primary.description = collection.template.description;
                            continue;
                        }
                    } else {
                        constructPrimary();
                        if (hasAux()) {
                            applyComment(collection.primary);
                        } else {
                            continue;
                        }
                    }
                }
                if (hasExs()) {
                    for (const card of collection.excess) {
                        let extension = 2;
                        while (collection.occupied.has(extension)) {
                            extension++;
                        }
                        applyComment(card);
                        addAuxiliary(card, collection, extension);
                    }
                }
                if (hasAux()) {
                    collection.auxiliaries.sort((a, b) => {
                        return a.extension - b.extension;
                    });
                }
                function hasExs() {
                    return (0 < collection.excess.length);
                }
                function hasAux() {
                    return (0 < collection.auxiliaries.length);
                }
                function applyComment(card) {
                    card.entry = card.description = "// You may continue writing your code here";
                    return;
                }
                function constructPrimary() {
                    collection.primary = constructCard(collection.template, newCardIndex());
                    // I like my LSIv2 cards to display in the proper order once initialized uwu
                    const templateKeys = Object.keys(factories);
                    const cards = templateKeys.map(key => O.f({
                        card: Internal.getCard(card => (card.title === templates[key].name)),
                        position: templates[key].position
                    })).filter(pair => (pair.card !== null));
                    if (cards.length < templateKeys.length) {
                        return;
                    }
                    const fullCardset = cards.sort((a, b) => (a.position - b.position)).map(pair => pair.card);
                    for (const card of fullCardset) {
                        eraseCard(card);
                        card.title = card.keys;
                    }
                    storyCards.splice(newCardIndex(), 0, ...fullCardset);
                    return;
                }
            }
            function addAuxiliary(card, collection, extension) {
                collection.occupied.add(extension);
                card.title = card.keys = collection.template.title + " " + extension;
                collection.auxiliaries.push({card, extension});
                return;
            }
            return O.f(collections.map(({singleton, primary, auxiliaries}) => {
                if (singleton) {
                    return primary;
                } else {
                    return O.f({primary, auxiliaries: O.f(auxiliaries.map(({card}) => card))});
                }
            }));
        }
    } else if (AC.config.doAC) {
        // Auto-Cards is currently enabled
        // "text" represents the original text which was present before any scripts were executed
        // "TEXT" represents the script-modified version of "text" which AutoCards was called with
        // This dual scheme exists to ensure Auto-Cards is safely compatible with other scripts
        switch(HOOK) {
        case "input": {
            // AutoCards was called within the input modifier
            if ((AC.config.deleteAllAutoCards === false) && /CONFIRM\s*DELETE/i.test(TEXT)) {
                CODOMAIN.initialize("CONFIRM DELETE -> Success!");
            } else if (/\/\s*A\s*C/i.test(text)) {
                CODOMAIN.initialize(doPlayerCommands(text));
            } else if (TEXT.startsWith(" ") && readPastAction(0).text.endsWith("\n")) {
                // Just a simple little formatting bugfix for regular AID story actions
                CODOMAIN.initialize(getPrecedingNewlines() + TEXT.replace(/^\s+/, ""));
            } else {
                CODOMAIN.initialize(TEXT);
            }
            break; }
        case "context": {
            // AutoCards was called within the context modifier
            advanceChronometer();
            // Get or construct the "Configure Auto-Cards" story card
            const configureCardTemplate = getConfigureCardTemplate();
            const configureCard = getSingletonCard(true, configureCardTemplate);
            banTitle(configureCardTemplate.title);
            pinAndSortCards(configureCard);
            const bansOverwritten = (0 < AC.signal.overrideBans);
            if ((configureCard.description !== configureCardTemplate.description) || bansOverwritten) {
                const descConfigPatterns = (getConfigureCardDescription()
                    .split(Words.delimiter)
                    .slice(1)
                    .map(descPattern => (descPattern
                        .slice(0, descPattern.indexOf(":"))
                        .trim()
                        .replace(/\s+/g, "\\s*")
                    ))
                    .map(descPattern => (new RegExp("^\\s*" + descPattern + "\\s*:", "i")))
                );
                const descConfigs = configureCard.description.split(Words.delimiter).slice(1);
                if (
                    (descConfigs.length === descConfigPatterns.length)
                    && descConfigs.every((descConfig, index) => descConfigPatterns[index].test(descConfig))
                ) {
                    // All description config headers must be present and well-formed
                    let cfg = extractDescSetting(0);
                    if (AC.config.generationPrompt !== cfg) {
                        notify("Changes to your card generation prompt were successfully saved");
                        AC.config.generationPrompt = cfg;
                    }
                    cfg = extractDescSetting(1);
                    if (AC.config.compressionPrompt !== cfg) {
                        notify("Changes to your card memory compression prompt were successfully saved");
                        AC.config.compressionPrompt = cfg;
                    }
                    if (bansOverwritten) {
                        overrideBans();
                    } else if ((0 < AC.database.titles.pendingBans.length) || (0 < AC.database.titles.pendingUnbans.length)) {
                        const pendingBans = AC.database.titles.pendingBans.map(pair => pair[0]);
                        const pendingRewrites = new Set(
                            lowArr([...pendingBans, ...AC.database.titles.pendingUnbans.map(pair => pair[0])])
                        );
                        Internal.setBannedTitles([...pendingBans, ...extractDescSetting(2)
                            .split(",")
                            .filter(newBan => !pendingRewrites.has(newBan.toLowerCase().replace(/\s+/, " ").trim()))
                        ], true);
                    } else {
                        Internal.setBannedTitles(extractDescSetting(2).split(","), true);
                    }
                    function extractDescSetting(index) {
                        return descConfigs[index].replace(descConfigPatterns[index], "").trim();
                    }
                } else if (bansOverwritten) {
                    overrideBans();
                }
                configureCard.description = getConfigureCardDescription();
                function overrideBans() {
                    Internal.setBannedTitles(AC.database.titles.pendingBans.map(pair => pair[0]), true);
                    AC.signal.overrideBans = 0;
                    return;
                }
            }
            if (configureCard.entry !== configureCardTemplate.entry) {
                const oldConfig = {};
                const settings = O.f((function() {
                    const userSettings = extractSettings(configureCard.entry);
                    if (userSettings.resetallconfigsettingsandprompts !== true) {
                        return userSettings;
                    }
                    // Reset all config settings and display state change notifications only when appropriate
                    Object.assign(oldConfig, AC.config);
                    Object.assign(AC.config, getDefaultConfig());
                    AC.config.deleteAllAutoCards = oldConfig.deleteAllAutoCards;
                    AC.config.LSIv2 = oldConfig.LSIv2;
                    AC.config.defaultCardType = oldConfig.defaultCardType;
                    AC.database.titles.banned = getDefaultConfigBans();
                    configureCard.description = getConfigureCardDescription();
                    configureCard.entry = getConfigureCardEntry();
                    const defaultSettings = extractSettings(configureCard.entry);
                    if ((DEFAULT_DO_AC === false) || (userSettings.disableautocards === true)) {
                        defaultSettings.disableautocards = true;
                    }
                    notify("Restoring all settings and prompts to their default values");
                    return defaultSettings;
                })());
                O.f(oldConfig);
                if ((settings.deleteallautomaticstorycards === true) && (AC.config.deleteAllAutoCards === null)) {
                    AC.config.deleteAllAutoCards = true;
                } else if (settings.showdetailedguide === true) {
                    AC.signal.outputReplacement = Words.guide;
                }
                let cfg;
                if (parseConfig("pinthisconfigcardnearthetop", false, "pinConfigureCard")) {
                    if (cfg) {
                        pinAndSortCards(configureCard);
                        notify("The settings config card will now be pinned near the top of your story cards list");
                    } else {
                        const index = storyCards.indexOf(configureCard);
                        if (index !== -1) {
                            storyCards.splice(index, 1);
                            storyCards.push(configureCard);
                        }
                        notify("The settings config card will no longer be pinned near the top of your story cards list");
                    }
                }
                if (parseConfig("minimumturnscooldownfornewcards", true, "addCardCooldown")) {
                    const oldCooldown = AC.config.addCardCooldown;
                    AC.config.addCardCooldown = validateCooldown(cfg);
                    if (!isPendingGeneration() && !isAwaitingGeneration() && (0 < AC.generation.cooldown)) {
                        const quarterCooldown = validateCooldown(underQuarterInteger(AC.config.addCardCooldown));
                        if ((AC.config.addCardCooldown < oldCooldown) && (quarterCooldown < AC.generation.cooldown)) {
                            // Reduce the next generation's cooldown counter by a factor of 4
                            // But only if the new cooldown config is lower than it was before
                            // And also only if quarter cooldown is less than the current next gen cooldown
                            // (Just a random little user experience improvement)
                            AC.generation.cooldown = quarterCooldown;
                        } else if (oldCooldown < AC.config.addCardCooldown) {
                            if (oldCooldown === AC.generation.cooldown) {
                                AC.generation.cooldown = AC.config.addCardCooldown;
                            } else {
                                AC.generation.cooldown = validateCooldown(boundInteger(
                                    0,
                                    AC.generation.cooldown + quarterCooldown,
                                    AC.config.addCardCooldown
                                ));
                            }
                        }
                    }
                    switch(AC.config.addCardCooldown) {
                    case 9999: {
                        notify(
                            "You have disabled automatic card generation. To re-enable, simply set your cooldown config to any number lower than 9999. Or use the \"/ac\" in-game command to manually direct the card generation process"
                        );
                        break; }
                    case 1: {
                        notify(
                            "A new card will be generated during alternating game turns, but only if your story contains available titles"
                        );
                        break; }
                    case 0: {
                        notify(
                            "New cards will be immediately generated whenever valid titles exist within your recent story"
                        );
                        break; }
                    default: {
                        notify(
                            "A new card will be generated once every " + AC.config.addCardCooldown + " turns, but only if your story contains available titles"
                        );
                        break; }
                    }
                }
                if (parseConfig("newcardsuseabulletedlistformat", false, "bulletedListMode")) {
                    if (cfg) {
                        notify("New card entries will be generated using a bulleted list format");
                    } else {
                        notify("New card entries will be generated using a pure prose format");
                    }
                }
                if (parseConfig("maximumentrylengthfornewcards", true, "defaultEntryLimit")) {
                    AC.config.defaultEntryLimit = validateEntryLimit(cfg);
                    notify(
                        "New card entries will be limited to " + AC.config.defaultEntryLimit + " characters of generated text"
                    );
                }
                if (parseConfig("newcardsperformmemoryupdates", false, "defaultCardsDoMemoryUpdates")) {
                    if (cfg) {
                        notify("Newly constructed cards will begin with memory updates enabled by default");
                    } else {
                        notify("Newly constructed cards will begin with memory updates disabled by default");
                    }
                }
                if (parseConfig("cardmemorybankpreferredlength", true, "defaultMemoryLimit")) {
                    AC.config.defaultMemoryLimit = validateMemoryLimit(cfg);
                    notify(
                        "Newly constructed cards will begin with their memory bank length preference set to " + AC.config.defaultMemoryLimit + " characters of text"
                    );
                }
                if (parseConfig("memorysummarycompressionratio", true, "memoryCompressionRatio")) {
                    AC.config.memoryCompressionRatio = validateMemCompRatio(cfg);
                    notify(
                        "Freshly summarized card memory banks will be approximately " + (AC.config.memoryCompressionRatio / 10) + "x shorter than their originals"
                    );
                }
                if (parseConfig("excludeallcapsfromtitledetection", false, "ignoreAllCapsTitles")) {
                    if (cfg) {
                        notify("All-caps text will be ignored during title detection to help prevent bad cards");
                    } else {
                        notify("All-caps text may be considered during title detection processes");
                    }
                }
                if (parseConfig("alsodetecttitlesfromplayerinputs", false, "readFromInputs")) {
                    if (cfg) {
                        notify("Titles may be detected from player Do/Say/Story action inputs");
                    } else {
                        notify("Title detection will skip player Do/Say/Story action inputs for grammatical leniency");
                    }
                }
                if (parseConfig("minimumturnsagefortitledetection", true, "minimumLookBackDistance")) {
                    AC.config.minimumLookBackDistance = validateMinLookBackDist(cfg);
                    notify(
                        "Titles and names mentioned in your story may become eligible for future card generation attempts once they are at least " + AC.config.minimumLookBackDistance + " actions old"
                    );
                }
                cfg = settings.uselivescriptinterfacev2;
                if (typeof cfg === "boolean") {
                    if (AC.config.LSIv2 === null) {
                        if (cfg) {
                            AC.config.LSIv2 = true;
                            state.LSIv2 = AC;
                            AutoCards("initialize");
                            notify("Live Script Interface v2 is now embedded within your adventure!");
                        }
                    } else {
                        if (!cfg) {
                            AC.config.LSIv2 = null;
                            notify("Live Script Interface v2 has been removed from your adventure");
                        }
                    }
                }
                if (parseConfig("logdebugdatainaseparatecard" , false, "showDebugData")) {
                    if (data === null) {
                        if (cfg) {
                            notify("State may now be viewed within the \"Debug Data\" story card");
                        } else {
                            notify("The \"Debug Data\" story card has been removed");
                        }
                    } else if (cfg) {
                        notify("Debug data will be shared with the \"Critical Data\" story card to conserve memory");
                    } else {
                        notify("Debug mode has been disabled");
                    }
                }
                if ((settings.disableautocards === true) && (AC.signal.forceToggle !== true)) {
                    disableAutoCards();
                    break;
                } else {
                    // Apply the new card entry and proceed to implement Auto-Cards onContext
                    configureCard.entry = getConfigureCardEntry();
                }
                function parseConfig(settingsKey, isNumber, configKey) {
                    cfg = settings[settingsKey];
                    if (isNumber) {
                        return checkConfig("number");
                    } else if (!checkConfig("boolean")) {
                        return false;
                    }
                    AC.config[configKey] = cfg;
                    function checkConfig(type) {
                        return ((typeof cfg === type) && (
                            (notEmptyObj(oldConfig) && (oldConfig[configKey] !== cfg))
                            || (AC.config[configKey] !== cfg)
                        ));
                    }
                    return true;
                }
            }
            if (AC.signal.forceToggle === false) {
                disableAutoCards();
                break;
            }
            AC.signal.forceToggle = null;
            if (0 < AC.chronometer.postpone) {
                CODOMAIN.initialize(TEXT);
                break;
            }
            // Fully implement Auto-Cards onContext
            const forceStep = AC.signal.recheckRetryOrErase;
            const currentTurn = getTurn();
            const nearestUnparsedAction = boundInteger(0, currentTurn - AC.config.minimumLookBackDistance);
            if (AC.signal.recheckRetryOrErase || (nearestUnparsedAction <= AC.database.titles.lastActionParsed)) {
                // The player erased or retried an unknown number of actions
                // Purge recent candidates and perform a safety recheck
                if (nearestUnparsedAction <= AC.database.titles.lastActionParsed) {
                    AC.signal.recheckRetryOrErase = true;
                } else {
                    AC.signal.recheckRetryOrErase = false;
                }
                AC.database.titles.lastActionParsed = boundInteger(-1, nearestUnparsedAction - 8);
                for (let i = AC.database.titles.candidates.length - 1; 0 <= i; i--) {
                    const candidate = AC.database.titles.candidates[i];
                    for (let j = candidate.length - 1; 0 < j; j--) {
                        if (AC.database.titles.lastActionParsed < candidate[j]) {
                            candidate.splice(j, 1);
                        }
                    }
                    if (candidate.length <= 1) {
                        AC.database.titles.candidates.splice(i, 1);
                    }
                }
            }
            const pendingCandidates = new Map();
            if ((0 < nearestUnparsedAction) && (AC.database.titles.lastActionParsed < nearestUnparsedAction)) {
                const actions = [];
                for (
                    let actionToParse = AC.database.titles.lastActionParsed + 1;
                    actionToParse <= nearestUnparsedAction;
                    actionToParse++
                ) {
                    // I wrote this whilst sleep-deprived, somehow it works
                    const lookBack = currentTurn - actionToParse - (function() {
                        if (isDoSayStory(readPastAction(0).type)) {
                            // Inputs count as 2 actions instead of 1, conditionally offset lookBack by 1
                            return 0;
                        } else {
                            return 1;
                        }
                    })();
                    if (history.length <= lookBack) {
                        // history cannot be indexed with a negative integer
                        continue;
                    }
                    const action = readPastAction(lookBack);
                    const thisTextHash = new StringsHashed(4096).add(action.text).serialize();
                    if (actionToParse === nearestUnparsedAction) {
                        if (AC.signal.recheckRetryOrErase || (thisTextHash === AC.database.titles.lastTextHash)) {
                            // Additional safety to minimize duplicate candidate additions during retries or erases
                            AC.signal.recheckRetryOrErase = true;
                            break;
                        } else {
                            // Action parsing will proceed
                            AC.database.titles.lastActionParsed = nearestUnparsedAction;
                            AC.database.titles.lastTextHash = thisTextHash;
                        }
                    } else if (
                        // Special case where a consecutive retry>erase>continue cancels out
                        AC.signal.recheckRetryOrErase
                        && (actionToParse === (nearestUnparsedAction - 1))
                        && (thisTextHash === AC.database.titles.lastTextHash)
                    ) {
                        AC.signal.recheckRetryOrErase = false;
                    }
                    actions.push([action, actionToParse]);
                }
                if (!AC.signal.recheckRetryOrErase) {
                    for (const [action, turn] of actions) {
                        if (
                            (action.type === "see")
                            || (action.type === "unknown")
                            || (!AC.config.readFromInputs && isDoSayStory(action.type))
                            || /^[^\p{Lu}]*$/u.test(action.text)
                            || action.text.includes("<<<")
                            || /\/\s*A\s*C/i.test(action.text)
                            || /CONFIRM\s*DELETE/i.test(action.text)
                        ) {
                            // Skip see actions
                            // Skip input actions (only if input title detection has been disabled in the config)
                            // Skip strings without capital letters
                            // Skip utility actions
                            continue;
                        }
                        const words = (prettifyEmDashes(action.text)
                            // Nuh uh
                            .replace(/[‚Äú‚Äù]/g, "\"").replace(/[‚Äò‚Äô]/g, "'").replaceAll("¬¥", "`")
                            .replaceAll("„ÄÇ", ".").replaceAll("Ôºü", "?").replaceAll("ÔºÅ", "!")
                            // Replace special clause opening punctuation with colon ":" terminators
                            .replace(/(^|\s+)["'`]\s*/g, ": ").replace(/\s*[\(\[{]\s*/g, ": ")
                            // Likewise for end-quotes (curbs a common AI grammar mistake)
                            .replace(/\s*,?\s*["'`](?:\s+|$)/g, ": ")
                            // Replace funky wunky symbols with regular spaces
                            .replace(/[ÿüÿå¬´¬ª¬ø¬°‚Äû‚Äú‚Ä¶¬ßÔºå„ÄÅ\*_~><\)\]}#"`\s]/g, " ")
                            // Replace some mid-sentence punctuation symbols with a placeholder word
                            .replace(/\s*[‚Äî;,\/\\]\s*/g, " %@% ")
                            // Replace "I", "I'm", "I'd", "I'll", and "I've" with a placeholder word
                            .replace(/(?:^|\s+|-)I(?:'(?:m|d|ll|ve))?(?:\s+|-|$)/gi, " %@% ")
                            // Remove "'s" only if not followed by a letter
                            .replace(/'s(?![a-zA-Z])/g, "")
                            // Replace "s'" with "s" only if preceded but not followed by a letter
                            .replace(/(?<=[a-zA-Z])s'(?![a-zA-Z])/g, "s")
                            // Remove apostrophes not between letters (preserve contractions like "don't")
                            .replace(/(?<![a-zA-Z])'(?![a-zA-Z])/g, "")
                            // Remove a leading bullet
                            .replace(/^\s*-+\s*/, "")
                            // Replace common honorifics with a placeholder word
                            .replace(buildKiller(Words.honorifics), " %@% ")
                            // Remove common abbreviations
                            .replace(buildKiller(Words.abbreviations), " ")
                            // Fix end punctuation
                            .replace(/\s+\.(?![a-zA-Z])/g, ".").replace(/\.\.+/g, ".")
                            .replace(/\s+\?(?![a-zA-Z])/g, "?").replace(/\?\?+/g, "?")
                            .replace(/\s+!(?![a-zA-Z])/g, "!").replace(/!!+/g, "!")
                            .replace(/\s+:(?![a-zA-Z])/g, ":").replace(/::+/g, ":")
                            // Colons are treated as substitute end-punctuation, apply the capitalization rule
                            .replace(/:\s+(\S)/g, (_, next) => ": " + next.toUpperCase())
                            // Condense consecutive whitespace
                            .trim().replace(/\s+/g, " ")
                        ).split(" ");
                        if (!Array.isArray(words) || (words.length < 2)) {
                            continue;
                        }
                        const titles = [];
                        const incompleteTitle = [];
                        let previousWordTerminates = true;
                        for (let i = 0; i < words.length; i++) {
                            let word = words[i];
                            if (startsWithTerminator()) {
                                // This word begins on a terminator, push the preexisting incomplete title to titles and proceed with the next sentence's beginning
                                pushTitle();
                                previousWordTerminates = true;
                                // Ensure no leading terminators remain
                                while ((word !== "") && startsWithTerminator()) {
                                    word = word.slice(1);
                                }
                            }
                            if (word === "") {
                                continue;
                            } else if (previousWordTerminates) {
                                // We cannot detect titles from sentence beginnings due to sentence capitalization rules. The previous sentence was recently terminated, implying the current series of capitalized words (plus lowercase minor words) occurs near the beginning of the current sentence
                                if (endsWithTerminator()) {
                                    continue;
                                } else if (startsWithUpperCase()) {
                                    if (isMinorWord(word)) {
                                        // Special case where a capitalized minor word precedes a named entity, clear the previous termination status
                                        previousWordTerminates = false;
                                    }
                                    // Otherwise, proceed without clearing
                                } else if (!isMinorWord(word) && !/^(?:and|&)(?:$|[\.\?!:]$)/.test(word)) {
                                    // Previous sentence termination status is cleared by the first new non-minor lowercase word encountered during forward iteration through the action text's words
                                    previousWordTerminates = false;
                                }
                                continue;
                            }
                            // Words near the beginning of this sentence have been skipped, proceed with named entity detection using capitalization rules. An incomplete title will be pushed to titles if A) a non-minor lowercase word is encountered, B) three consecutive minor words occur in a row, C) a terminator symbol is encountered at the end of a word. Otherwise, continue pushing words to the incomplete title
                            if (endsWithTerminator()) {
                                previousWordTerminates = true;
                                while ((word !== "") && endsWithTerminator()) {
                                    word = word.slice(0, -1);
                                }
                                if (word === "") {
                                    pushTitle();
                                    continue;
                                }
                            }
                            if (isMinorWord(word)) {
                                if (0 < incompleteTitle.length) {
                                    // Titles cannot start with a minor word
                                    if (
                                        (2 < incompleteTitle.length) && !(isMinorWord(incompleteTitle[incompleteTitle.length - 1]) && isMinorWord(incompleteTitle[incompleteTitle.length - 2]))
                                    ) {
                                        // Titles cannot have 3 or more consecutive minor words in a row
                                        pushTitle();
                                        continue;
                                    } else {
                                        // Titles may contain minor words in their middles. Ex: "Ace of Spades"
                                        incompleteTitle.push(word.toLowerCase());
                                    }
                                }
                            } else if (startsWithUpperCase()) {
                                // Add this proper noun to the incomplete title
                                incompleteTitle.push(word);
                            } else {
                                // The full title has a non-minor lowercase word to its immediate right
                                pushTitle();
                                continue;
                            }
                            if (previousWordTerminates) {
                                pushTitle();
                            }
                            function pushTitle() {
                                while (
                                    (1 < incompleteTitle.length)
                                    && isMinorWord(incompleteTitle[incompleteTitle.length - 1])
                                ) {
                                    incompleteTitle.pop();
                                }
                                if (0 < incompleteTitle.length) {
                                    titles.push(incompleteTitle.join(" "));
                                    // Empty the array
                                    incompleteTitle.length = 0;
                                }
                                return;
                            }
                            function isMinorWord(testWord) {
                                return Words.minor.includes(testWord.toLowerCase());
                            }
                            function startsWithUpperCase() {
                                return /^\p{Lu}/u.test(word);
                            }
                            function startsWithTerminator() {
                                return /^[\.\?!:]/.test(word);
                            }
                            function endsWithTerminator() {
                                return /[\.\?!:]$/.test(word);
                            }
                        }
                        for (let i = titles.length - 1; 0 <= i; i--) {
                            titles[i] = formatTitle(titles[i]).newTitle;
                            if (titles[i] === "" || (
                                AC.config.ignoreAllCapsTitles
                                && (2 < titles[i].replace(/[^a-zA-Z]/g, "").length)
                                && (titles[i] === titles[i].toUpperCase())
                            )) {
                                titles.splice(i, 1);
                            }
                        }
                        // Remove duplicates
                        const uniqueTitles = [...new Set(titles)];
                        if (uniqueTitles.length === 0) {
                            continue;
                        } else if (
                            // No reason to keep checking long past the max lookback distance
                            (currentTurn < 256)
                            && (action.type === "start")
                            // This is only used here so it doesn't need its own AC.config property or validation
                            && (DEFAULT_BAN_TITLES_FROM_OPENING !== false)
                        ) {
                            // Titles in the opening prompt are banned by default, hopefully accounting for the player character's name and other established setting details
                            uniqueTitles.forEach(title => banTitle(title));
                        } else {
                            // Schedule new titles for later insertion within the candidates database
                            for (const title of uniqueTitles) {
                                const pendingHashKey = title.toLowerCase();
                                if (pendingCandidates.has(pendingHashKey)) {
                                    // Consolidate pending candidates with matching titles but different turns
                                    pendingCandidates.get(pendingHashKey).turns.push(turn);
                                } else {
                                    pendingCandidates.set(pendingHashKey, O.s({title, turns: [turn]}));
                                }
                            }
                        }
                        function buildKiller(words) {
                            return (new RegExp(("(?:^|\\s+|-)(?:" + (words
                                .map(word => word.replace(".", "\\."))
                                .join("|")
                            ) + ")(?:\\s+|-|$)"), "gi"));
                        }
                    }
                }
            }
            // Measure the minimum and maximum turns of occurance for all title candidates
            let minTurn = currentTurn;
            let maxTurn = 0;
            for (let i = AC.database.titles.candidates.length - 1; 0 <= i; i--) {
                const candidate = AC.database.titles.candidates[i];
                const title = candidate[0];
                if (isUsedOrBanned(title) || isNamed(title)) {
                    // Retroactively ensure AC.database.titles.candidates contains no used / banned titles
                    AC.database.titles.candidates.splice(i, 1);
                } else {
                    const pendingHashKey = title.toLowerCase();
                    if (pendingCandidates.has(pendingHashKey)) {
                        // This candidate title matches one of the pending candidates, collect the pending turns
                        candidate.push(...pendingCandidates.get(pendingHashKey).turns);
                        // Remove this pending candidate
                        pendingCandidates.delete(pendingHashKey);
                    }
                    if (2 < candidate.length) {
                        // Ensure all recorded turns of occurance are unique for this candidate
                        // Sort the turns from least to greatest
                        const sortedTurns = [...new Set(candidate.slice(1))].sort((a, b) => (a - b));
                        if (625 < sortedTurns.length) {
                            sortedTurns.splice(0, sortedTurns.length - 600);
                        }
                        candidate.length = 1;
                        candidate.push(...sortedTurns);
                    }
                    setCandidateTurnBounds(candidate);
                }
            }
            for (const pendingCandidate of pendingCandidates.values()) {
                // Insert any remaining pending candidates (validity has already been ensured)
                const newCandidate = [pendingCandidate.title, ...pendingCandidate.turns];
                setCandidateTurnBounds(newCandidate);
                AC.database.titles.candidates.push(newCandidate);
            }
            const isCandidatesSorted = (function() {
                if (425 < AC.database.titles.candidates.length) {
                    // Sorting a large title candidates database is computationally expensive
                    sortCandidates();
                    AC.database.titles.candidates.splice(400);
                    // Flag this operation as complete for later consideration
                    return true;
                } else {
                    return false;
                }
            })();
            Internal.getUsedTitles();
            for (const titleKey in AC.database.memories.associations) {
                if (isAuto(titleKey)) {
                    // Reset the lifespan counter
                    AC.database.memories.associations[titleKey][0] = 999;
                } else if (AC.database.memories.associations[titleKey][0] < 1) {
                    // Forget this set of memory associations
                    delete AC.database.memories.associations[titleKey];
                } else if (!isAwaitingGeneration()) {
                    // Decrement the lifespan counter
                    AC.database.memories.associations[titleKey][0]--;
                }
            }
            // This copy of TEXT may be mutated
            let context = TEXT;
            const titleHeaderPatternGlobal = /\s*{\s*titles?\s*:\s*([\s\S]*?)\s*}\s*/gi;
            // Card events govern the parsing of memories from raw context as well as card memory bank injection
            const cardEvents = (function() {
                // Extract memories from the initial text (not TEXT as called from within the context modifier!)
                const contextMemories = (function() {
                    const memoriesMatch = text.match(/Memories\s*:\s*([\s\S]*?)\s*(?:Recent\s*Story\s*:|$)/i);
                    if (!memoriesMatch) {
                        return new Set();
                    }
                    const uniqueMemories = new Set(isolateMemories(memoriesMatch[1]));
                    if (uniqueMemories.size === 0) {
                        return uniqueMemories;
                    }
                    const duplicatesHashed = StringsHashed.deserialize(AC.database.memories.duplicates, 65536);
                    const duplicateMemories = new Set();
                    const seenMemories = new Set();
                    for (const memoryA of uniqueMemories) {
                        if (duplicatesHashed.has(memoryA)) {
                            // Remove to ensure the insertion order for this duplicate changes
                            duplicatesHashed.remove(memoryA);
                            duplicateMemories.add(memoryA);
                        } else if ((function() {
                            for (const memoryB of seenMemories) {
                                if (0.42 < similarityScore(memoryA, memoryB)) {
                                    // This memory is too similar to another memory
                                    duplicateMemories.add(memoryA);
                                    return false;
                                }
                            }
                            return true;
                        })()) {
                            seenMemories.add(memoryA);
                        }
                    }
                    if (0 < duplicateMemories.size) {
                        // Add each near duplicate's hashcode to AC.database.memories.duplicates
                        // Then remove duplicates from uniqueMemories and the context window
                        for (const duplicate of duplicateMemories) {
                            duplicatesHashed.add(duplicate);
                            uniqueMemories.delete(duplicate);
                            context = context.replaceAll("\n" + duplicate, "");
                        }
                        // Only the 2000 most recent duplicate memory hashcodes are remembered
                        AC.database.memories.duplicates = duplicatesHashed.latest(2000).serialize();
                    }
                    return uniqueMemories;
                })();
                const leftBoundary = "^|\\s|\"|'|‚Äî|\\(|\\[|{";
                const rightBoundary = "\\s|\\.|\\?|!|,|;|\"|'|‚Äî|\\)|\\]|}|$";
                // Murder, homicide if you will, nothing to see here
                const theKiller = new RegExp("(?:" + leftBoundary + ")the[\\s\\S]*$", "i");
                const peerageKiller = new RegExp((
                    "(?:" + leftBoundary + ")(?:" + Words.peerage.join("|") + ")(?:" + rightBoundary + ")"
                ), "gi");
                const events = new Map();
                for (const contextMemory of contextMemories) {
                    for (const titleKey of auto) {
                        if (!(new RegExp((
                            "(?<=" + leftBoundary + ")" + (titleKey
                                .replace(theKiller, "")
                                .replace(peerageKiller, "")
                                .replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
                            ) + "(?=" + rightBoundary + ")"
                        ), "i")).test(contextMemory)) {
                            continue;
                        }
                        // AC card titles found in active memories will promote card events
                        if (events.has(titleKey)) {
                            events.get(titleKey).pendingMemories.push(contextMemory);
                            continue;
                        }
                        events.set(titleKey, O.s({
                            pendingMemories: [contextMemory],
                            titleHeader: ""
                        }));
                    }
                }
                const titleHeaderMatches = [...context.matchAll(titleHeaderPatternGlobal)];
                for (const [titleHeader, title] of titleHeaderMatches) {
                    if (!isAuto(title)) {
                        continue;
                    }
                    // Unique title headers found in context will promote card events
                    const titleKey = title.toLowerCase();
                    if (events.has(titleKey)) {
                        events.get(titleKey).titleHeader = titleHeader;
                        continue;
                    }
                    events.set(titleKey, O.s({
                        pendingMemories: [],
                        titleHeader: titleHeader
                    }));
                }
                return events;
            })();
            // Remove auto card title headers from active story card entries and contextualize their respective memory banks
            // Also handle the growth and maintenance of card memory banks
            let isRemembering = false;
            for (const card of storyCards) {
                // Iterate over each card to handle pending card events and forenames/surnames
                const titleHeaderMatcher = /^{title: \s*([\s\S]*?)\s*}/;
                let breakForCompression = isPendingCompression();
                if (breakForCompression) {
                    break;
                } else if (!card.entry.startsWith("{title: ")) {
                    continue;
                } else if (exceedsMemoryLimit()) {
                    const titleHeaderMatch = card.entry.match(titleHeaderMatcher);
                    if (titleHeaderMatch && isAuto(titleHeaderMatch[1])) {
                        prepareMemoryCompression(titleHeaderMatch[1].toLowerCase());
                        break;
                    }
                }
                // Handle card events
                const lowerEntry = card.entry.toLowerCase();
                for (const titleKey of cardEvents.keys()) {
                    if (!lowerEntry.startsWith("{title: " + titleKey + "}")) {
                        continue;
                    }
                    const cardEvent = cardEvents.get(titleKey);
                    if (
                        (0 < cardEvent.pendingMemories.length)
                        && /{\s*updates?\s*:\s*true\s*,\s*limits?\s*:[\s\S]*?}/i.test(card.description)
                    ) {
                        // Add new card memories
                        const associationsHashed = (function() {
                            if (titleKey in AC.database.memories.associations) {
                                return StringsHashed.deserialize(AC.database.memories.associations[titleKey][1], 65536);
                            } else {
                                AC.database.memories.associations[titleKey] = [999, ""];
                                return new StringsHashed(65536);
                            }
                        })();
                        const oldMemories = isolateMemories(extractCardMemories().text);
                        for (let i = 0; i < cardEvent.pendingMemories.length; i++) {
                            if (associationsHashed.has(cardEvent.pendingMemories[i])) {
                                // Remove first to alter the insertion order
                                associationsHashed.remove(cardEvent.pendingMemories[i]);
                            } else if (!oldMemories.some(oldMemory => (
                                (0.8 < similarityScore(oldMemory, cardEvent.pendingMemories[i]))
                            ))) {
                                // Ensure no near-duplicate memories are appended
                                card.description += "\n- " + cardEvent.pendingMemories[i];
                            }
                            associationsHashed.add(cardEvent.pendingMemories[i]);
                        }
                        AC.database.memories.associations[titleKey][1] = associationsHashed.latest(3500).serialize();
                        if (associationsHashed.size() === 0) {
                            delete AC.database.memories.associations[titleKey];
                        }
                        if (exceedsMemoryLimit()) {
                            breakForCompression = prepareMemoryCompression(titleKey);
                            break;
                        }
                    }
                    if (cardEvent.titleHeader !== "") {
                        // Replace this card's title header in context
                        const cardMemoriesText = extractCardMemories().text;
                        if (cardMemoriesText === "") {
                            // This card contains no card memories to contextualize
                            context = context.replace(cardEvent.titleHeader, "\n\n");
                        } else {
                            // Insert card memories within context and ensure they occur uniquely
                            const cardMemories = cardMemoriesText.split("\n").map(cardMemory => cardMemory.trim());
                            for (const cardMemory of cardMemories) {
                                if (25 < cardMemory.length) {
                                    context = (context
                                        .replaceAll(cardMemory, "<#>")
                                        .replaceAll(cardMemory.replace(/^-+\s*/, ""), "<#>")
                                    );
                                }
                            }
                            context = context.replace(cardEvent.titleHeader, (
                                "\n\n{%@MEM@%" + cardMemoriesText + "%@MEM@%}\n"
                            ));
                            isRemembering = true;
                        }
                    }
                    cardEvents.delete(titleKey);
                    break;
                }
                if (breakForCompression) {
                    break;
                }
                // Simplify auto-card titles which contain an obvious surname
                const titleHeaderMatch = card.entry.match(titleHeaderMatcher);
                if (!titleHeaderMatch) {
                    continue;
                }
                const [oldTitleHeader, oldTitle] = titleHeaderMatch;
                if (!isAuto(oldTitle)) {
                    continue;
                }
                const surname = isNamed(oldTitle, true);
                if (typeof surname !== "string") {
                    continue;
                }
                const newTitle = oldTitle.replace(" " + surname, "");
                const [oldTitleKey, newTitleKey] = [oldTitle, newTitle].map(title => title.toLowerCase());
                if (oldTitleKey === newTitleKey) {
                    continue;
                }
                // Preemptively mitigate some global state considered within the formatTitle scope
                clearTransientTitles();
                AC.database.titles.used = ["%@%"];
                [used, forenames, surnames].forEach(nameset => nameset.add("%@%"));
                // Premature optimization is the root of all evil
                const newKey = formatTitle(newTitle).newKey;
                clearTransientTitles();
                if (newKey === "") {
                    Internal.getUsedTitles();
                    continue;
                }
                if (oldTitleKey in AC.database.memories.associations) {
                    AC.database.memories.associations[newTitleKey] = AC.database.memories.associations[oldTitleKey];
                    delete AC.database.memories.associations[oldTitleKey];
                }
                if (AC.compression.titleKey === oldTitleKey) {
                    AC.compression.titleKey = newTitleKey;
                }
                card.entry = card.entry.replace(oldTitleHeader, oldTitleHeader.replace(oldTitle, newTitle));
                card.keys = buildKeys(card.keys.replaceAll(" " + surname, ""), newKey);
                Internal.getUsedTitles();
                function exceedsMemoryLimit() {
                    return ((function() {
                        const memoryLimitMatch = card.description.match(/limits?\s*:\s*(\d+)\s*}/i);
                        if (memoryLimitMatch) {
                            return validateMemoryLimit(parseInt(memoryLimitMatch[1], 10));
                        } else {
                            return AC.config.defaultMemoryLimit;
                        }
                    })() < (function() {
                        const cardMemories = extractCardMemories();
                        if (cardMemories.missing) {
                            return card.description;
                        } else {
                            return cardMemories.text;
                        }
                    })().length);
                }
                function prepareMemoryCompression(titleKey) {
                    AC.compression.oldMemoryBank = isolateMemories(extractCardMemories().text);
                    if (AC.compression.oldMemoryBank.length === 0) {
                        return false;
                    }
                    AC.compression.completed = 0;
                    AC.compression.titleKey = titleKey;
                    AC.compression.vanityTitle = cleanSpaces(card.title.trim());
                    AC.compression.responseEstimate = (function() {
                        const responseEstimate = estimateResponseLength();
                        if (responseEstimate === -1) {
                            return 1400
                        } else {
                            return responseEstimate;
                        }
                    })();
                    AC.compression.lastConstructIndex = -1;
                    AC.compression.newMemoryBank = [];
                    return true;
                }
                function extractCardMemories() {
                    const memoryHeaderMatch = card.description.match(
                        /(?<={\s*updates?\s*:[\s\S]*?,\s*limits?\s*:[\s\S]*?})[\s\S]*$/i
                    );
                    if (memoryHeaderMatch) {
                        return O.f({missing: false, text: cleanSpaces(memoryHeaderMatch[0].trim())});
                    } else {
                        return O.f({missing: true, text: ""});
                    }
                }
            }
            // Remove repeated memories plus any remaining title headers
            context = (context
                .replace(/(\s*<#>\s*)+/g, "\n")
                .replace(titleHeaderPatternGlobal, "\n\n")
                .replace(/World\s*Lore\s*:\s*/i, "World Lore:\n")
                .replace(/Memories\s*:\s*(?=Recent\s*Story\s*:|$)/i, "")
            );
            // Prompt the AI to generate a new card entry, compress an existing card's memories, or continue the story
            let isGenerating = false;
            let isCompressing = false;
            if (isPendingGeneration()) {
                promptGeneration();
            } else if (isAwaitingGeneration()) {
                AC.generation.workpiece = AC.generation.pending.shift();
                promptGeneration();
            } else if (isPendingCompression()) {
                promptCompression();
            } else if (AC.signal.recheckRetryOrErase) {
                // Do nothing üòú
            } else if ((AC.generation.cooldown <= 0) && (0 < AC.database.titles.candidates.length)) {
                // Prepare to automatically construct a new plot-relevant story card by selecting a title
                let selectedTitle = (function() {
                    if (AC.database.titles.candidates.length === 1) {
                        return AC.database.titles.candidates[0][0];
                    } else if (!isCandidatesSorted) {
                        sortCandidates();
                    }
                    const mostRelevantTitle = AC.database.titles.candidates[0][0];
                    if ((AC.database.titles.candidates.length < 16) || (Math.random() < 0.6667)) {
                        // Usually, 2/3 of the time, the most relevant title is selected
                        return mostRelevantTitle;
                    }
                    // Occasionally (1/3 of the time once the candidates databases has at least 16 titles) make a completely random selection between the top 4 most recently occuring title candidates which are NOT the top 2 most relevant titles. Note that relevance !== recency
                    // This gives non-character titles slightly better odds of being selected for card generation due to the relevance sorter's inherent bias towards characters; they tend to appear far more often in prose
                    return (AC.database.titles.candidates
                        // Create a shallow copy to avoid modifying AC.database.titles.candidates itself
                        // Add index to preserve original positions whenever ties occur during sorting
                        .map((candidate, index) => ({candidate, index}))
                        // Sort by each candidate's most recent turn
                        .sort((a, b) => {
                            const turnDiff = b.candidate[b.candidate.length - 1] - a.candidate[a.candidate.length - 1];
                            if (turnDiff === 0) {
                                // Don't change indices in the case of a tie
                                return (a.index - b.index);
                            } else {
                                // No tie here, sort by recency
                                return turnDiff;
                            }
                        })
                        // Get the top 6 most recent titles (4 + 2 because the top 2 relevant titles may be present)
                        .slice(0, 6)
                        // Extract only the title names
                        .map(element => element.candidate[0])
                        // Exclude the top 2 most relevant titles
                        .filter(title => ((title !== mostRelevantTitle) && (title !== AC.database.titles.candidates[1][0])))
                        // Ensure only 4 titles remain
                        .slice(0, 4)
                    )[Math.floor(Math.random() * 4)];
                })();
                while (!Internal.generateCard(O.f({title: selectedTitle}))) {
                    // This is an emergency precaution, I don't expect the interior of this while loop to EVER execute
                    // That said, it's crucial for the while condition be checked at least once, because Internal.generateCard appends an element to AC.generation.pending as a side effect
                    const lowerSelectedTitle = formatTitle(selectedTitle).newTitle.toLowerCase();
                    const index = AC.database.titles.candidates.findIndex(candidate => {
                        return (formatTitle(candidate[0]).newTitle.toLowerCase() === lowerSelectedTitle);
                    });
                    if (index === -1) {
                        // Should be impossible
                        break;
                    }
                    AC.database.titles.candidates.splice(index, 1);
                    if (AC.database.titles.candidates.length === 0) {
                        break;
                    }
                    selectedTitle = AC.database.titles.candidates[0][0];
                }
                if (isAwaitingGeneration()) {
                    // Assign the workpiece so card generation may fully commence!
                    AC.generation.workpiece = AC.generation.pending.shift();
                    promptGeneration();
                } else if (isPendingCompression()) {
                    promptCompression();
                }
            } else if (
                (AC.chronometer.step || forceStep)
                && (0 < AC.generation.cooldown)
                && (AC.config.addCardCooldown !== 9999)
            ) {
                AC.generation.cooldown--;
            }
            if (shouldTrimContext()) {
                // Truncate context based on AC.signal.maxChars, begin by individually removing the oldest sentences from the recent story portion of the context window
                const recentStoryPattern = /Recent\s*Story\s*:\s*([\s\S]*?)(%@GEN@%|%@COM@%|\s\[\s*Author's\s*note\s*:|$)/i;
                const recentStoryMatch = context.match(recentStoryPattern);
                if (recentStoryMatch) {
                    const recentStory = recentStoryMatch[1];
                    let sentencesJoined = recentStory;
                    // Split by the whitespace chars following each sentence (without consuming)
                    const sentences = splitBySentences(recentStory);
                    // [minimum num of story sentences] = ([max chars for context] / 6) / [average chars per sentence]
                    const sentencesMinimum = Math.ceil(
                        (AC.signal.maxChars / 6) / (
                            boundInteger(1, context.length) / boundInteger(1, sentences.length)
                        )
                    ) + 1;
                    do {
                        if (sentences.length < sentencesMinimum) {
                            // A minimum of n many recent story sentences must remain
                            // Where n represents a sentence count equal to roughly 16.7% of the full context chars
                            break;
                        }
                        // Remove the first (oldest) recent story sentence
                        sentences.shift();
                        // Check if the total length exceeds the AC.signal.maxChars limit
                        sentencesJoined = sentences.join("");
                    } while (AC.signal.maxChars < (context.length - recentStory.length + sentencesJoined.length + 3));
                    // Rebuild the context with the truncated recentStory
                    context = context.replace(recentStoryPattern, "Recent Story:\n" + sentencesJoined + recentStoryMatch[2]);
                }
                if (isRemembering && shouldTrimContext()) {
                    // Next remove loaded card memories (if any) with top-down priority, one card at a time
                    do {
                        // This matcher relies on its case-sensitivity
                        const cardMemoriesMatch = context.match(/{%@MEM@%([\s\S]+?)%@MEM@%}/);
                        if (!cardMemoriesMatch) {
                            break;
                        }
                        context = context.replace(cardMemoriesMatch[0], (cardMemoriesMatch[0]
                            .replace(cardMemoriesMatch[1], "")
                            // Set the MEM tags to lowercase to avoid repeated future matches
                            .toLowerCase()
                        ));
                    } while (AC.signal.maxChars < (context.length + 3));
                }
                if (shouldTrimContext()) {
                    // If the context is still too long, just trim from the beginning I guess ü§∑‚Äç‚ôÄÔ∏è
                    context = context.slice(context.length - AC.signal.maxChars + 1);
                }
            }
            if (isRemembering) {
                // Card memory flags serve no further purpose
                context = (context
                    // Case-insensitivity is crucial here
                    .replace(/(?<={%@MEM@%)\s*/gi, "")
                    .replace(/\s*(?=%@MEM@%})/gi, "")
                    .replace(/{%@MEM@%%@MEM@%}\s?/gi, "")
                    .replaceAll("{%@MEM@%", "{ Memories:\n")
                    .replaceAll("%@MEM@%}", " }")
                );
            }
            if (isGenerating) {
                // Likewise for the card entry generation delimiter
                context = context.replaceAll("%@GEN@%", "");
            } else if (isCompressing) {
                // Or the (mutually exclusive) card memory compression delimiter
                context = context.replaceAll("%@COM@%", "");
            }
            CODOMAIN.initialize(context);
            function isolateMemories(memoriesText) {
                return (memoriesText
                    .split("\n")
                    .map(memory => cleanSpaces(memory.trim().replace(/^-+\s*/, "")))
                    .filter(memory => (memory !== ""))
                );
            }
            function isAuto(title) {
                return auto.has(title.toLowerCase());
            }
            function promptCompression() {
                isGenerating = false;
                const cardEntryText = (function() {
                    const card = getAutoCard(AC.compression.titleKey);
                    if (card === null) {
                        return null;
                    }
                    const entryLines = formatEntry(card.entry).trimEnd().split("\n");
                    if (Object.is(entryLines[0].trim(), "")) {
                        return "";
                    }
                    for (let i = 0; i < entryLines.length; i++) {
                        entryLines[i] = entryLines[i].trim();
                        if (/[a-zA-Z]$/.test(entryLines[i])) {
                            entryLines[i] += ".";
                        }
                        entryLines[i] += " ";
                    }
                    return entryLines.join("");
                })();
                if (cardEntryText === null) {
                    // Safety measure
                    resetCompressionProperties();
                    return;
                }
                repositionAN();
                // The "%COM%" substring serves as a temporary delimiter for later context length trucation
                context = context.trimEnd() + "\n\n" + cardEntryText + (
                    [...AC.compression.newMemoryBank, ...AC.compression.oldMemoryBank].join(" ")
                ) + "%@COM@%\n\n" + (function() {
                                    const memoryConstruct = (function() {
                    // If this is a retry, slightly increase the size of the next chunk.
                    if (AC.compression.lastConstructIndex !== -1) {
                        AC.compression.lastConstructIndex = boundInteger(
                            0, AC.compression.lastConstructIndex + 1, AC.compression.oldMemoryBank.length - 1
                        );
                    }

                    const threshold = (AC.config.memoryCompressionRatio / 10) * AC.compression.responseEstimate;
                    let currentConstruct = [];
                    
                    // "Safe" loop: only add memories if they fit.
                    for (let i = 0; i < AC.compression.oldMemoryBank.length; i++) {
                        const nextMemory = AC.compression.oldMemoryBank[i];
                        const potentialConstruct = [...currentConstruct, nextMemory];
                        
                        // If we've hit our minimum size and adding the next memory would exceed the threshold, stop here.
                        if (currentConstruct.length > 0 && threshold < potentialConstruct.join(" ").length) {
                            break;
                        }

                        // Otherwise, it fits. Add it and update the index.
                        currentConstruct.push(nextMemory);
                        AC.compression.lastConstructIndex = i;
                    }
                    
                    return currentConstruct.join(" ");
                })();
                    // Fill all %{title} placeholders
                    const precursorPrompt = insertTitle(AC.config.compressionPrompt, AC.compression.vanityTitle).trim();
                    const memoryPlaceholderPattern = /(?:[%\$]+\s*|[%\$]*){+\s*memor(y|ies)\s*}+/gi;
                    if (memoryPlaceholderPattern.test(precursorPrompt)) {
                        // Fill all %{memory} placeholders with a selection of pending old memories
                        return precursorPrompt.replace(memoryPlaceholderPattern, memoryConstruct);
                    } else {
                        // Append the partial entry to the end of context
                        return precursorPrompt + "\n\n" + memoryConstruct;
                    }
                })() + "\n\n";
                isCompressing = true;
                return;
            }
            function promptGeneration() {
                repositionAN();
                // All %{title} placeholders were already filled during this workpiece's initialization
                // The "%GEN%" substring serves as a temporary delimiter for later context length trucation
                context = context.trimEnd() + "%@GEN@%\n\n" + (function() {
                    // For context only, remove the title header from this workpiece's partially completed entry
                    const partialEntry = formatEntry(AC.generation.workpiece.entry);
                    const entryPlaceholderPattern = /(?:[%\$]+\s*|[%\$]*){+\s*entry\s*}+/gi;
                    if (entryPlaceholderPattern.test(AC.generation.workpiece.prompt)) {
                        // Fill all %{entry} placeholders with the partial entry
                        return AC.generation.workpiece.prompt.replace(entryPlaceholderPattern, partialEntry);
                    } else {
                        // Append the partial entry to the end of context
                        return AC.generation.workpiece.prompt.trimEnd() + "\n\n" + partialEntry;
                    }
                })();
                isGenerating = true;
                return;
            }
            function repositionAN() {
                // Move the Author's Note further back in context during card generation (should still be considered)
                const authorsNotePattern = /\s*(\[\s*Author's\s*note\s*:[\s\S]*\])\s*/i;
                const authorsNoteMatch = context.match(authorsNotePattern);
                if (!authorsNoteMatch) {
                    return;
                }
                const leadingSpaces = context.match(/^\s*/)[0];
                context = context.replace(authorsNotePattern, " ").trimStart();
                const recentStoryPattern = /\s*Recent\s*Story\s*:\s*/i;
                if (recentStoryPattern.test(context)) {
                    // Remove author's note from its original position and insert above "Recent Story:\n"
                    context = (context
                        .replace(recentStoryPattern, "\n\n" + authorsNoteMatch[1] + "\n\nRecent Story:\n")
                        .trimStart()
                    );
                } else {
                    context = authorsNoteMatch[1] + "\n\n" + context;
                }
                context = leadingSpaces + context;
                return;
            }
            function sortCandidates() {
                if (AC.database.titles.candidates.length < 2) {
                    return;
                }
                const turnRange = boundInteger(1, maxTurn - minTurn);
                const recencyExponent = Math.log10(turnRange) + 1.85;
                // Sort the database of available title candidates by relevance
                AC.database.titles.candidates.sort((a, b) => {
                    return relevanceScore(b) - relevanceScore(a);
                });
                function relevanceScore(candidate) {
                    // weight = (((turn - minTurn) / (maxTurn - minTurn)) + 1)^(log10(maxTurn - minTurn) + 1.85)
                    return candidate.slice(1).reduce((sum, turn) => {
                        // Apply exponential scaling to give far more weight to recent turns
                        return sum + Math.pow((
                            // The recency weight's exponent scales by log10(turnRange) + 1.85
                            // Shhh don't question it üòú
                            ((turn - minTurn) / turnRange) + 1
                        ), recencyExponent);
                    }, 0);
                }
                return;
            }
            function shouldTrimContext() {
                return (AC.signal.maxChars <= context.length);
            }
            function setCandidateTurnBounds(candidate) {
                // candidate: ["Example Title", 0, 1, 2, 3]
                minTurn = boundInteger(0, minTurn, candidate[1]);
                maxTurn = boundInteger(candidate[candidate.length - 1], maxTurn);
                return;
            }
            function disableAutoCards() {
                AC.signal.forceToggle = null;
                // Auto-Cards has been disabled
                AC.config.doAC = false;
                // Deconstruct the "Configure Auto-Cards" story card
                unbanTitle(configureCardTemplate.title);
                eraseCard(configureCard);
                // Signal the construction of "Edit to enable Auto-Cards" during the next onOutput hook
                AC.signal.swapControlCards = true;
                // Post a success message
                notify("Disabled! Use the \"Edit to enable Auto-Cards\" story card to undo");
                CODOMAIN.initialize(TEXT);
                return;
            }
            break; }
        case "output": {
            // AutoCards was called within the output modifier
            const output = prettifyEmDashes(TEXT);
            if (0 < AC.chronometer.postpone) {
                // Do not capture or replace any outputs during this turn
                promoteAmnesia();
                if (permitOutput()) {
                    CODOMAIN.initialize(output);
                }
            } else if (AC.signal.swapControlCards) {
                if (permitOutput()) {
                    CODOMAIN.initialize(output);
                }
            } else if (isPendingGeneration()) {
                const textClone = prettifyEmDashes(text);
                AC.chronometer.amnesia = 0;
                AC.generation.completed++;
                const generationsRemaining = (function() {
                    if (
                        textClone.includes("\"")
                        || /(?<=^|\s|‚Äî|\(|\[|{)sa(ys?|id)(?=\s|\.|\?|!|,|;|‚Äî|\)|\]|}|$)/i.test(textClone)
                    ) {
                        // Discard full outputs containing "say" or quotations
                        // To build coherent entries, the AI must not attempt to continue the story
                        return skip(estimateRemainingGens());
                    }
                    const oldSentences = (splitBySentences(formatEntry(AC.generation.workpiece.entry))
                        .map(sentence => sentence.trim())
                        .filter(sentence => (2 < sentence.length))
                    );
                    const seenSentences = new Set();
                    const entryAddition = splitBySentences(textClone
                        .replace(/[\*_~]/g, "")
                        .replace(/:+/g, "#")
                        .replace(/\s+/g, " ")
                    ).map(sentence => (sentence
                        .trim()
                        .replace(/^-+\s*/, "")
                    )).filter(sentence => (
                        // Remove empty strings
                        (sentence !== "")
                        // Remove colon ":" headers or other stinky symbols because me no like üò†
                        && !/[#><@]/.test(sentence)
                        // Remove previously repeated sentences
                        && !oldSentences.some(oldSentence => (0.75 < similarityScore(oldSentence, sentence)))
                        // Remove repeated sentences from within entryAddition itself
                        && ![...seenSentences].some(seenSentence => (0.75 < similarityScore(seenSentence, sentence)))
                        // Simply ensure this sentence is henceforth unique
                        && seenSentences.add(sentence)
                    )).join(" ").trim() + " ";
                    if (entryAddition === " ") {
                        return skip(estimateRemainingGens());
                    } else if (
                        /^{title:[\s\S]*?}$/.test(AC.generation.workpiece.entry.trim())
                        && (AC.generation.workpiece.entry.length < 111)
                    ) {
                        AC.generation.workpiece.entry += "\n" + entryAddition;
                    } else {
                        AC.generation.workpiece.entry += entryAddition;
                    }
                    if (AC.generation.workpiece.limit < AC.generation.workpiece.entry.length) {
                        let exit = false;
                        let truncatedEntry = AC.generation.workpiece.entry.trimEnd();
                        const sentences = splitBySentences(truncatedEntry);
                        for (let i = sentences.length - 1; 0 <= i; i--) {
                            if (!sentences[i].includes("\n")) {
                                sentences.splice(i, 1);
                                truncatedEntry = sentences.join("").trimEnd();
                                if (truncatedEntry.length <= AC.generation.workpiece.limit) {
                                    break;
                                }
                                continue;
                            }
                            // Lines only matter for initial entries provided via AutoCards().API.generateCard
                            const lines = sentences[i].split("\n");
                            for (let j = lines.length - 1; 0 <= j; j--) {
                                lines.splice(j, 1);
                                sentences[i] = lines.join("\n");
                                truncatedEntry = sentences.join("").trimEnd();
                                if (truncatedEntry.length <= AC.generation.workpiece.limit) {
                                    // Exit from both loops
                                    exit = true;
                                    break;
                                }
                            }
                            if (exit) {
                                break;
                            }
                        }
                        if (truncatedEntry.length < 150) {
                            // Disregard the previous sentence/line-based truncation attempt
                            AC.generation.workpiece.entry = limitString(
                                AC.generation.workpiece.entry, AC.generation.workpiece.limit
                            );
                            // Attempt to remove the last word/fragment
                            truncatedEntry = AC.generation.workpiece.entry.replace(/\s*\S+$/, "");
                            if (150 <= truncatedEntry) {
                                AC.generation.workpiece.entry = truncatedEntry;
                            }
                        } else {
                            AC.generation.workpiece.entry = truncatedEntry;
                        }
                        return 0;
                    } else if ((AC.generation.workpiece.limit - 50) <= AC.generation.workpiece.entry.length) {
                        AC.generation.workpiece.entry = AC.generation.workpiece.entry.trimEnd();
                        return 0;
                    }
                    function skip(remaining) {
                        if (AC.generation.permitted <= AC.generation.completed) {
                            AC.generation.workpiece.entry = AC.generation.workpiece.entry.trimEnd();
                            return 0;
                        }
                        return remaining;
                    }
                    function estimateRemainingGens() {
                        const responseEstimate = estimateResponseLength();
                        if (responseEstimate === -1) {
                            return 1;
                        }
                        const remaining = boundInteger(1, Math.round(
                            (150 + AC.generation.workpiece.limit - AC.generation.workpiece.entry.length) / responseEstimate
                        ));
                        if (AC.generation.permitted === 34) {
                            AC.generation.permitted = boundInteger(6, Math.floor(3.5 * remaining), 32);
                        }
                        return remaining;
                    }
                    return skip(estimateRemainingGens());
                })();
                postOutputMessage(textClone, AC.generation.completed / Math.min(
                    AC.generation.permitted,
                    AC.generation.completed + generationsRemaining
                ));
                if (generationsRemaining <= 0) {
                    notify("\"" + AC.generation.workpiece.title + "\" was successfully added to your story cards!");
                    constructCard(O.f({
                        type: AC.generation.workpiece.type,
                        title: AC.generation.workpiece.title,
                        keys: AC.generation.workpiece.keys,
                        entry: (function() {
                            if (!AC.config.bulletedListMode) {
                                return AC.generation.workpiece.entry;
                            }
                            const sentences = splitBySentences(
                                formatEntry(
                                    AC.generation.workpiece.entry.replace(/\s+/g, " ")
                                ).replace(/:+/g, "#")
                            ).map(sentence => {
                                sentence = (sentence
                                    .replaceAll("#", ":")
                                    .trim()
                                    .replace(/^-+\s*/, "")
                                );
                                if (sentence.length < 12) {
                                    return sentence;
                                } else {
                                    return "\n- " + sentence.replace(/\s*[\.\?!]+$/, "");
                                }
                            });
                            const titleHeader = "{title: " + AC.generation.workpiece.title + "}";
                            if (sentences.every(sentence => (sentence.length < 12))) {
                                const sentencesJoined = sentences.join(" ").trim();
                                if (sentencesJoined === "") {
                                    return titleHeader;
                                } else {
                                    return limitString(titleHeader + "\n" + sentencesJoined, 2000);
                                }
                            }
                            for (let i = sentences.length - 1; 0 <= i; i--) {
                                const bulletedEntry = cleanSpaces(titleHeader + sentences.join(" ")).trimEnd();
                                if (bulletedEntry.length <= 2000) {
                                    return bulletedEntry;
                                }
                                if (sentences.length === 1) {
                                    break;
                                }
                                sentences.splice(i, 1);
                            }
                            return limitString(AC.generation.workpiece.entry, 2000);
                        })(),
                        description: AC.generation.workpiece.description,
                    }), newCardIndex());
                    AC.generation.cooldown = AC.config.addCardCooldown;
                    AC.generation.completed = 0;
                    AC.generation.permitted = 34;
                    AC.generation.workpiece = O.f({});
                    clearTransientTitles();
                }
            } else if (isPendingCompression()) {
                const textClone = prettifyEmDashes(text);
                AC.chronometer.amnesia = 0;
                AC.compression.completed++;
                const compressionsRemaining = (function() {
                    const newMemory = (textClone
                        // Remove some dumb stuff
                        .replace(/^[\s\S]*:/g, "")
                        .replace(/[\*_~#><@\[\]{}`\\]/g, " ")
                        // Remove bullets
                        .trim().replace(/^-+\s*/, "").replace(/\s*-+$/, "").replace(/\s*-\s+/g, " ")
                        // Condense consecutive whitespace
                        .replace(/\s+/g, " ")
                    );
                    if ((AC.compression.oldMemoryBank.length - 1) <= AC.compression.lastConstructIndex) {
                        // Terminate this compression cycle; the memory construct cannot grow any further
                        AC.compression.newMemoryBank.push(newMemory);
                        return 0;
                    } else if ((newMemory.trim() !== "") && (newMemory.length < buildMemoryConstruct().length)) {
                        // Good output, preserve and then proceed onwards
                        AC.compression.oldMemoryBank.splice(0, AC.compression.lastConstructIndex + 1);
                        AC.compression.lastConstructIndex = -1;
                        AC.compression.newMemoryBank.push(newMemory);
                    } else {
                        // Bad output, discard and then try again
                        AC.compression.responseEstimate += 200;
                    }
                    return boundInteger(1, joinMemoryBank(AC.compression.oldMemoryBank).length) / AC.compression.responseEstimate;
                })();
                postOutputMessage(textClone, AC.compression.completed / (AC.compression.completed + compressionsRemaining));
                if (compressionsRemaining <= 0) {
                    const card = getAutoCard(AC.compression.titleKey);
                    if (card === null) {
                        notify(
                            "Failed to apply summarized memories for \"" + AC.compression.vanityTitle + "\" due to a missing or invalid AC card title header!"
                        );
                    } else {
                        const memoryHeaderMatch = card.description.match(
                            /(?<={\s*updates?\s*:[\s\S]*?,\s*limits?\s*:[\s\S]*?})[\s\S]*$/i
                        );
                        if (memoryHeaderMatch) {
                            // Update the card memory bank
                            notify("Memories for \"" + AC.compression.vanityTitle + "\" were successfully summarized!");
                            card.description = card.description.replace(memoryHeaderMatch[0], (
                                "\n" + joinMemoryBank(AC.compression.newMemoryBank)
                            ));
                        } else {
                            notify(
                                "Failed to apply summarizes memories for \"" + AC.compression.vanityTitle + "\" due to a missing or invalid AC card memory header!"
                            );
                        }
                    }
                    resetCompressionProperties();
                } else if (AC.compression.completed === 1) {
                    notify("Summarizing excess memories for \"" + AC.compression.vanityTitle + "\"");
                }
                function joinMemoryBank(memoryBank) {
                    return cleanSpaces("- " + memoryBank.join("\n- "));
                }
            } else if (permitOutput()) {
                CODOMAIN.initialize(output);
            }
            concludeOutputBlock((function() {
                if (AC.signal.swapControlCards) {
                    return getConfigureCardTemplate();
                } else {
                    return null;
                }
            })())
            function postOutputMessage(textClone, ratio) {
                if (!permitOutput()) {
                    // Do nothing
                } else if (0.5 < similarityScore(textClone, output)) {
                    // To improve Auto-Cards' compatability with other scripts, I only bother to replace the output text when the original and new output texts have a similarity score above a particular threshold. Otherwise, I may safely assume the output text has already been replaced by another script and thus skip this step.
                    CODOMAIN.initialize(
                        getPrecedingNewlines() + ">>> please select \"continue\" (" + Math.round(ratio * 100) + "%) <<<\n\n"
                    );
                } else {
                    CODOMAIN.initialize(output);
                }
                return;
            }
            break; }
        default: {
            CODOMAIN.initialize(TEXT);
            break; }
        }
        // Get an individual story card reference via titleKey
        function getAutoCard(titleKey) {
            return Internal.getCard(card => card.entry.toLowerCase().startsWith("{title: " + titleKey + "}"));
        }
        function buildMemoryConstruct() {
            return (AC.compression.oldMemoryBank
                .slice(0, AC.compression.lastConstructIndex + 1)
                .join(" ")
            );
        }
        // Estimate the average AI response char count based on recent continue outputs
        function estimateResponseLength() {
            if (!Array.isArray(history) || (history.length === 0)) {
                return -1;
            }
            const charCounts = [];
            for (let i = 0; i < history.length; i++) {
                const action = readPastAction(i);
                if ((action.type === "continue") && !action.text.includes("<<<")) {
                    charCounts.push(action.text.length);
                }
            }
            if (charCounts.length < 7) {
                if (charCounts.length === 0) {
                    return -1;
                } else if (charCounts.length < 4) {
                    return boundInteger(350, charCounts[0]);
                }
                charCounts.splice(3);
            }
            return boundInteger(175, Math.floor(
                charCounts.reduce((sum, charCount) => {
                    return sum + charCount;
                }, 0) / charCounts.length
            ));
        }
        // Evalute how similar two strings are on the range [0, 1]
        function similarityScore(strA, strB) {
            if (strA === strB) {
                return 1;
            }
            // Normalize both strings for further comparison purposes
            const [cleanA, cleanB] = [strA, strB].map(str => (str
                .replace(/[0-9\s]/g, " ")
                .trim()
                .replace(/  +/g, " ")
                .toLowerCase()
            ));
            if (cleanA === cleanB) {
                return 1;
            }
            // Compute the Levenshtein distance
            const [lengthA, lengthB] = [cleanA, cleanB].map(str => str.length);
            // I love DP ‚ù§Ô∏è (dynamic programming)
            const dp = Array(lengthA + 1).fill(null).map(() => Array(lengthB + 1).fill(0));
            for (let i = 0; i <= lengthA; i++) {
                dp[i][0] = i;
            }
            for (let j = 0; j <= lengthB; j++) {
                dp[0][j] = j;
            }
            for (let i = 1; i <= lengthA; i++) {
                for (let j = 1; j <= lengthB; j++) {
                    if (cleanA[i - 1] === cleanB[j - 1]) {
                        // No cost if chars match, swipe right üòé
                        dp[i][j] = dp[i - 1][j - 1];
                    } else {
                        dp[i][j] = Math.min(
                            // Deletion
                            dp[i - 1][j] + 1,
                            // Insertion
                            dp[i][j - 1] + 1,
                            // Substitution
                            dp[i - 1][j - 1] + 1
                        );
                    }
                }
            }
            // Convert distance to similarity score (1 - (distance / maxLength))
            return 1 - (dp[lengthA][lengthB] / Math.max(lengthA, lengthB));
        }
        function splitBySentences(prose) {
            // Don't split sentences on honorifics or abbreviations such as "Mr.", "Mrs.", "etc."
            return (prose
                .replace(new RegExp("(?<=\\s|\"|\\(|‚Äî|\\[|'|{|^)(?:" + ([...Words.honorifics, ...Words.abbreviations]
                    .map(word => word.replace(".", ""))
                    .join("|")
                ) + ")\\.", "gi"), "$1%@%")
                .split(/(?<=[\.\?!:]["\)'\]}]?\s+)(?=[^\p{Ll}\s])/u)
                .map(sentence => sentence.replaceAll("%@%", "."))
            );
        }
        function formatEntry(partialEntry) {
            const cleanedEntry = cleanSpaces(partialEntry
                .replace(/^{title:[\s\S]*?}/, "")
                .replace(/[#><@*_~]/g, "")
                .trim()
            ).replace(/(?<=^|\n)-+\s*/g, "");
            if (cleanedEntry === "") {
                return "";
            } else {
                return cleanedEntry + " ";
            }
        }
        // Resolve malformed em dashes (common AI cliche)
        function prettifyEmDashes(str) {
            return str.replace(/(?<!^\s*)(?: - | ?‚Äì ?)(?!\s*$)/g, "‚Äî");
        }
        function getConfigureCardTemplate() {
            const names = getControlVariants().configure;
            return O.f({
                type: AC.config.defaultCardType,
                title: names.title,
                keys: names.keys,
                entry: getConfigureCardEntry(),
                description: getConfigureCardDescription()
            });
        }
        function getConfigureCardEntry() {
            return prose(
                "> Auto-Cards automatically creates and updates plot-relevant story cards while you play. You may configure the following settings by replacing \"false\" with \"true\" (and vice versa) or by adjusting numbers for the appropriate settings.",
                "> Disable Auto-Cards: false",
                "> Show detailed guide: false",
                "> Delete all automatic story cards: false",
                "> Reset all config settings and prompts: false",
                "> Pin this config card near the top: " + AC.config.pinConfigureCard,
                "> Minimum turns cooldown for new cards: " + AC.config.addCardCooldown,
                "> New cards use a bulleted list format: " + AC.config.bulletedListMode,
                "> Maximum entry length for new cards: " + AC.config.defaultEntryLimit,
                "> New cards perform memory updates: " + AC.config.defaultCardsDoMemoryUpdates,
                "> Card memory bank preferred length: " + AC.config.defaultMemoryLimit,
                "> Memory summary compression ratio: " + AC.config.memoryCompressionRatio,
                "> Exclude all-caps from title detection: " + AC.config.ignoreAllCapsTitles,
                "> Also detect titles from player inputs: " + AC.config.readFromInputs,
                "> Minimum turns age for title detection: " + AC.config.minimumLookBackDistance,
                "> Use Live Script Interface v2: " + (AC.config.LSIv2 !== null),
                "> Log debug data in a separate card: " + AC.config.showDebugData
            );
        }
        function getConfigureCardDescription() {
            return limitString(O.v(prose(
                Words.delimiter,
                "> AI prompt to generate new cards:",
                limitString(AC.config.generationPrompt.trim(), 4350).trimEnd(),
                Words.delimiter,
                "> AI prompt to summarize card memories:",
                limitString(AC.config.compressionPrompt.trim(), 4350).trimEnd(),
                Words.delimiter,
                "> Titles banned from new card creation:",
                AC.database.titles.banned.join(", ")
            )), 9850);
        }
    } else {
        // Auto-Cards is currently disabled
        switch(HOOK) {
        case "input": {
            if (/\/\s*A\s*C/i.test(text)) {
                CODOMAIN.initialize(doPlayerCommands(text));
            } else {
                CODOMAIN.initialize(TEXT);
            }
            break; }
        case "context": {
            // AutoCards was called within the context modifier
            advanceChronometer();
            // Get or construct the "Edit to enable Auto-Cards" story card
            const enableCardTemplate = getEnableCardTemplate();
            const enableCard = getSingletonCard(true, enableCardTemplate);
            banTitle(enableCardTemplate.title);
            pinAndSortCards(enableCard);
            if (AC.signal.forceToggle) {
                enableAutoCards();
            } else if (enableCard.entry !== enableCardTemplate.entry) {
                if ((extractSettings(enableCard.entry)?.enableautocards === true) && (AC.signal.forceToggle !== false)) {
                    // Use optional chaining to check the existence of enableautocards before accessing its value
                    enableAutoCards();
                } else {
                    // Repair the damaged card entry
                    enableCard.entry = enableCardTemplate.entry;
                }
            }
            AC.signal.forceToggle = null;
            CODOMAIN.initialize(TEXT);
            function enableAutoCards() {
                // Auto-Cards has been enabled
                AC.config.doAC = true;
                // Deconstruct the "Edit to enable Auto-Cards" story card
                unbanTitle(enableCardTemplate.title);
                eraseCard(enableCard);
                // Signal the construction of "Configure Auto-Cards" during the next onOutput hook
                AC.signal.swapControlCards = true;
                // Post a success message
                notify("Enabled! You may now edit the \"Configure Auto-Cards\" story card");
                return;
            }
            break; }
        case "output": {
            // AutoCards was called within the output modifier
            promoteAmnesia();
            if (permitOutput()) {
                CODOMAIN.initialize(TEXT);
            }
            concludeOutputBlock((function() {
                if (AC.signal.swapControlCards) {
                    return getEnableCardTemplate();
                } else {
                    return null;
                }
            })());
            break; }
        default: {
            CODOMAIN.initialize(TEXT);
            break; }
        }
        function getEnableCardTemplate() {
            const names = getControlVariants().enable;
            return O.f({
                type: AC.config.defaultCardType,
                title: names.title,
                keys: names.keys,
                entry: prose(
                    "> Auto-Cards automatically creates and updates plot-relevant story cards while you play. To enable this system, simply edit the \"false\" below to say \"true\" instead!",
                    "> Enable Auto-Cards: false"),
                description: "Perform any Do/Say/Story/Continue action within your adventure to apply this change!"
            });
        }
    }
    function hoistConst() { return (class Const {
        // This helps me debug stuff uwu
        #constant;
        constructor(...args) {
            if (args.length !== 0) {
                this.constructor.#throwError([[(args.length === 1), "Const cannot be instantiated with a parameter"], ["Const cannot be instantiated with parameters"]]);
            } else {
                O.f(this);
                return this;
            }
        }
        declare(...args) {
            if (args.length !== 0) {
                this.constructor.#throwError([[(args.length === 1), "Instances of Const cannot be declared with a parameter"], ["Instances of Const cannot be declared with parameters"]]);
            } else if (this.#constant === undefined) {
                this.#constant = null;
                return this;
            } else if (this.#constant === null) {
                this.constructor.#throwError("Instances of Const cannot be redeclared");
            } else {
                this.constructor.#throwError("Instances of Const cannot be redeclared after initialization");
            }
        }
        initialize(...args) {
            if (args.length !== 1) {
                this.constructor.#throwError([[(args.length === 0), "Instances of Const cannot be initialized without a parameter"], ["Instances of Const cannot be initialized with multiple parameters"]]);
            } else if (this.#constant === null) {
                this.#constant = [args[0]];
                return this;
            } else if (this.#constant === undefined) {
                this.constructor.#throwError("Instances of Const cannot be initialized before declaration");
            } else {
                this.constructor.#throwError("Instances of Const cannot be reinitialized");
            }
        }
        read(...args) {
            if (args.length !== 0) {
                this.constructor.#throwError([[(args.length === 1), "Instances of Const cannot be read with a parameter"], ["Instances of Const cannot read with any parameters"]]);
            } else if (Array.isArray(this.#constant)) {
                return this.#constant[0];
            } else if (this.#constant === null) {
                this.constructor.#throwError("Despite prior declaration, instances of Const cannot be read before initialization");
            } else {
                this.constructor.#throwError("Instances of Const cannot be read before initialization");
            }
        }
        // An error condition is paired with an error message [condition, message], call #throwError with an array of pairs to throw the message corresponding with the first true condition [[cndtn1, msg1], [cndtn2, msg2], [cndtn3, msg3], ...] The first conditionless array element always evaluates to true ('else')
        static #throwError(...args) {
            // Look, I thought I was going to use this more at the time okay
            const [conditionalMessagesTable] = args;
            const codomain = new Const().declare();
            const error = O.f(new Error((function() {
                const codomain = new Const().declare();
                if (Array.isArray(conditionalMessagesTable)) {
                    const chosenPair = conditionalMessagesTable.find(function(...args) {
                        const [pair] = args;
                        const codomain = new Const().declare();
                        if (Array.isArray(pair)) {
                            if ((pair.length === 1) && (typeof pair[0] === "string")) {
                                codomain.initialize(true);
                            } else if (
                                (pair.length === 2)
                                && (typeof pair[0] === "boolean")
                                && (typeof pair[1] === "string")
                            ) {
                                codomain.initialize(pair[0]);
                            } else {
                                Const.#throwError("Const.#throwError encountered an invalid array element of conditionalMessagesTable");
                            }
                        } else {
                            Const.#throwError("Const.#throwError encountered a non-array element within conditionalMessagesTable");
                        }
                        return codomain.read();
                    });
                    if (Array.isArray(chosenPair)) {
                        if (chosenPair.length === 1) {
                            codomain.initialize(chosenPair[0]);
                        } else {
                            codomain.initialize(chosenPair[1]);
                        }
                    } else {
                        codomain.initialize("Const.#throwError was not called with any true conditions");
                    }
                } else if (typeof conditionalMessagesTable === "string") {
                    codomain.initialize(conditionalMessagesTable);
                } else {
                    codomain.initialize("Const.#throwError could not parse the given argument");
                }
                return codomain.read();
            })()));
            if (error.stack) {
                codomain.initialize(error.stack
                    .replace(/\(<isolated-vm>:/gi, "(")
                    .replace(/Error:|at\s*(?:#throwError|Const.(?:declare|initialize|read)|new\s*Const)\s*\(\d+:\d+\)/gi, "")
                    .replace(/AutoCards\s*\((\d+):(\d+)\)\s*at\s*<isolated-vm>:\d+:\d+\s*$/i, "AutoCards ($1:$2)")
                    .trim()
                    .replace(/\s+/g, " ")
                );
            } else {
                codomain.initialize(error.message);
            }
            throw codomain.read();
        }
    }); }
    function hoistO() { return (class O {
        // Some Object class methods are annoyingly verbose for how often I use them üëø
        static f(obj) {
            return Object.freeze(obj);
        }
        static v(base) {
            return see(Words.copy) + base;
        }
        static s(obj) {
            return Object.seal(obj);
        }
    }); }
    function hoistWords() { return (class Words { static #cache = {}; static {
        // Each word list is initialized only once before being cached!
        const wordListInitializers = {
            // Special-cased honorifics which are excluded from titles and ignored during split-by-sentences operations
            honorifics: () => [
                "mr.", "ms.", "mrs.", "dr."
            ],
            // Other special-cased abbreviations used to reformat titles and split-by-sentences
            abbreviations: () => [
                "sr.", "jr.", "etc.", "st.", "ex.", "inc."
            ],
            // Lowercase minor connector words which may exist within titles
            minor: () => [
                "&", "the", "for", "of", "le", "la", "el"
            ],
            // Removed from shortened titles for improved memory detection and trigger keword assignments
            peerage: () => [
                "sir", "lord", "lady", "king", "queen", "majesty", "duke", "duchess", "noble", "royal", "emperor", "empress", "great", "prince", "princess", "count", "countess", "baron", "baroness", "archduke", "archduchess", "marquis", "marquess", "viscount", "viscountess", "consort", "grand", "sultan", "sheikh", "tsar", "tsarina", "czar", "czarina", "viceroy", "monarch", "regent", "imperial", "sovereign", "president", "prime", "minister", "nurse", "doctor", "saint", "general", "private", "commander", "captain", "lieutenant", "sergeant", "admiral", "marshal", "baronet", "emir", "chancellor", "archbishop", "bishop", "cardinal", "abbot", "abbess", "shah", "maharaja", "maharani", "councillor", "squire", "lordship", "ladyship", "monseigneur", "mayor", "princeps", "chief", "chef", "their", "my", "his", "him", "he'd", "her", "she", "she'd", "you", "your", "yours", "you'd", "you've", "you'll", "yourself", "mine", "myself", "highness", "excellency", "farmer", "sheriff", "officer", "detective", "investigator", "miss", "mister", "colonel", "professor", "teacher", "agent", "heir", "heiress", "master", "mistress", "headmaster", "headmistress", "principal", "papa", "mama", "mommy", "daddy", "mother", "father", "grandma", "grandpa", "aunt", "auntie", "aunty", "uncle", "cousin", "sister", "brother", "holy", "holiness", "almighty", "senator", "congressman"
            ],
            // Common named entities represent special-cased INVALID card titles. Because these concepts are already abundant within the AI's training data, generating story cards for any of these would be both annoying and superfluous. Therefore, Words.entities is accessed during banned titles initialization to prevent their appearance
            entities: () => [
                // Seasons
                "spring", "summer", "autumn", "fall", "winter",
                // Holidays
                "halloween", "christmas", "thanksgiving", "easter", "hanukkah", "passover", "ramadan", "eid", "diwali", "new year", "new year eve", "valentine day", "oktoberfest",
                // People terms
                "mom", "dad", "child", "grandmother", "grandfather", "ladies", "gentlemen", "gentleman", "slave",
                // Capitalizable pronoun thingys
                "his", "him", "he'd", "her", "she", "she'd", "you", "your", "yours", "you'd", "you've", "you'll", "you're", "yourself", "mine", "myself", "this", "that",
                // Religious figures & deities
                "god", "jesus", "buddha", "allah", "christ",
                // Religious texts & concepts
                "bible", "holy bible", "qur'an", "quran", "hadith", "tafsir", "tanakh", "talmud", "torah", "vedas", "vatican", "paganism", "pagan",
                // Religions & belief systems
                "hindu", "hinduism", "christianity", "islam", "jew", "judaism", "taoism", "buddhist", "buddhism", "catholic", "baptist",
                // Common locations
                "earth", "moon", "sun", "new york city", "london", "paris", "tokyo", "beijing", "mumbai", "sydney", "berlin", "moscow", "los angeles", "san francisco", "chicago", "miami", "seattle", "vancouver", "toronto", "ottawa", "mexico city", "rio de janeiro", "cape town", "sao paulo", "bangkok", "delhi", "amsterdam", "seoul", "shanghai", "new delhi", "atlanta", "jerusalem", "africa", "north america", "south america", "central america", "asia", "north africa", "south africa", "boston", "rome", "america", "siberia", "new england", "manhattan", "bavaria", "catalonia", "greenland", "hong kong", "singapore",
                // Countries & political entities
                "china", "india", "japan", "germany", "france", "spain", "italy", "canada", "australia", "brazil", "south africa", "russia", "north korea", "south korea", "iran", "iraq", "syria", "saudi arabia", "afghanistan", "pakistan", "uk", "britain", "england", "scotland", "wales", "northern ireland", "usa", "united states", "united states of america", "mexico", "turkey", "greece", "portugal", "poland", "netherlands", "belgium", "sweden", "norway", "finland", "denmark",
                // Organizations & unions
                "united nations", "european union", "state", "nato", "nfl", "nba", "fbi", "cia", "harvard", "yale", "princeton", "ivy league", "little league", "nasa", "nsa", "noaa", "osha", "nascar", "daytona 500", "grand prix", "wwe", "mba", "superbowl",
                // Currencies
                "dollar", "euro", "pound", "yen", "rupee", "peso", "franc", "dinar", "bitcoin", "ethereum", "ruble", "won", "dirham",
                // Landmarks
                "sydney opera house", "eiffel tower", "statue of liberty", "big ben", "great wall of china", "taj mahal", "pyramids of giza", "grand canyon", "mount everest",
                // Events
                "world war i", "world war 1", "wwi", "wwii", "world war ii", "world war 2", "wwii", "ww2", "cold war", "brexit", "american revolution", "french revolution", "holocaust", "cuban missile crisis",
                // Companies
                "google", "microsoft", "apple", "amazon", "facebook", "tesla", "ibm", "intel", "samsung", "sony", "coca-cola", "nike", "ford", "chevy", "pontiac", "chrysler", "volkswagen", "lambo", "lamborghini", "ferrari", "pizza hut", "taco bell", "ai dungeon", "openai", "mcdonald", "mcdonalds", "kfc", "burger king", "disney",
                // Nationalities & languages
                "english", "french", "spanish", "german", "italian", "russian", "chinese", "japanese", "korean", "arabic", "portuguese", "hindi", "american", "canadian", "mexican", "brazilian", "indian", "australian", "egyptian", "greek", "swedish", "norwegian", "danish", "dutch", "turkish", "iranian", "ukraine", "asian", "british", "european", "polish", "thai", "vietnamese", "filipino", "malaysian", "indonesian", "finnish", "estonian", "latvian", "lithuanian", "czech", "slovak", "hungarian", "romanian", "bulgarian", "serbian", "croatian", "bosnian", "slovenian", "albanian", "georgian", "armenian", "azerbaijani", "kazakh", "uzbek", "mongolian", "hebrew", "persian", "pashto", "urdu", "bengali", "tamil", "telugu", "marathi", "gujarati", "swahili", "zulu", "xhosa", "african", "north african", "south african", "north american", "south american", "central american", "colombian", "argentinian", "chilean", "peruvian", "venezuelan", "ecuadorian", "bolivian", "paraguayan", "uruguayan", "cuban", "dominican", "arabian", "roman", "haitian", "puerto rican", "moroccan", "algerian", "tunisian", "saudi", "emirati", "qatarian", "bahraini", "omani", "yemeni", "syrian", "lebanese", "iraqi", "afghan", "pakistani", "sri lankan", "burmese", "laotian", "cambodian", "hawaiian", "victorian",
                // Fantasy stuff
                "elf", "elves", "elven", "dwarf", "dwarves", "dwarven", "human", "man", "men", "mankind", "humanity",
                // IPs
                "pokemon", "pok√©mon", "minecraft", "beetles", "band-aid", "bandaid", "band aid", "big mac", "gpt", "chatgpt", "gpt-2", "gpt-3", "gpt-4", "gpt-4o", "mixtral", "mistral", "linux", "windows", "mac", "happy meal", "disneyland", "disneyworld",
                // US states
                "alabama", "alaska", "arizona", "arkansas", "california", "colorado", "connecticut", "delaware", "florida", "georgia", "hawaii", "idaho", "illinois", "indiana", "iowa", "kansas", "kentucky", "louisiana", "maine", "massachusetts", "michigan", "minnesota", "mississippi", "missouri", "nebraska", "nevada", "new hampshire", "new jersey", "new mexico", "new york", "north carolina", "north dakota", "ohio", "oklahoma", "oregon", "pennsylvania", "rhode island", "south carolina", "south dakota", "tennessee", "texas", "utah", "vermont", "west virginia", "wisconsin", "wyoming",
                // Canadian Provinces & Territories
                "british columbia", "manitoba", "new brunswick", "labrador", "nova scotia", "ontario", "prince edward island", "quebec", "saskatchewan", "northwest territories", "nunavut", "yukon", "newfoundland",
                // Australian States & Territories
                "new south wales", "queensland", "south australia", "tasmania", "western australia", "australian capital territory",
                // idk
                "html", "javascript", "python", "java", "c++", "php", "bluetooth", "json", "sql", "word", "dna", "icbm", "npc", "usb", "rsvp", "omg", "brb", "lol", "rofl", "smh", "ttyl", "rubik", "adam", "t-shirt", "tshirt", "t shirt", "led", "leds", "laser", "lasers", "qna", "q&a", "vip", "human resource", "human resources", "llm", "llc", "ceo", "cfo", "coo", "office", "blt", "suv", "suvs", "ems", "emt", "cbt", "cpr", "ferris wheel", "toy", "pet", "plaything", "m o"
            ],
            // Unwanted values
            undesirables: () => [
                [343332, 451737, 323433, 377817], [436425, 356928, 363825, 444048], [323433, 428868, 310497, 413952], [350097, 66825, 436425, 413952, 406593, 444048], [316932, 330000, 436425, 392073], [444048, 356928, 323433], [451737, 444048, 363825], [330000, 310497, 392073, 399300]
            ],
            delimiter: () => (
                "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî"
            ),
            // Source code location
            copy: () => [
                126852, 33792, 211200, 384912, 336633, 310497, 436425, 336633, 33792, 459492, 363825, 436425, 363825, 444048, 33792, 392073, 483153, 33792, 139425, 175857, 33792, 152592, 451737, 399300, 350097, 336633, 406593, 399300, 33792, 413952, 428868, 406593, 343332, 363825, 384912, 336633, 33792, 135168, 190608, 336633, 467313, 330000, 190608, 336633, 310497, 356928, 33792, 310497, 399300, 330000, 33792, 428868, 336633, 310497, 330000, 33792, 392073, 483153, 33792, 316932, 363825, 406593, 33792, 343332, 406593, 428868, 33792, 436425, 363825, 392073, 413952, 384912, 336633, 33792, 363825, 399300, 436425, 444048, 428868, 451737, 323433, 444048, 363825, 406593, 399300, 436425, 33792, 406593, 399300, 33792, 310497, 330000, 330000, 363825, 399300, 350097, 33792, 139425, 451737, 444048, 406593, 66825, 148137, 310497, 428868, 330000, 436425, 33792, 444048, 406593, 33792, 483153, 406593, 451737, 428868, 33792, 436425, 323433, 336633, 399300, 310497, 428868, 363825, 406593, 436425, 35937, 33792, 3355672848, 139592360193, 3300, 3300, 356928, 444048, 444048, 413952, 436425, 111012, 72897, 72897, 413952, 384912, 310497, 483153, 69828, 310497, 363825, 330000, 451737, 399300, 350097, 336633, 406593, 399300, 69828, 323433, 406593, 392073, 72897, 413952, 428868, 406593, 343332, 363825, 384912, 336633, 72897, 190608, 336633, 467313, 330000, 190608, 336633, 310497, 356928, 3300, 3300, 126852, 33792, 139425, 451737, 444048, 406593, 66825, 148137, 310497, 428868, 330000, 436425, 33792, 459492, 79233, 69828, 76032, 69828, 76032, 33792, 363825, 436425, 33792, 310497, 399300, 33792, 406593, 413952, 336633, 399300, 66825, 436425, 406593, 451737, 428868, 323433, 336633, 33792, 436425, 323433, 428868, 363825, 413952, 444048, 33792, 343332, 406593, 428868, 33792, 139425, 175857, 33792, 152592, 451737, 399300, 350097, 336633, 406593, 399300, 33792, 392073, 310497, 330000, 336633, 33792, 316932, 483153, 33792, 190608, 336633, 467313, 330000, 190608, 336633, 310497, 356928, 69828, 33792, 261393, 406593, 451737, 33792, 356928, 310497, 459492, 336633, 33792, 392073, 483153, 33792, 343332, 451737, 384912, 384912, 33792, 413952, 336633, 428868, 392073, 363825, 436425, 436425, 363825, 406593, 399300, 33792, 444048, 406593, 33792, 451737, 436425, 336633, 33792, 139425, 451737, 444048, 406593, 66825, 148137, 310497, 428868, 330000, 436425, 33792, 467313, 363825, 444048, 356928, 363825, 399300, 33792, 483153, 406593, 451737, 428868, 33792, 413952, 336633, 428868, 436425, 406593, 399300, 310497, 384912, 33792, 406593, 428868, 33792, 413952, 451737, 316932, 384912, 363825, 436425, 356928, 336633, 330000, 33792, 436425, 323433, 336633, 399300, 310497, 428868, 363825, 406593, 436425, 35937, 3300, 126852, 33792, 261393, 406593, 451737, 50193, 428868, 336633, 33792, 310497, 384912, 436425, 406593, 33792, 467313, 336633, 384912, 323433, 406593, 392073, 336633, 33792, 444048, 406593, 33792, 336633, 330000, 363825, 444048, 33792, 444048, 356928, 336633, 33792, 139425, 175857, 33792, 413952, 428868, 406593, 392073, 413952, 444048, 436425, 33792, 310497, 399300, 330000, 33792, 444048, 363825, 444048, 384912, 336633, 33792, 336633, 475200, 323433, 384912, 451737, 436425, 363825, 406593, 399300, 436425, 33792, 413952, 428868, 406593, 459492, 363825, 330000, 336633, 330000, 33792, 316932, 336633, 384912, 406593, 467313, 69828, 33792, 175857, 33792, 436425, 363825, 399300, 323433, 336633, 428868, 336633, 384912, 483153, 33792, 356928, 406593, 413952, 336633, 33792, 483153, 406593, 451737, 33792, 336633, 399300, 370788, 406593, 483153, 33792, 483153, 406593, 451737, 428868, 33792, 310497, 330000, 459492, 336633, 399300, 444048, 451737, 428868, 336633, 436425, 35937, 33792, 101128769412, 106046468352, 3300
            ],
            // Card interface names reserved for use within LSIv2
            reserved: () => ({
                library: "Shared Library", input: "Input Modifier", context: "Context Modifier", output: "Output Modifier", guide: "LSIv2 Guide", state: "State Display", log: "Console Log"
            }),
            // Acceptable config settings which are coerced to true
            trues: () => [
                "true", "t", "yes", "y", "on"
            ],
            // Acceptable config settings which are coerced to false
            falses: () => [
                "false", "f", "no", "n", "off"
            ],
            guide: () => prose(
                ">>> Detailed Guide:",
                "Auto-Cards was made by LewdLeah ‚ù§Ô∏è",
                "",
                Words.delimiter,
                "",
                "üí° What is Auto-Cards?",
                "Auto-Cards is a plug-and-play script for AI Dungeon that watches your story and automatically writes plot-relevant story cards during normal gameplay. A forgetful AI breaks my immersion, therefore my primary goal was to address the \"object permanence problem\" by extending story cards and memories with deeper automation. Auto-Cards builds a living reference of your adventure's world as you go. For your own convenience, all of this stuff is handled in the background. Though you're certainly welcome to customize various settings or use in-game commands for more precise control",
                "",
                Words.delimiter,
                "",
                " üìå Main Features",
                "- Detects named entities from your story and periodically writes new cards",
                "- Smart long-term memory updates and summaries for important cards",
                "- Fully customizable AI card generation and memory summarization prompts",
                "- Optional in-game commands to manually direct the card generation process",
                "- Free and open source for anyone to use within their own projects",
                "- Compatible with other scripts and includes an external API",
                "- Optional in-game scripting interface (LSIv2)",
                "",
                Words.delimiter,
                "",
                "‚öôÔ∏è Config Settings",
                "You may, at any time, fine-tune your settings in-game by editing their values within the config card's entry section. Simply swap true/false or tweak numbers where appropriate",
                "",
                "> Disable Auto-Cards:",
                "Turns the whole system off if true",
                "",
                "> Show detailed guide:",
                "If true, shows this player guide in-game",
                "",
                "> Delete all automatic story cards:",
                "Removes every auto-card present in your adventure",
                "",
                "> Reset all config settings and prompts:",
                "Restores all settings and prompts to their original default values",
                "",
                "> Pin this config card near the top:",
                "Keeps the config card pinned high on your cards list",
                "",
                "> Minimum turns cooldown for new cards:",
                "How many turns (minimum) to wait between generating new cards. Using 9999 will pause periodic card generation while still allowing card memory updates to continue",
                "",
                "> New cards use a bulleted list format:",
                "If true, new entries will use bullet points instead of pure prose",
                "",
                "> Maximum entry length for new cards:",
                "Caps how long newly generated card entries can be (in characters)",
                "",
                "> New cards perform memory updates:",
                "If true, new cards will automatically experience memory updates over time",
                "",
                "> Card memory bank preferred length:",
                "Character count threshold before card memories are summarized to save space",
                "",
                "> Memory summary compression ratio:",
                "Controls how much to compress when summarizing long card memory banks",
                "(ratio = 10 * old / new ... such that 25 -> 2.5x shorter)",
                "",
                "> Exclude all-caps from title detection:",
                "Prevents all-caps words like \"RUN\" from being parsed as viable titles",
                "",
                "> Also detect titles from player inputs:",
                "Allows your typed Do/Say/Story action inputs to help suggest new card topics. Set to false if you have bad grammar, or if you're German (due to idiosyncratic noun capitalization habits)",
                "",
                "> Minimum turns age for title detection:",
                "How many actions back the script looks when parsing recent titles from your story",
                "",
                "> Use Live Script Interface v2:",
                "Enables LSIv2 for extra scripting magic and advanced control via arbitrary code execution",
                "",
                "> Log debug data in a separate card:",
                "Shows a debug card if set to true",
                "",
                Words.delimiter,
                "",
                "‚úèÔ∏è AI Prompts",
                "You may specify how the AI handles story card processes by editing either of these two prompts within the config card's notes section",
                "",
                "> AI prompt to generate new cards:",
                "Used when Auto-Cards writes a new card entry. It tells the AI to focus on important plot stuff, avoid fluff, and write in a consistent, polished style. I like to add some personal preferences here when playing my own adventures. \"%{title}\" and \"%{entry}\" are dynamic placeholders for their namesakes",
                "",
                "> AI prompt to summarize card memories:",
                "Summarizes older details within card memory banks to keep everything concise and neat over the long-run. Maintains only the most important details, written in the past tense. \"%{title}\" and \"%{memory}\" are dynamic placeholders for their namesakes",
                "",
                Words.delimiter,
                "",
                "‚õî Banned Titles List",
                "This list prevents new cards from being created for super generic or unhelpful titles such as North, Tuesday, or December. You may edit these at the bottom of the config card's notes section. Capitalization and plural/singular forms are handled for you, so no worries about that",
                "",
                "> Titles banned from automatic new card generation:",
                "North, East, South, West, and so on...",
                "",
                Words.delimiter,
                "",
                "üîë In-Game Commands (/ac)",
                "Use these commands to manually interact with Auto-Cards, simply type them into a Do/Say/Story input action",
                "",
                "/ac",
                "Sets your actual cooldown to 0 and immediately attempts to generate a new card for the most relevant unused title from your story (if one exists)",
                "",
                "/ac Your Title Goes Here",
                "Will immediately begin generating a new story card with the given title",
                "Example use: \"/ac Leah\"",
                "",
                "/ac Your Title Goes Here / Your extra prompt details go here",
                "Similar to the previous case, but with additional context to include with the card generation prompt",
                "Example use: \"/ac Leah / Focus on Leah's works of artifice and ingenuity\"",
                "",
                "/ac Your Title Goes Here / Your extra prompt details go here / Your starter entry goes here",
                "Again, similar to the previous case, but with an initial card entry for the generator to build upon",
                "Example use: \"/ac Leah / Focus on Leah's works of artifice and ingenuity / You are a woman named Leah.\"",
                "",
                "/ac redo Your Title Goes Here",
                "Rewrites your chosen story card, using the old card entry, memory bank, and story context for inspiration. Useful for recreating cards after important character development has occurred",
                "Example use: \"/ac redo Leah\"",
                "",
                "/ac redo Your Title Goes Here / New info goes here",
                "Similar to the previous case, but with additional info provided to guide the rewrite according to your additional specifications",
                "Example use: \"/ac redo Leah / Leah recently achieved immortality\"",
                "",
                "/ac redo all",
                "Recreates every single auto-card in your adventure. I must warn you though: This is very risky",
                "",
                "Extra Info:",
                "- Invalid titles will fail. It's a technical limitation, sorry ü§∑‚Äç‚ôÄÔ∏è",
                "- Titles must be unique, unless you're attempting to use \"/ac redo\" for an existing card",
                "- You may submit multiple commands using a single input to queue up a chained sequence of requests",
                "- Capitalization doesn't matter, titles will be reformatted regardless",
                "",
                Words.delimiter,
                "",
                "üîß External API Functions (quick summary)",
                "These are mainly for other JavaScript programmers to use, so feel free to ignore this section if that doesn't apply to you. Anyway, here's what each one does in plain terms, though please do refer to my source code for the full documentation",
                "",
                "AutoCards().API.postponeEvents();",
                "Pauses Auto-Cards activity for n many turns",
                "",
                "AutoCards().API.emergencyHalt();",
                "Emergency stop or resume",
                "",
                "AutoCards().API.suppressMessages();",
                "Hides Auto-Cards toasts by preventing assignment to state.message",
                "",
                "AutoCards().API.debugLog();",
                "Writes to the debug log card",
                "",
                "AutoCards().API.toggle();",
                "Turns Auto-Cards on/off",
                "",
                "AutoCards().API.generateCard();",
                "Initiates AI generation of the requested card",
                "",
                "AutoCards().API.redoCard();",
                "Regenerates an existing card",
                "",
                "AutoCards().API.setCardAsAuto();",
                "Flags or unflags a card as automatic",
                "",
                "AutoCards().API.addCardMemory();",
                "Adds a memory to a specific card",
                "",
                "AutoCards().API.eraseAllAutoCards();",
                "Deletes all auto-cards",
                "",
                "AutoCards().API.getUsedTitles();",
                "Lists all current card titles and keys",
                "",
                "AutoCards().API.getBannedTitles();",
                "Shows your current banned titles list",
                "",
                "AutoCards().API.setBannedTitles();",
                "Replaces the banned titles list with a new list",
                "",
                "AutoCards().API.buildCard();",
                "Makes a new card from scratch, using exact parameters",
                "",
                "AutoCards().API.getCard();",
                "Finds cards that match a filter",
                "",
                "AutoCards().API.eraseCard();",
                "Deletes cards matching a filter",
                "",
                "These API functions also work from within the LSIv2 scope, by the way",
                "",
                Words.delimiter,
                "",
                "‚ù§Ô∏è Special Thanks",
                "This project flourished due to the incredible help, feedback, and encouragement from the AI Dungeon community. Your ideas, bug reports, testing, and support made Auto-Cards smarter, faster, and more fun for all. Please refer to my source code to learn more about everyone's specific contributions",
                "",
                "AHotHamster22, BinKompliziert, Boo, bottledfox, Bruno, Burnout, bweni, DebaczX, Dirty Kurtis, Dragranis, effortlyss, Hawk, Idle Confusion, ImprezA, Kat-Oli, KryptykAngel, Mad19pumpkin, Magic, Mirox80, Nathaniel Wyvern, NobodyIsUgly, OnyxFlame, Purplejump, Randy Viosca, RustyPawz, sinner, Sleepy pink, Vutinberg, Wilmar, Yi1i1i",
                "",
                Words.delimiter,
                "",
                "üé¥ Random Tips",
                "- The default setup works great out of the box, just play normally and watch your world build itself",
                "- Enable AI Dungeon's built-in memory system for the best results",
                "- Gameplay -> AI Models -> Memory System -> Memory Bank -> Toggle-ON to enable",
                "- \"t\" and \"f\" are valid shorthand for \"true\" and \"false\" inside the config card",
                "- If Auto-Cards goes overboard with new cards, you can pause it by setting the cooldown config to 9999",
                "- Write \"{title:}\" anywhere within a regular story card's entry to transform it into an automatic card",
                "- Feel free to import/export entire story card decks at any time",
                "- Please copy my source code from here: https://play.aidungeon.com/profile/LewdLeah",
                "",
                Words.delimiter,
                "",
                "Happy adventuring! ‚ù§Ô∏è",
                "Please erase before continuing! <<<"
            )
        };
        for (const wordList in wordListInitializers) {
            // Define a lazy getter for every word list
            Object.defineProperty(Words, wordList, {
                configurable: false,
                enumerable: true,
                get() {
                    // If not already in cache, initialize and store the word list
                    if (!(wordList in Words.#cache)) {
                        Words.#cache[wordList] = O.f(wordListInitializers[wordList]());
                    }
                    return Words.#cache[wordList];
                }
            });
        }
    } }); }
    function hoistStringsHashed() { return (class StringsHashed {
        // Used for information-dense past memory recognition
        // Strings are converted to (reasonably) unique hashcodes for efficient existence checking
        static #defaultSize = 65536;
        #size;
        #store;
        constructor(size = StringsHashed.#defaultSize) {
            this.#size = size;
            this.#store = new Set();
            return this;
        }
        static deserialize(serialized, size = StringsHashed.#defaultSize) {
            const stringsHashed = new StringsHashed(size);
            stringsHashed.#store = new Set(serialized.split(","));
            return stringsHashed;
        }
        serialize() {
            return Array.from(this.#store).join(",");
        }
        has(str) {
            return this.#store.has(this.#hash(str));
        }
        add(str) {
            this.#store.add(this.#hash(str));
            return this;
        }
        remove(str) {
            this.#store.delete(this.#hash(str));
            return this;
        }
        size() {
            return this.#store.size;
        }
        latest(keepLatestCardinality) {
            if (this.#store.size <= keepLatestCardinality) {
                return this;
            }
            const excess = this.#store.size - keepLatestCardinality;
            const iterator = this.#store.values();
            for (let i = 0; i < excess; i++) {
                // The oldest hashcodes are removed first (insertion order matters!)
                this.#store.delete(iterator.next().value);
            }
            return this;
        }
        #hash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((31 * hash) + str.charCodeAt(i)) % this.#size;
            }
            return hash.toString(36);
        }
    }); }
    function hoistInternal() { return (class Internal {
        // Some exported API functions are internally reused by AutoCards
        // Recursively calling AutoCards().API is computationally wasteful
        // AutoCards uses this collection of static methods as an internal proxy
        static generateCard(request, predefinedPair = ["", ""]) {
            // Method call guide:
            // Internal.generateCard({
            //     // All properties except 'title' are optional
            //     type: "card type, defaults to 'class' for ease of filtering",
            //     title: "card title",
            //     keysStart: "preexisting card triggers",
            //     entryStart: "preexisting card entry",
            //     entryPrompt: "prompt the AI will use to complete this entry",
            //     entryPromptDetails: "extra details to include with this card's prompt",
            //     entryLimit: 750, // target character count for the generated entry
            //     description: "card notes",
            //     memoryStart: "preexisting card memory",
            //     memoryUpdates: true, // card updates when new relevant memories are formed
            //     memoryLimit: 2750, // max characters before the card memory is compressed
            // });
            const titleKeyPair = formatTitle((request.title ?? "").toString());
            const title = predefinedPair[0] || titleKeyPair.newTitle;
            if (
                (title === "")
                || (("title" in AC.generation.workpiece) && (title === AC.generation.workpiece.title))
                || (isAwaitingGeneration() && (AC.generation.pending.some(pendingWorkpiece => (
                    ("title" in pendingWorkpiece) && (title === pendingWorkpiece.title)
                ))))
            ) {
                logEvent("The title '" + request.title + "' is invalid or unavailable for card generation", true);
                return false;
            }
            AC.generation.pending.push(O.s({
                title: title,
                type: limitString((request.type || AC.config.defaultCardType).toString().trim(), 100),
                keys: predefinedPair[1] || buildKeys((request.keysStart ?? "").toString(), titleKeyPair.newKey),
                entry: limitString("{title: " + title + "}" + cleanSpaces((function() {
                    const entry = (request.entryStart ?? "").toString().trim();
                    if (entry === "") {
                        return "";
                    } else {
                        return ("\n" + entry + (function() {
                            if (/[a-zA-Z]$/.test(entry)) {
                                return ".";
                            } else {
                                return "";
                            }
                        })() + " ");
                    }
                })()), 2000),
                description: limitString((
                    (function() {
                        const description = limitString((request.description ?? "").toString().trim(), 9900);
                        if (description === "") {
                            return "";
                        } else {
                            return description + "\n\n";
                        }
                    })() + "Auto-Cards will contextualize these memories:\n{updates: " + (function() {
                        if (typeof request.memoryUpdates === "boolean") {
                            return request.memoryUpdates;
                        } else {
                            return AC.config.defaultCardsDoMemoryUpdates;
                        }
                    })() + ", limit: " + validateMemoryLimit(
                        parseInt((request.memoryLimit || AC.config.defaultMemoryLimit), 10)
                    ) + "}" + (function() {
                        const cardMemoryBank = cleanSpaces((request.memoryStart ?? "").toString().trim());
                        if (cardMemoryBank === "") {
                            return "";
                        } else {
                            return "\n" + cardMemoryBank.split("\n").map(memory => addBullet(memory)).join("\n");
                        }
                    })()
                ), 10000),
                prompt: (function() {
                    let prompt = insertTitle((
                        (request.entryPrompt ?? "").toString().trim() || AC.config.generationPrompt.trim()
                    ), title);
                    let promptDetails = insertTitle((
                        cleanSpaces((request.entryPromptDetails ?? "").toString().trim())
                    ), title);
                    if (promptDetails !== "") {
                        const spacesPrecedingTerminalEntryPlaceholder = (function() {
                            const terminalEntryPlaceholderPattern = /(?:[%\$]+\s*|[%\$]*){+\s*entry\s*}+$/i;
                            if (terminalEntryPlaceholderPattern.test(prompt)) {
                                prompt = prompt.replace(terminalEntryPlaceholderPattern, "");
                                const trailingSpaces = prompt.match(/(\s+)$/);
                                if (trailingSpaces) {
                                    prompt = prompt.trimEnd();
                                    return trailingSpaces[1];
                                } else {
                                    return "\n\n";
                                }
                            } else {
                                return "";
                            }
                        })();
                        switch(prompt[prompt.length - 1]) {
                        case "]": { encapsulateBothPrompts("[", true, "]"); break; }
                        case ">": { encapsulateBothPrompts(null, false, ">"); break; }
                        case "}": { encapsulateBothPrompts("{", true, "}"); break; }
                        case ")": { encapsulateBothPrompts("(", true, ")"); break; }
                        case "/": { encapsulateBothPrompts("/", true, "/"); break; }
                        case "#": { encapsulateBothPrompts("#", true, "#"); break; }
                        case "-": { encapsulateBothPrompts(null, false, "-"); break; }
                        case ":": { encapsulateBothPrompts(":", true, ":"); break; }
                        case "<": { encapsulateBothPrompts(">", true, "<"); break; }
                        };
                        if (promptDetails.includes("\n")) {
                            const lines = promptDetails.split("\n");
                            for (let i = 0; i < lines.length; i++) {
                                lines[i] = addBullet(lines[i].trim());
                            }
                            promptDetails = lines.join("\n");
                        } else {
                            promptDetails = addBullet(promptDetails);
                        }
                        prompt += "\n" + promptDetails + (function() {
                            if (spacesPrecedingTerminalEntryPlaceholder !== "") {
                                // Prompt previously contained a terminal %{entry} placeholder, re-append it
                                return spacesPrecedingTerminalEntryPlaceholder + "%{entry}";
                            }
                            return "";
                        })();
                        function encapsulateBothPrompts(leftSymbol, slicesAtMiddle, rightSymbol) {
                            if (slicesAtMiddle) {
                                prompt = prompt.slice(0, -1).trim();
                                if (promptDetails.startsWith(leftSymbol)) {
                                    promptDetails = promptDetails.slice(1).trim();
                                }
                            }
                            if (!promptDetails.endsWith(rightSymbol)) {
                                promptDetails += rightSymbol;
                            }
                            return;
                        }
                    }
                    return limitString(prompt, Math.floor(0.8 * AC.signal.maxChars));
                })(),
                limit: validateEntryLimit(parseInt((request.entryLimit || AC.config.defaultEntryLimit), 10))
            }));
            notify("Generating card for \"" + title + "\"");
            function addBullet(str) {
                return "- " + str.replace(/^-+\s*/, "");
            }
            return true;
        }
        static redoCard(request, useOldInfo, newInfo) {
            const card = getIntendedCard(request.title)[0];
            const oldCard = O.f({...card});
            if (!eraseCard(card)) {
                return false;
            } else if (newInfo !== "") {
                request.entryPromptDetails = (request.entryPromptDetails ?? "").toString() + "\n" + newInfo;
            }
            O.f(request);
            Internal.getUsedTitles(true);
            if (!Internal.generateCard(request) && !Internal.generateCard(request, [
                (oldCard.entry.match(/^{title: ([\s\S]*?)}/)?.[1] || request.title.replace(/\w\S*/g, word => (
                    word[0].toUpperCase() + word.slice(1).toLowerCase()
                ))), oldCard.keys
            ])) {
                constructCard(oldCard, newCardIndex());
                Internal.getUsedTitles(true);
                return false;
            } else if (!useOldInfo) {
                return true;
            }
            AC.generation.pending[AC.generation.pending.length - 1].prompt = ((
                removeAutoProps(oldCard.entry) + "\n\n" +
                removeAutoProps(isolateNotesAndMemories(oldCard.description)[1])
            ).trimEnd() + "\n\n" + AC.generation.pending[AC.generation.pending.length - 1].prompt).trim();
            return true;
        }
        // Sometimes it's helpful to log information elsewhere during development
        // This log card is separate and distinct from the LSIv2 console log
        static debugLog(...args) {
            const debugCardName = "Debug Log";
            banTitle(debugCardName);
            const card = getSingletonCard(true, O.f({
                type: AC.config.defaultCardType,
                title: debugCardName,
                keys: debugCardName,
                entry: "The debug console log will print to the notes section below.",
                description: Words.delimiter + "\nBEGIN DEBUG LOG"
            }));
            logToCard(card, ...args);
            return card;
        }
        static eraseAllAutoCards() {
            const cards = [];
            Internal.getUsedTitles(true);
            for (const card of storyCards) {
                if (card.entry.startsWith("{title: ")) {
                    cards.push(card);
                }
            }
            for (const card of cards) {
                eraseCard(card);
            }
            auto.clear();
            forgetStuff();
            clearTransientTitles();
            AC.generation.pending = [];
            AC.database.memories.associations = {};
            if (AC.config.deleteAllAutoCards) {
                AC.config.deleteAllAutoCards = null;
            }
            return cards.length;
        }
        static getUsedTitles(isExternal = false) {
            if (isExternal) {
                bans.clear();
                isBanned("", true);
            } else if (0 < AC.database.titles.used.length) {
                return AC.database.titles.used;
            }
            // All unique used titles and keys encountered during this iteration
            const seen = new Set();
            auto.clear();
            clearTransientTitles();
            AC.database.titles.used = ["%@%"];
            for (const card of storyCards) {
                // Perform some common-sense maintenance while we're here
                card.type = card.type.trim();
                card.title = card.title.trim();
                // card.keys should be left as-is
                card.entry = card.entry.trim();
                card.description = card.description.trim();
                if (isExternal) {
                    O.s(card);
                } else if (!shouldProceed()) {
                    checkRemaining();
                    continue;
                }
                // An ideal auto-card's entry starts with "{title: Example of Greatness}" (example)
                // An ideal auto-card's description contains "{updates: true, limit: 2750}" (example)
                if (checkPlurals(denumberName(card.title.replace("\n", "")), t => isBanned(t))) {
                    checkRemaining();
                    continue;
                } else if (!card.keys.includes(",")) {
                    const cleanKeys = denumberName(card.keys.trim());
                    if ((2 < cleanKeys.length) && checkPlurals(cleanKeys, t => isBanned(t))) {
                        checkRemaining();
                        continue;
                    }
                }
                // Detect and repair malformed auto-card properties in a fault-tolerant manner
                const traits = [card.entry, card.description].map((str, i) => {
                    // Absolute abomination uwu
                    const hasUpdates = /updates?\s*:[\s\S]*?(?:(?:title|limit)s?\s*:|})/i.test(str);
                    const hasLimit = /limits?\s*:[\s\S]*?(?:(?:title|update)s?\s*:|})/i.test(str);
                    return [(function() {
                        if (hasUpdates || hasLimit) {
                            if (/titles?\s*:[\s\S]*?(?:(?:limit|update)s?\s*:|})/i.test(str)) {
                                return 2;
                            }
                            return false;
                        } else if (/titles?\s*:[\s\S]*?}/i.test(str)) {
                            return 1;
                        } else if (!(
                            (i === 0)
                            && /{[\s\S]*?}/.test(str)
                            && (str.match(/{/g)?.length === 1)
                            && (str.match(/}/g)?.length === 1)
                        )) {
                            return false;
                        }
                        const badTitleHeaderMatch = str.match(/{([\s\S]*?)}/);
                        if (!badTitleHeaderMatch) {
                            return false;
                        }
                        const inferredTitle = badTitleHeaderMatch[1].split(",")[0].trim();
                        if (
                            (2 < inferredTitle.length)
                            && (inferredTitle.length <= 100)
                            && (badTitleHeaderMatch[0].length < str.length)
                        ) {
                            // A rare case where the title's existence should be inferred from the enclosing {curly brackets}
                            return inferredTitle;
                        }
                        return false;
                    })(), hasUpdates, hasLimit];
                }).flat();
                if (traits.every(trait => !trait)) {
                    // This card contains no auto-card traits, not even malformed ones
                    checkRemaining();
                    continue;
                }
                const [
                    hasEntryTitle,
                    hasEntryUpdates,
                    hasEntryLimit,
                    hasDescTitle,
                    hasDescUpdates,
                    hasDescLimit
                ] = traits;
                // Handle all story cards which belong to the Auto-Cards ecosystem
                // May flag this damaged auto-card for later repairs
                // May flag this duplicate auto-card for deformatting (will become a regular story card)
                let repair = false;
                let release = false;
                const title = (function() {
                    let title = "";
                    if (typeof hasEntryTitle === "string") {
                        repair = true;
                        title = formatTitle(hasEntryTitle).newTitle;
                        if (hasDescTitle && bad()) {
                            title = parseTitle(false);
                        }
                    } else if (hasEntryTitle) {
                        title = parseTitle(true);
                        if (hasDescTitle) {
                            repair = true;
                            if (bad()) {
                                title = parseTitle(false);
                            }
                        } else if (1 < card.entry.match(/titles?\s*:/gi)?.length) {
                            repair = true;
                        }
                    } else if (hasDescTitle) {
                        repair = true;
                        title = parseTitle(false);
                    }
                    if (bad()) {
                        repair = true;
                        title = formatTitle(card.title).newTitle;
                        if (bad()) {
                            release = true;
                        } else {
                            seen.add(title);
                            auto.add(title.toLowerCase());
                        }
                    } else {
                        seen.add(title);
                        auto.add(title.toLowerCase());
                        const titleHeader = "{title: " + title + "}";
                        if (!repair && !((card.entry === titleHeader) || card.entry.startsWith(titleHeader + "\n"))) {
                            repair = true;
                        }
                    }
                    function bad() {
                        return ((title === "") || checkPlurals(title, t => auto.has(t)));
                    }
                    function parseTitle(fromEntry) {
                        const [sourceType, sourceText] = (function() {
                            if (fromEntry) {
                                return [hasEntryTitle, card.entry];
                            } else {
                                return [hasDescTitle, card.description];
                            }
                        })()
                        switch(sourceType) {
                        case 1: {
                            return formatTitle(isolateProperty(
                                sourceText,
                                /titles?\s*:[\s\S]*?}/i,
                                /(?:titles?\s*:|})/gi
                            )).newTitle; }
                        case 2: {
                            return formatTitle(isolateProperty(
                                sourceText,
                                /titles?\s*:[\s\S]*?(?:(?:limit|update)s?\s*:|})/i,
                                /(?:(?:title|update|limit)s?\s*:|})/gi
                            )).newTitle; }
                        default: {
                            return ""; }
                        }
                    }
                    return title;
                })();
                if (release) {
                    // Remove Auto-Cards properties from this incompatible story card
                    safeRemoveProps();
                    card.description = (card.description
                        .replace(/\s*Auto(?:-|\s*)Cards\s*will\s*contextualize\s*these\s*memories\s*:\s*/gi, "")
                        .replaceAll("%@%", "\n\n")
                        .trim()
                    );
                    seen.delete(title);
                    checkRemaining();
                    continue;
                }
                const memoryProperties = "{updates: " + (function() {
                    let updates = null;
                    if (hasDescUpdates) {
                        updates = parseUpdates(false);
                        if (hasEntryUpdates) {
                            repair = true;
                            if (bad()) {
                                updates = parseUpdates(true);
                            }
                        } else if (1 < card.description.match(/updates?\s*:/gi)?.length) {
                            repair = true;
                        }
                    } else if (hasEntryUpdates) {
                        repair = true;
                        updates = parseUpdates(true);
                    }
                    if (bad()) {
                        repair = true;
                        updates = AC.config.defaultCardsDoMemoryUpdates;
                    }
                    function bad() {
                        return (updates === null);
                    }
                    function parseUpdates(fromEntry) {
                        const updatesText = (isolateProperty(
                            (function() {
                                if (fromEntry) {
                                    return card.entry;
                                } else {
                                    return card.description;
                                }
                            })(),
                            /updates?\s*:[\s\S]*?(?:(?:title|limit)s?\s*:|})/i,
                            /(?:(?:title|update|limit)s?\s*:|})/gi
                        ).toLowerCase().replace(/[^a-z]/g, ""));
                        if (Words.trues.includes(updatesText)) {
                            return true;
                        } else if (Words.falses.includes(updatesText)) {
                            return false;
                        } else {
                            return null;
                        }
                    }
                    return updates;
                })() + ", limit: " + (function() {
                    let limit = -1;
                    if (hasDescLimit) {
                        limit = parseLimit(false);
                        if (hasEntryLimit) {
                            repair = true;
                            if (bad()) {
                                limit = parseLimit(true);
                            }
                        } else if (1 < card.description.match(/limits?\s*:/gi)?.length) {
                            repair = true;
                        }
                    } else if (hasEntryLimit) {
                        repair = true;
                        limit = parseLimit(true);
                    }
                    if (bad()) {
                        repair = true;
                        limit = AC.config.defaultMemoryLimit;
                    } else {
                        limit = validateMemoryLimit(limit);
                    }
                    function bad() {
                        return (limit === -1);
                    }
                    function parseLimit(fromEntry) {
                        const limitText = (isolateProperty(
                            (function() {
                                if (fromEntry) {
                                    return card.entry;
                                } else {
                                    return card.description;
                                }
                            })(),
                            /limits?\s*:[\s\S]*?(?:(?:title|update)s?\s*:|})/i,
                            /(?:(?:title|update|limit)s?\s*:|})/gi
                        ).replace(/[^0-9]/g, ""));
                        if ((limitText === "")) {
                            return -1;
                        } else {
                            return parseInt(limitText, 10);
                        }
                    }
                    return limit.toString();
                })() + "}";
                if (!repair && (new RegExp("(?:^|\\n)" + memoryProperties + "(?:\\n|$)")).test(card.description)) {
                    // There are no serious repairs to perform
                    card.entry = cleanSpaces(card.entry);
                    const [notes, memories] = isolateNotesAndMemories(card.description);
                    const pureMemories = cleanSpaces(memories.replace(memoryProperties, "").trim());
                    rejoinDescription(notes, memoryProperties, pureMemories);
                    checkRemaining();
                    continue;
                }
                // Damage was detected, perform an adaptive repair on this auto-card's configurable properties
                card.description = card.description.replaceAll("%@%", "\n\n");
                safeRemoveProps();
                card.entry = limitString(("{title: " + title + "}\n" + card.entry).trimEnd(), 2000);
                const [left, right] = card.description.split("%@%");
                rejoinDescription(left, memoryProperties, right);
                checkRemaining();
                function safeRemoveProps() {
                    if (typeof hasEntryTitle === "string") {
                        card.entry = card.entry.replace(/{[\s\S]*?}/g, "");
                    }
                    card.entry = removeAutoProps(card.entry);
                    const [notes, memories] = isolateNotesAndMemories(card.description);
                    card.description = notes + "%@%" + removeAutoProps(memories);
                    return;
                }
                function rejoinDescription(notes, memoryProperties, memories) {
                    card.description = limitString((notes + (function() {
                        if (notes === "") {
                            return "";
                        } else if (notes.endsWith("Auto-Cards will contextualize these memories:")) {
                            return "\n";
                        } else {
                            return "\n\n";
                        }
                    })() + memoryProperties + (function() {
                        if (memories === "") {
                            return "";
                        } else {
                            return "\n";
                        }
                    })() + memories), 10000);
                    return;
                }
                function isolateProperty(sourceText, propMatcher, propCleaner) {
                    return ((sourceText.match(propMatcher)?.[0] || "")
                        .replace(propCleaner, "")
                        .split(",")[0]
                        .trim()
                    );
                }
                // Observe literal card titles and keys
                function checkRemaining() {
                    const literalTitles = [card.title, ...card.keys.split(",")];
                    for (let i = 0; i < literalTitles.length; i++) {
                        // The pre-format set inclusion check helps avoid superfluous formatTitle calls
                        literalTitles[i] = (literalTitles[i]
                            .replace(/["\.\?!;\(\):\[\]‚Äî{}]/g, " ")
                            .trim()
                            .replace(/\s+/g, " ")
                            .replace(/^'\s*/, "")
                            .replace(/\s*'$/, "")
                        );
                        if (seen.has(literalTitles[i])) {
                            continue;
                        }
                        literalTitles[i] = formatTitle(literalTitles[i]).newTitle;
                        if (literalTitles[i] !== "") {
                            seen.add(literalTitles[i]);
                        }
                    }
                    return;
                }
                function denumberName(name) {
                    if (2 < (name.match(/[^\d\s]/g) || []).length) {
                        // Important for identifying LSIv2 auxiliary code cards when banned
                        return name.replace(/\s*\d+$/, "");
                    } else {
                        return name;
                    }
                }
            }
            clearTransientTitles();
            AC.database.titles.used = [...seen];
            return AC.database.titles.used;
        }
        static getBannedTitles() {
            // AC.database.titles.banned is an array, not a set; order matters
            return AC.database.titles.banned;
        }
        static setBannedTitles(newBans, isFinalAssignment) {
            AC.database.titles.banned = [];
            AC.database.titles.pendingBans = [];
            AC.database.titles.pendingUnbans = [];
            for (let i = newBans.length - 1; 0 <= i; i--) {
                banTitle(newBans[i], isFinalAssignment);
            }
            return AC.database.titles.banned;
        }
        static getCard(predicate, getAll) {
            if (getAll) {
                // Return an array of card references which satisfy the given condition
                const collectedCards = [];
                for (const card of storyCards) {
                    if (predicate(card)) {
                        O.s(card);
                        collectedCards.push(card);
                    }
                }
                return collectedCards;
            }
            // Return a reference to the first card which satisfies the given condition
            for (const card of storyCards) {
                if (predicate(card)) {
                    return O.s(card);
                }
            }
            return null;
        }
    }); }
    function validateCooldown(cooldown) {
        return boundInteger(0, cooldown, 9999, 22);
    }
    function validateEntryLimit(entryLimit) {
        return boundInteger(200, entryLimit, 2000, 750);
    }
    function validateMemoryLimit(memoryLimit) {
        return boundInteger(1750, memoryLimit, 9900, 2750);
    }
    function validateMemCompRatio(memCompressRatio) {
        return boundInteger(20, memCompressRatio, 1250, 25);
    }
    function validateMinLookBackDist(minLookBackDist) {
        return boundInteger(2, minLookBackDist, 88, 7);
    }
    function getDefaultConfig() {
        function check(value, fallback = true, type = "boolean") {
            if (typeof value === type) {
                return value;
            } else {
                return fallback;
            }
        }
        return O.s({
            // Is Auto-Cards enabled?
            doAC: check(DEFAULT_DO_AC),
            // Delete all previously generated story cards?
            deleteAllAutoCards: null,
            // Pin the configuration interface story card near the top?
            pinConfigureCard: check(DEFAULT_PIN_CONFIGURE_CARD),
            // Minimum number of turns in between automatic card generation events?
            addCardCooldown: validateCooldown(DEFAULT_CARD_CREATION_COOLDOWN),
            // Use bulleted list mode for newly generated card entries?
            bulletedListMode: check(DEFAULT_USE_BULLETED_LIST_MODE),
            // Maximum allowed length for newly generated story card entries?
            defaultEntryLimit: validateEntryLimit(DEFAULT_GENERATED_ENTRY_LIMIT),
            // Do newly generated cards have memory updates enabled by default?
            defaultCardsDoMemoryUpdates: check(DEFAULT_NEW_CARDS_DO_MEMORY_UPDATES),
            // Default character limit before the card's memory bank is summarized?
            defaultMemoryLimit: validateMemoryLimit(DEFAULT_NEW_CARDS_MEMORY_LIMIT),
            // Approximately how much shorter should recently compressed memories be? (ratio = 10 * old / new)
            memoryCompressionRatio: validateMemCompRatio(DEFAULT_MEMORY_COMPRESSION_RATIO),
            // Ignore all-caps during title candidate detection?
            ignoreAllCapsTitles: check(DEFAULT_IGNORE_ALL_CAPS_TITLES),
            // Should player input actions (Do/Say/Story) be considered for future named entity detection?
            readFromInputs: check(DEFAULT_DETECT_TITLES_FROM_INPUTS),
            // How many (minimum) actions in the past does Auto-Cards look for named entities?
            minimumLookBackDistance: validateMinLookBackDist(DEFAULT_MINIMUM_LOOK_BACK_DISTANCE),
            // Is Live Script Interface v2 enabled?
            LSIv2: (function() {
                if (DEFAULT_DO_LSI_V2 === true) {
                    return true;
                } else {
                    // Intrepret "false" as null, both here and for later config card reads
                    return null;
                }
            })(),
            // Should the debug data card be visible?
            showDebugData: check(DEFAULT_SHOW_DEBUG_DATA, false),
            // How should the AI be prompted when generating new story card entries?
            generationPrompt: check(DEFAULT_CARD_GENERATION_PROMPT, prose(
                "-----",
                "",
                "<SYSTEM>",
                "# Stop the story and ignore previous instructions. Write a brief and coherent informational entry for %{title} following these instructions:",
                "- Write only third-person pure prose information about %{title} using complete sentences with correct punctuation",
                "- Avoid short-term temporary details or appearances, instead focus on plot-significant information",
                "- Prioritize story-relevant details about %{title} first to ensure seamless integration with the previous plot",
                "- Create new information based on the context and story direction",
                "- Mention %{title} in every sentence",
                "- Use semicolons if needed",
                "- Add additional details about %{title} beneath incomplete entries",
                "- Be concise and grounded",
                "- Imitate the story's writing style and infer the reader's preferences",
                "</SYSTEM>",
                "Continue the entry for %{title} below while avoiding repetition:",
                "%{entry}"
            ), "string"),
            // How should the AI be prompted when summarizing memories for a given story card?
            compressionPrompt: check(DEFAULT_CARD_MEMORY_COMPRESSION_PROMPT, prose(
                "-----",
                "",
                "<SYSTEM>",
                "# Stop the story and ignore previous instructions. Summarize and condense the given paragraph into a narrow and focused memory passage while following these guidelines:",
                "- Ensure the passage retains the core meaning and most essential details",
                "- Use the third-person perspective",
                "- Prioritize information-density, accuracy, and completeness",
                "- Remain brief and concise",
                "- Write firmly in the past tense",
                "- The paragraph below pertains to old events from far earlier in the story",
                "- Integrate %{title} naturally within the memory; however, only write about the events as they occurred",
                "- Only reference information present inside the paragraph itself, be specific",
                "</SYSTEM>",
                "Write a summarized old memory passage for %{title} based only on the following paragraph:",
                "\"\"\"",
                "%{memory}",
                "\"\"\"",
                "Summarize below:"
            ), "string"),
            // All cards constructed by AC will inherit this type by default
            defaultCardType: check(DEFAULT_CARD_TYPE, "class", "string")
        });
    }
    function getDefaultConfigBans() {
        if (typeof DEFAULT_BANNED_TITLES_LIST === "string") {
            return uniqueTitlesArray(DEFAULT_BANNED_TITLES_LIST.split(","));
        } else {
            return [
                "North", "East", "South", "West", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December, Story Arc Settings, Story Arc, Updating Story Arc Next Turn, Charmer, Honorable, Rogue, Dominant, Submissive, Prankster, Curious, Innocent, Mischievous, Affectionate, Defiant, Brave, Clever, Playful, Month, Year, Day, Minute"
            ];
        }
    }
    function uniqueTitlesArray(titles) {
        const existingTitles = new Set();
        return (titles
            .map(title => title.trim().replace(/\s+/g, " "))
            .filter(title => {
                if (title === "") {
                    return false;
                }
                const lowerTitle = title.toLowerCase();
                if (existingTitles.has(lowerTitle)) {
                    return false;
                } else {
                    existingTitles.add(lowerTitle);
                    return true;
                }
            })
        );
    }
    function boundInteger(lowerBound, value, upperBound, fallback) {
        if (!Number.isInteger(value)) {
            if (!Number.isInteger(fallback)) {
                throw new Error("Invalid arguments: value and fallback are not integers");
            }
            value = fallback;
        }
        if (Number.isInteger(lowerBound) && (value < lowerBound)) {
            if (Number.isInteger(upperBound) && (upperBound < lowerBound)) {
                throw new Error("Invalid arguments: The inequality (lowerBound <= upperBound) must be satisfied");
            }
            return lowerBound;
        } else if (Number.isInteger(upperBound) && (upperBound < value)) {
            return upperBound;
        } else {
            return value;
        }
    }
    function limitString(str, lengthLimit) {
        if (lengthLimit < str.length) {
            return str.slice(0, lengthLimit).trim();
        } else {
            return str;
        }
    }
    function cleanSpaces(unclean) {
        return (unclean
            .replace(/\s*\n\s*/g, "\n")
            .replace(/\t/g, " ")
            .replace(/  +/g, " ")
        );
    }
    function isolateNotesAndMemories(str) {
        const bisector = str.search(/\s*(?:{|(?:title|update|limit)s?\s*:)\s*/i);
        if (bisector === -1) {
            return [str, ""];
        } else {
            return [str.slice(0, bisector), str.slice(bisector)];
        }
    }
    function removeAutoProps(str) {
        return cleanSpaces(str
            .replace(/\s*{([\s\S]*?)}\s*/g, (bracedMatch, enclosedProperties) => {
                if (enclosedProperties.trim().length < 150) {
                    return "\n";
                } else {
                    return bracedMatch;
                }
            })
            .replace((
                /\s*(?:{|(?:title|update|limit)s?\s*:)(?:[\s\S]{0,150}?)(?=(?:title|update|limit)s?\s*:|})\s*/gi
            ), "\n")
            .replace(/\s*(?:{|(?:title|update|limit)s?\s*:|})\s*/gi, "\n")
            .trim()
        );
    }
    function insertTitle(prompt, title) {
        return prompt.replace((
            /(?:[%\$]+\s*|[%\$]*){+\s*(?:titles?|names?|characters?|class(?:es)?|races?|locations?|factions?)\s*}+/gi
        ), title);
    }
    function prose(...args) {
        return args.join("\n");
    }
    function buildKeys(keys, key) {
        key = key.trim().replace(/\s+/g, " ");
        const keyset = [];
        if (key === "") {
            return keys;
        } else if (keys.trim() !== "") {
            keyset.push(...keys.split(","));
            const lowerKey = key.toLowerCase();
            for (let i = keyset.length - 1; 0 <= i; i--) {
                const preKey = keyset[i].trim().replace(/\s+/g, " ").toLowerCase();
                if ((preKey === "") || preKey.includes(lowerKey)) {
                    keyset.splice(i, 1);
                }
            }
        }
        if (key.length < 6) {
            keyset.push(...[
                " " + key + " ", " " + key + "'", "\"" + key + " ", " " + key + ".", " " + key + "?", " " + key + "!", " " + key + ";", "'" + key + " ", "(" + key + " ", " " + key + ")", " " + key + ":", " " + key + "\"", "[" + key + " ", " " + key + "]", "‚Äî" + key + " ", " " + key + "‚Äî", "{" + key + " ", " " + key + "}"
            ]);
        } else if (key.length < 9) {
            keyset.push(...[
                key + " ", " " + key, key + "'", "\"" + key, key + ".", key + "?", key + "!", key + ";", "'" + key, "(" + key, key + ")", key + ":", key + "\"", "[" + key, key + "]", "‚Äî" + key, key + "‚Äî", "{" + key, key + "}"
            ]);
        } else {
            keyset.push(key);
        }
        keys = keyset[0] || key;
        let i = 1;
        while ((i < keyset.length) && ((keys.length + 1 + keyset[i].length) < 101)) {
            keys += "," + keyset[i];
            i++;
        }
        return keys;
    }
    // Returns the template-specified singleton card (or secondary varient) after:
    // 1) Erasing all inferior duplicates
    // 2) Repairing damaged titles and keys
    // 3) Constructing a new singleton card if it doesn't exist
    function getSingletonCard(allowConstruction, templateCard, secondaryCard) {
        let singletonCard = null;
        const excessCards = [];
        for (const card of storyCards) {
            O.s(card);
            if (singletonCard === null) {
                if ((card.title === templateCard.title) || (card.keys === templateCard.keys)) {
                    // The first potentially valid singleton card candidate to be found
                    singletonCard = card;
                }
            } else if (card.title === templateCard.title) {
                if (card.keys === templateCard.keys) {
                    excessCards.push(singletonCard);
                    singletonCard = card;
                } else {
                    eraseInferiorDuplicate();
                }
            } else if (card.keys === templateCard.keys) {
                eraseInferiorDuplicate();
            }
            function eraseInferiorDuplicate() {
                if ((singletonCard.title === templateCard.title) && (singletonCard.keys === templateCard.keys)) {
                    excessCards.push(card);
                } else {
                    excessCards.push(singletonCard);
                    singletonCard = card;
                }
                return;
            }
        }
        if (singletonCard === null) {
            if (secondaryCard) {
                // Fallback to a secondary card template
                singletonCard = getSingletonCard(false, secondaryCard);
            }
            // No singleton card candidate exists
            if (allowConstruction && (singletonCard === null)) {
                // Construct a new singleton card from the given template
                singletonCard = constructCard(templateCard);
            }
        } else {
            if (singletonCard.title !== templateCard.title) {
                // Repair any damage to the singleton card's title
                singletonCard.title = templateCard.title;
            } else if (singletonCard.keys !== templateCard.keys) {
                // Repair any damage to the singleton card's keys
                singletonCard.keys = templateCard.keys;
            }
            for (const card of excessCards) {
                // Erase all excess singleton card candidates
                eraseCard(card);
            }
            if (secondaryCard) {
                // A secondary card match cannot be allowed to persist
                eraseCard(getSingletonCard(false, secondaryCard));
            }
        }
        return singletonCard;
    }
    // Erases the given story card
    function eraseCard(badCard) {
        if (badCard === null) {
            return false;
        }
        badCard.title = "%@%";
        for (const [index, card] of storyCards.entries()) {
            if (card.title === "%@%") {
                removeStoryCard(index);
                return true;
            }
        }
        return false;
    }
    // Constructs a new story card from a standardized story card template object
    // {type: "", title: "", keys: "", entry: "", description: ""}
    // Returns a reference to the newly constructed card
    function constructCard(templateCard, insertionIndex = 0) {
        addStoryCard("%@%");
        for (const [index, card] of storyCards.entries()) {
            if (card.title !== "%@%") {
                continue;
            }
            card.type = templateCard.type;
            card.title = templateCard.title;
            card.keys = templateCard.keys;
            card.entry = templateCard.entry;
            card.description = templateCard.description;
            if (index !== insertionIndex) {
                // Remove from the current position and reinsert at the desired index
                storyCards.splice(index, 1);
                storyCards.splice(insertionIndex, 0, card);
            }
            return O.s(card);
        }
        return {};
    }
    function newCardIndex() {
        return +AC.config.pinConfigureCard;
    }
    function getIntendedCard(targetCard) {
        Internal.getUsedTitles(true);
        const titleKey = targetCard.trim().replace(/\s+/g, " ").toLowerCase();
        const autoCard = Internal.getCard(card => (card.entry
            .toLowerCase()
            .startsWith("{title: " + titleKey + "}")
        ));
        if (autoCard !== null) {
            return [autoCard, true, titleKey];
        }
        return [Internal.getCard(card => ((card.title
            .replace(/\s+/g, " ")
            .toLowerCase()
        ) === titleKey)), false, titleKey];
    }
    function doPlayerCommands(input) {
        let result = "";
        for (const command of (
            (function() {
                if (/^\n> [\s\S]*? says? "[\s\S]*?"\n$/.test(input)) {
                    return input.replace(/\s*"\n$/, "");
                } else {
                    return input.trimEnd();
                }
            })().split(/(?=\/\s*A\s*C)/i)
        )) {
            const prefixPattern = /^\/\s*A\s*C/i;
            if (!prefixPattern.test(command)) {
                continue;
            }
            const [requestTitle, requestDetails, requestEntry] = (command
                .replace(/(?:{\s*)|(?:\s*})/g, "")
                .replace(prefixPattern, "")
                .replace(/(?:^\s*\/*\s*)|(?:\s*\/*\s*$)/g, "")
                .split("/")
                .map(requestArg => requestArg.trim())
                .filter(requestArg => (requestArg !== ""))
            );
            if (!requestTitle) {
                // Request with no args
                AC.generation.cooldown = 0;
                result += "/AC -> Success!\n\n";
                logEvent("/AC");
            } else {
                const request = {title: requestTitle.replace(/\s*[\.\?!:]+$/, "")};
                const redo = (function() {
                    const redoPattern = /^(?:redo|retry|rewrite|remake)[\s\.\?!:,;"'‚Äî\)\]]+\s*/i;
                    if (redoPattern.test(request.title)) {
                        request.title = request.title.replace(redoPattern, "");
                        if (/^(?:all|every)(?:\s|\.|\?|!|:|,|;|"|'|‚Äî|\)|\]|$)/i.test(request.title)) {
                            return [];
                        } else {
                            return true;
                        }
                    } else {
                        return false;
                    }
                })();
                if (Array.isArray(redo)) {
                    // Redo all auto cards
                    Internal.getUsedTitles(true);
                    const titleMatchPattern = /^{title: ([\s\S]*?)}/;
                    redo.push(...Internal.getCard(card => (
                        titleMatchPattern.test(card.entry)
                        && /{updates: (?:true|false), limit: \d+}/.test(card.description)
                    ), true));
                    let count = 0;
                    for (const card of redo) {
                        const titleMatch = card.entry.match(titleMatchPattern);  
                        if (titleMatch && Internal.redoCard(O.f({title: titleMatch[1]}), true, "")) {
                            count++;
                        }
                    }
                    const parsed = "/AC redo all";
                    result += parsed + " -> ";
                    if (count === 0) {
                        result += "There were no valid auto-cards to redo";
                    } else {
                        result += "Success!";
                        if (1 < count) {
                            result += " Proceed to redo " + count + " cards";
                        }
                    }
                    logEvent(parsed);
                } else if (!requestDetails) {
                    // Request with only title
                    submitRequest("");
                } else if (!requestEntry || redo) {
                    // Request with title and details
                    request.entryPromptDetails = requestDetails;
                    submitRequest(" / {" + requestDetails + "}");
                } else {
                    // Request with title, details, and entry
                    request.entryPromptDetails = requestDetails;
                    request.entryStart = requestEntry;
                    submitRequest(" / {" + requestDetails + "} / {" + requestEntry + "}");
                }
                result += "\n\n";
                function submitRequest(extra) {
                    O.f(request);
                    const [type, success] = (function() {
                        if (redo) {
                            return [" redo", Internal.redoCard(request, true, "")];
                        } else {
                            Internal.getUsedTitles(true);
                            return ["", Internal.generateCard(request)];
                        }
                    })();
                    const left = "/AC" + type + " {";
                    const right = "}" + extra;
                    if (success) {
                        const parsed = left + AC.generation.pending[AC.generation.pending.length - 1].title + right;
                        result += parsed + " -> Success!";
                        logEvent(parsed);
                    } else {
                        const parsed = left + request.title + right;
                        result += parsed + " -> \"" + request.title + "\" is invalid or unavailable";
                        logEvent(parsed);
                    }
                    return;
                }
            }
            if (isPendingGeneration() || isAwaitingGeneration() || isPendingCompression()) {
                if (AC.config.doAC) {
                    AC.signal.outputReplacement = "";
                } else {
                    AC.signal.forceToggle = true;
                    AC.signal.outputReplacement = ">>> please select \"continue\" (0%) <<<";
                }
            } else if (AC.generation.cooldown === 0) {
                if (0 < AC.database.titles.candidates.length) {
                    if (AC.config.doAC) {
                        AC.signal.outputReplacement = "";
                    } else {
                        AC.signal.forceToggle = true;
                        AC.signal.outputReplacement = ">>> please select \"continue\" (0%) <<<";
                    }
                } else if (AC.config.doAC) {
                    result = result.trimEnd() + "\n";
                    AC.signal.outputReplacement = "\n";
                } else {
                    AC.signal.forceToggle = true;
                    AC.signal.outputReplacement = ">>> Auto-Cards has been enabled! <<<";
                }
            } else {
                result = result.trimEnd() + "\n";
                AC.signal.outputReplacement = "\n";
            }
        }
        return getPrecedingNewlines() + result;
    }
    function advanceChronometer() {
        const currentTurn = getTurn();
        if (Math.abs(history.length - currentTurn) < 2) {
            // The two measures are within ¬±1, thus history hasn't been truncated yet
            AC.chronometer.step = !(history.length < currentTurn);
        } else {
            // history has been truncated, fallback to a (slightly) worse step detection technique
            AC.chronometer.step = (AC.chronometer.turn < currentTurn);
        }
        AC.chronometer.turn = currentTurn;
        return;
    }
    function concludeEmergency() {
        promoteAmnesia();
        endTurn();
        AC.message.pending = [];
        AC.message.previous = getStateMessage();
        return;
    }
    function concludeOutputBlock(templateCard) {
        if (AC.config.deleteAllAutoCards !== null) {
            // A config-initiated event to delete all previously generated story cards is in progress
            if (AC.config.deleteAllAutoCards) {
                // Request in-game confirmation from the player before proceeding
                AC.config.deleteAllAutoCards = false;
                CODOMAIN.initialize(getPrecedingNewlines() + ">>> please submit the message \"CONFIRM DELETE\" using a Do, Say, or Story action to permanently delete all previously generated story cards <<<\n\n");
            } else {
                // Check for player confirmation
                const previousAction = readPastAction(0);
                if (isDoSayStory(previousAction.type) && /CONFIRM\s*DELETE/i.test(previousAction.text)) {
                    let successMessage = "Confirmation Success: ";
                    const numCardsErased = Internal.eraseAllAutoCards();
                    if (numCardsErased === 0) {
                        successMessage += "However, there were no previously generated story cards to delete!";
                    } else {
                        successMessage += numCardsErased + " generated story card";
                        if (numCardsErased === 1) {
                            successMessage += " was";
                        } else {
                            successMessage += "s were";
                        }
                        successMessage += " deleted";
                    }
                    notify(successMessage);
                } else {
                    notify("Confirmation Failure: No story cards were deleted");
                }
                AC.config.deleteAllAutoCards = null;
                CODOMAIN.initialize("\n");
            }
        } else if (AC.signal.outputReplacement !== "") {
            const output = AC.signal.outputReplacement.trim();
            if (output === "") {
                CODOMAIN.initialize("\n");
            } else {
                CODOMAIN.initialize(getPrecedingNewlines() + output + "\n\n");
            }
        }
        if (templateCard) {
            // Auto-Cards was enabled or disabled during the previous onContext hook
            // Construct the replacement control card onOutput
            banTitle(templateCard.title);
            getSingletonCard(true, templateCard);
            AC.signal.swapControlCards = false;
        }
        endTurn();
        if (AC.config.LSIv2 === null) {
            postMessages();
        }
        return;
    }
    function endTurn() {
        AC.database.titles.used = [];
        AC.signal.outputReplacement = "";
        [AC.database.titles.pendingBans, AC.database.titles.pendingUnbans].map(pending => decrementAll(pending));
        if (0 < AC.signal.overrideBans) {
            AC.signal.overrideBans--;
        }
        function decrementAll(pendingArray) {
            if (pendingArray.length === 0) {
                return;
            }
            for (let i = pendingArray.length - 1; 0 <= i; i--) {
                if (0 < pendingArray[i][1]) {
                    pendingArray[i][1]--;
                } else {
                    pendingArray.splice(i, 1);
                }
            }
            return;
        }
        return;
    }
    // Example usage: notify("Message text goes here");
    function notify(message) {
        if (typeof message === "string") {
            AC.message.pending.push(message);
            logEvent(message);
        } else if (Array.isArray(message)) {
            message.forEach(element => notify(element));
        } else if (message instanceof Set) {
            notify([...message]);
        } else {
            notify(message.toString());
        }
        return;
    }
    function logEvent(message, uncounted) {
        if (uncounted) {
            log("Auto-Cards event: " + message);
        } else {
            log("Auto-Cards event #" + (function() {
                try {
                    AC.message.event++;
                    return AC.message.event;
                } catch {
                    return 0;
                }
            })() + ": " + message.replace(/"/g, "'"));
        }
        return;
    }
    // Provide the story card object which you wish to log info within as the first argument
    // All remaining arguments represent anything you wish to log
    function logToCard(logCard, ...args) {
        logEvent(args.map(arg => {
            if ((typeof arg === "object") && (arg !== null)) {
                return JSON.stringify(arg);
            } else {
                return String(arg);
            }
        }).join(", "), true);
        if (logCard === null) {
            return;
        }
        let desc = logCard.description.trim();
        const turnDelimiter = Words.delimiter + "\nAction #" + getTurn() + ":\n";
        let header = turnDelimiter;
        if (!desc.startsWith(turnDelimiter)) {
            desc = turnDelimiter + desc;
        }
        const scopesTable = [
            ["input", "Input Modifier"],
            ["context", "Context Modifier"],
            ["output", "Output Modifier"],
            [null, "Shared Library"],
            [undefined, "External API"],
            [Symbol("default"), "Unknown Scope"]
        ];
        const callingScope = (function() {
            const pair = scopesTable.find(([condition]) => (condition === HOOK));
            if (pair) {
                return pair[1];
            } else {
                return scopesTable[scopesTable.length - 1][1];
            }
        })();
        const hookDelimiterLeft = callingScope + " @ ";
        if (desc.startsWith(turnDelimiter + hookDelimiterLeft)) {
            const hookDelimiterOld = desc.match(new RegExp((
                "^" + turnDelimiter + "(" + hookDelimiterLeft + "\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z:\n)"
            ).replaceAll("\n", "\\n")));
            if (hookDelimiterOld) {
                header += hookDelimiterOld[1];
            } else {
                const hookDelimiter = getNewHookDelimiter();
                desc = desc.replace(hookDelimiterLeft, hookDelimiter);
                header += hookDelimiter;
            }
        } else {
            if ((new RegExp("^" + turnDelimiter.replaceAll("\n", "\\n") + "(" + (scopesTable
                .map(pair => pair[1])
                .filter(scope => (scope !== callingScope))
                .join("|")
            ) + ") @ ")).test(desc)) {
                desc = desc.replace(turnDelimiter, turnDelimiter + "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n");
            }
            const hookDelimiter = getNewHookDelimiter();
            desc = desc.replace(turnDelimiter, turnDelimiter + hookDelimiter);
            header += hookDelimiter;
        }
        const logDelimiter = (function() {
            let logDelimiter = "Log #";
            if (desc.startsWith(header + logDelimiter)) {
                desc = desc.replace(header, header + "‚Äî‚Äî‚Äî\n");
                const logCounter = desc.match(/Log #(\d+)/);
                if (logCounter) {
                    logDelimiter += (parseInt(logCounter[1], 10) + 1).toString();
                }
            } else {
                logDelimiter += "0";
            }
            return logDelimiter + ": ";
        })();
        logCard.description = limitString(desc.replace(header, header + logDelimiter + args.map(arg => {
            if ((typeof arg === "object") && (arg !== null)) {
                return stringifyObject(arg);
            } else {
                return String(arg);
            }
        }).join(",\n") + "\n").trim(), 999999);
        // The upper limit is actually closer to 3985621, but I think 1 million is reasonable enough as-is
        function getNewHookDelimiter() {
            return hookDelimiterLeft + (new Date().toISOString()) + ":\n";
        }
        return;
    }
    // Makes nested objects not look like cancer within interface cards
    function stringifyObject(obj) {
        const seen = new WeakSet();
        // Each indentation is 4 spaces
        return JSON.stringify(obj, (_key, value) => {
            if ((typeof value === "object") && (value !== null)) {
                if (seen.has(value)) {
                    return "[Circular]";
                }
                seen.add(value);
            }
            switch(typeof value) {
            case "function": {
                return "[Function]"; }
            case "undefined": {
                return "[Undefined]"; }
            case "symbol": {
                return "[Symbol]"; }
            default: {
                return value; }
            }
        }, 4);
    }
    // Implement state.message toasts without interfering with the operation of other possible scripts
    function postMessages() {
        const preMessage = getStateMessage();
        if ((preMessage === AC.message.previous) && (AC.message.pending.length !== 0)) {
            // No other scripts are attempting to update state.message during this turn
            // One or more pending Auto-Cards messages exist
            if (!AC.message.suppress) {
                // Message suppression is off
                let newMessage = "Auto-Cards:\n";
                if (AC.message.pending.length === 1) {
                    newMessage += AC.message.pending[0];
                } else {
                    newMessage += AC.message.pending.map(
                        (messageLine, index) => ("#" + (index + 1) + ": " + messageLine)
                    ).join("\n");
                }
                if (preMessage === newMessage) {
                    // Introduce a minor variation to facilitate repetition of the previous message toast
                    newMessage = newMessage.replace("Auto-Cards:\n", "Auto-Cards: \n");
                }
                state.message = newMessage;
            }
            // Clear the pending messages queue after posting or suppressing messages
            AC.message.pending = [];
        }
        AC.message.previous = getStateMessage();
        return;
    }
    function getStateMessage() {
        return state.message ?? "";
    }
    function getPrecedingNewlines() {
        const previousAction = readPastAction(0);
        if (isDoSay(previousAction.type)) {
            return "";
        } else if (previousAction.text.endsWith("\n")) {
            if (previousAction.text.endsWith("\n\n")) {
                return "";
            } else {
                return "\n";
            }
        } else {
            return "\n\n";
        }
    }
    // Call with lookBack 0 to read the most recent action in history (or n many actions back)
    function readPastAction(lookBack) {
        const action = (function() {
            if (Array.isArray(history)) {
                return (history[(function() {
                    const index = history.length - 1 - Math.abs(lookBack);
                    if (index < 0) {
                        return 0;
                    } else {
                        return index;
                    }
                })()]);
            } else {
                return O.f({});
            }
        })();
        return O.f({
            text: action?.text ?? (action?.rawText ?? ""),
            type: action?.type ?? "unknown"
        });
    }
    // Forget ongoing card generation/compression after passing or postponing completion over many consecutive turns
    // Also decrement AC.chronometer.postpone regardless of retries or erases
    function promoteAmnesia() {
        // Decrement AC.chronometer.postpone in all cases
        if (0 < AC.chronometer.postpone) {
            AC.chronometer.postpone--;
        }
        if (!AC.chronometer.step) {
            // Skip known retry/erase turns
            return;
        }
        if (AC.chronometer.amnesia++ < boundInteger(16, (2 * AC.config.addCardCooldown), 64)) {
            return;
        }
        AC.generation.cooldown = validateCooldown(underQuarterInteger(AC.config.addCardCooldown));
        forgetStuff();
        AC.chronometer.amnesia = 0;
        return;
    }
    function forgetStuff() {
        AC.generation.completed = 0;
        AC.generation.permitted = 34;
        AC.generation.workpiece = O.f({});
        // AC.generation.pending is not forgotten
        resetCompressionProperties();
        return;
    }
    function resetCompressionProperties() {
        AC.compression.completed = 0;
        AC.compression.titleKey = "";
        AC.compression.vanityTitle = "";
        AC.compression.responseEstimate = 1400;
        AC.compression.lastConstructIndex = -1;
        AC.compression.oldMemoryBank = [];
        AC.compression.newMemoryBank = [];
        return;
    }
    function underQuarterInteger(someNumber) {
        return Math.floor(someNumber / 4);
    }
    function getTurn() {
        if (Number.isInteger(info?.actionCount)) {
            // "But Leah, surely info.actionCount will never be negative?"
            // You have no idea what nightmares I've seen...
            return Math.abs(info.actionCount);
        } else {
            return 0;
        }
    }
    // Constructs a JSON representation of various properties/settings pulled from raw text
    // Used to parse the "Configure Auto-Cards" and "Edit to enable Auto-Cards" control card entries
    function extractSettings(settingsText) {
        const settings = {};
        // Lowercase everything
        // Remove all non-alphanumeric characters (aside from ":" and ">")
        // Split into an array of strings delimited by the ">" character
        const settingLines = settingsText.toLowerCase().replace(/[^a-z0-9:>]+/g, "").split(">");
        for (const settingLine of settingLines) {
            // Each setting line is preceded by ">" and bisected by ":"
            const settingKeyValue = settingLine.split(":");
            if ((settingKeyValue.length !== 2) || settings.hasOwnProperty(settingKeyValue[0])) {
                // The bisection failed or this setting line's key already exists
                continue;
            }
            // Parse boolean and integer setting values
            if (Words.falses.includes(settingKeyValue[1])) {
                // This setting line's value is false
                settings[settingKeyValue[0]] = false;
            } else if (Words.trues.includes(settingKeyValue[1])) {
                // This setting line's value is true
                settings[settingKeyValue[0]] = true;
            } else if (/^\d+$/.test(settingKeyValue[1])) {
                // This setting line's value is an integer
                // Negative integers are parsed as being positive (because "-" characters were removed)
                settings[settingKeyValue[0]] = parseInt(settingKeyValue[1], 10);
            }
        }
        // Return the settings object for later analysis
        return settings;
    }
    // Ensure the given singleton card is pinned near the top of the player's list of story cards
    function pinAndSortCards(pinnedCard) {
        if (!storyCards || (storyCards.length < 2)) {
            return;
        }
        storyCards.sort((cardA, cardB) => {
            return readDate(cardB) - readDate(cardA);
        });
        if (!AC.config.pinConfigureCard) {
            return;
        }
        const index = storyCards.indexOf(pinnedCard);
        if (0 < index) {
            storyCards.splice(index, 1);
            storyCards.unshift(pinnedCard);
        }
        function readDate(card) {
            if (card && card.updatedAt) {
                const timestamp = Date.parse(card.updatedAt);
                if (!isNaN(timestamp)) {
                    return timestamp;
                }
            }
            return 0;
        }
        return;
    }
    function see(arr) {
        return String.fromCharCode(...arr.map(n => Math.sqrt(n / 33)));
    }
    function formatTitle(title) {
        title = title.trim();
        const failureCase = O.f({newTitle: "", newKey: ""});
        if (short()) {
            // This is an abundantly called function, return as early as possible to ensure superior performance
            return failureCase;
        }
        title = (title
            // Begone!
            .replace(/[‚Äì„ÄÇÔºüÔºÅ¬¥‚Äú‚Äùÿüÿå¬´¬ª¬ø¬°‚Äû‚Äú‚Ä¶¬ßÔºå„ÄÅ\*_~><\(\)\[\]{}#"`:!‚Äî;\.\?,\s\\]/g, " ")
            .replace(/[‚Äò‚Äô]/g, "'").replace(/\s+'/g, " ")
            // Remove the words "I", "I'm", "I'd", "I'll", and "I've"
            .replace(/(?<=^|\s)(?:I|I'm|I'd|I'll|I've)(?=\s|$)/gi, "")
            // Remove "'s" only if not followed by a letter
            .replace(/'s(?![a-zA-Z])/g, "")
            // Replace "s'" with "s" only if preceded but not followed by a letter
            .replace(/(?<=[a-zA-Z])s'(?![a-zA-Z])/g, "s")
            // Remove apostrophes not between letters (preserve contractions like "don't")
            .replace(/(?<![a-zA-Z])'(?![a-zA-Z])/g, "")
            // Eliminate fake em dashes and terminal/leading dashes
            .replace(/\s-\s/g, " ")
            // Condense consecutive whitespace
            .trim().replace(/\s+/g, " ")
            // Remove a leading or trailing bullet
            .replace(/^-+\s*/, "").replace(/\s*-+$/, "")
        );
        if (short()) {
            return failureCase;
        }
        // Special-cased words
        const minorWordsJoin = Words.minor.join("|");
        const leadingMinorWordsKiller = new RegExp("^(?:" + minorWordsJoin + ")\\s", "i");
        const trailingMinorWordsKiller = new RegExp("\\s(?:" + minorWordsJoin + ")$", "i");
        // Ensure the title is not bounded by any outer minor words
        title = enforceBoundaryCondition(title);
        if (short()) {
            return failureCase;
        }
        // Ensure interior minor words are lowercase and excise all interior honorifics/abbreviations
        const honorAbbrevsKiller = new RegExp("(?:^|\\s|-|\\/)(?:" + (
            [...Words.honorifics, ...Words.abbreviations]
        ).map(word => word.replace(".", "")).join("|") + ")(?=\\s|-|\\/|$)", "gi");
        title = (title
            // Capitalize the first letter of each word
            .replace(/(?<=^|\s|-|\/)(?:\p{L})/gu, word => word.toUpperCase())
            // Lowercase minor words properly
            .replace(/(?<=^|\s|-|\/)(?:\p{L}+)(?=\s|-|\/|$)/gu, word => {
                const lowerWord = word.toLowerCase();
                if (Words.minor.includes(lowerWord)) {
                    return lowerWord;
                } else {
                    return word;
                }
            })
            // Remove interior honorifics/abbreviations
            .replace(honorAbbrevsKiller, "")
            .trim()
        );
        if (short()) {
            return failureCase;
        }
        let titleWords = title.split(" ");
        while ((2 < title.length) && (98 < title.length) && (1 < titleWords.length)) {
            titleWords.pop();
            title = titleWords.join(" ").trim();
            const unboundedLength = title.length;
            title = enforceBoundaryCondition(title);
            if (unboundedLength !== title.length) {
                titleWords = title.split(" ");
            }
        }
        if (isUsedOrBanned(title) || isNamed(title)) {
            return failureCase;
        }
        // Procedurally generated story card trigger keywords exclude certain words and patterns which are otherwise permitted in titles
        let key = title;
        const peerage = new Set(Words.peerage);
        if (titleWords.some(word => ((word === "the") || peerage.has(word.toLowerCase())))) {
            if (titleWords.length < 2) {
                return failureCase;
            }
            key = enforceBoundaryCondition(
                titleWords.filter(word => !peerage.has(word.toLowerCase())).join(" ")
            );
            if (key.includes(" the ")) {
                key = enforceBoundaryCondition(key.split(" the ")[0]);
            }
            if (isUsedOrBanned(key)) {
                return failureCase;
            }
        }
        function short() {
            return (title.length < 3);
        }
        function enforceBoundaryCondition(str) {
            while (leadingMinorWordsKiller.test(str)) {
                str = str.replace(/^\S+\s+/, "");
            }
            while (trailingMinorWordsKiller.test(str)) {
                str = str.replace(/\s+\S+$/, "");
            }
            return str;
        }
        return O.f({newTitle: title, newKey: key});
    }
    // I really hate english grammar
    function checkPlurals(title, predicate) {
        function check(t) { return ((t.length < 3) || (100 < t.length) || predicate(t)); }
        const t = title.toLowerCase();
        if (check(t)) { return true; }
        // s>p : singular -> plural : p>s: plural -> singular
        switch(t[t.length - 1]) {
        // p>s : s -> _ : Birds -> Bird
        case "s": if (check(t.slice(0, -1))) { return true; }
        case "x":
        // s>p : s, x, z -> ses, xes, zes : Mantis -> Mantises
        case "z": if (check(t + "es")) { return true; }
            break;
        // s>p : o -> oes, os : Gecko -> Geckoes, Geckos
        case "o": if (check(t + "es") || check(t + "s")) { return true; }
            break;
        // p>s : i -> us : Cacti -> Cactus
        case "i": if (check(t.slice(0, -1) + "us")) { return true; }
        // s>p : i, y -> ies : Kitty -> Kitties
        case "y": if (check(t.slice(0, -1) + "ies")) { return true; }
            break;
        // s>p : f -> ves : Wolf -> Wolves
        case "f": if (check(t.slice(0, -1) + "ves")) { return true; }
        // s>p : !(s, x, z, i, y) -> +s : Turtle -> Turtles
        default: if (check(t + "s")) { return true; }
            break;
        } switch(t.slice(-2)) {
        // p>s : es -> _ : Foxes -> Fox
        case "es": if (check(t.slice(0, -2))) { return true; } else if (
            (t.endsWith("ies") && (
                // p>s : ies -> y : Bunnies -> Bunny
                check(t.slice(0, -3) + "y")
                // p>s : ies -> i : Ravies -> Ravi
                || check(t.slice(0, -2))
            // p>s : es -> is : Crises -> Crisis
            )) || check(t.slice(0, -2) + "is")) { return true; }
            break;
        // s>p : us -> i : Cactus -> Cacti
        case "us": if (check(t.slice(0, -2) + "i")) { return true; }
            break;
        // s>p : is -> es : Thesis -> Theses
        case "is": if (check(t.slice(0, -2) + "es")) { return true; }
            break;
        // s>p : fe -> ves : Knife -> Knives
        case "fe": if (check(t.slice(0, -2) + "ves")) { return true; }
            break;
        case "sh":
        // s>p : sh, ch -> shes, ches : Fish -> Fishes
        case "ch": if (check(t + "es")) { return true; }
            break;
        } return false;
    }
    function isUsedOrBanned(title) {
        function isUsed(lowerTitle) {
            if (used.size === 0) {
                const usedTitles = Internal.getUsedTitles();
                for (let i = 0; i < usedTitles.length; i++) {
                    used.add(usedTitles[i].toLowerCase());
                }
                if (used.size === 0) {
                    // Add a placeholder so compute isn't wasted on additional checks during this hook
                    used.add("%@%");
                }
            }
            return used.has(lowerTitle);
        }
        return checkPlurals(title, t => (isUsed(t) || isBanned(t)));
    }
    function isBanned(lowerTitle, getUsedIsExternal) {
        if (bans.size === 0) {
            // In order to save space, implicit bans aren't listed within the UI
            const controlVariants = getControlVariants();
            const dataVariants = getDataVariants();
            const bansToAdd = [...lowArr([
                ...Internal.getBannedTitles(),
                controlVariants.enable.title.replace("\n", ""),
                controlVariants.enable.keys,
                controlVariants.configure.title.replace("\n", ""),
                controlVariants.configure.keys,
                dataVariants.debug.title,
                dataVariants.debug.keys,
                dataVariants.critical.title,
                dataVariants.critical.keys,
                ...Object.values(Words.reserved)
            ]), ...(function() {
                if (shouldProceed() || getUsedIsExternal) {
                    // These proper nouns are way too common to waste card generations on; they already exist within the AI training data so this would be pointless
                    return [...Words.entities, ...Words.undesirables.map(undesirable => see(undesirable))];
                } else {
                    return [];
                }
            })()];
            for (let i = 0; i < bansToAdd.length; i++) {
                bans.add(bansToAdd[i]);
            }
        }
        return bans.has(lowerTitle);
    }
    function isNamed(title, returnSurname) {
        const peerage = new Set(Words.peerage);
        const minorWords = new Set(Words.minor);
        if ((forenames.size === 0) || (surnames.size === 0)) {
            const usedTitles = Internal.getUsedTitles();
            for (let i = 0; i < usedTitles.length; i++) {
                const usedTitleWords = divideTitle(usedTitles[i]);
                if (
                    (usedTitleWords.length === 2)
                    && (2 < usedTitleWords[0].length)
                    && (2 < usedTitleWords[1].length)
                ) {
                    forenames.add(usedTitleWords[0]);
                    surnames.add(usedTitleWords[1]);
                } else if (
                    (usedTitleWords.length === 1)
                    && (2 < usedTitleWords[0].length)
                ) {
                    forenames.add(usedTitleWords[0]);
                }
            }
            if (forenames.size === 0) {
                forenames.add("%@%");
            }
            if (surnames.size === 0) {
                surnames.add("%@%");
            }
        }
        const titleWords = divideTitle(title);
        if (
            returnSurname
            && (titleWords.length === 2)
            && (3 < titleWords[0].length)
            && (3 < titleWords[1].length)
            && forenames.has(titleWords[0])
            && surnames.has(titleWords[1])
        ) {
            return (title
                .split(" ")
                .find(casedTitleWord => (casedTitleWord.toLowerCase() === titleWords[1]))
            );
        } else if (
            (titleWords.length === 2)
            && (2 < titleWords[0].length)
            && (2 < titleWords[1].length)
            && forenames.has(titleWords[0])
        ) {         
            return true;
        } else if (
            (titleWords.length === 1)
            && (2 < titleWords[0].length)
            && (forenames.has(titleWords[0]) || surnames.has(titleWords[0]))
        ) {
            return true;
        }
        function divideTitle(undividedTitle) {
            const titleWords = undividedTitle.toLowerCase().split(" ");
            if (titleWords.some(word => minorWords.has(word))) {
                return [];
            } else {
                return titleWords.filter(word => !peerage.has(word));
            }
        }
        return false;
    }
    function shouldProceed() {
        return (AC.config.doAC && !AC.signal.emergencyHalt && (AC.chronometer.postpone < 1));
    }
    function isDoSayStory(type) {
        return (isDoSay(type) || (type === "story"));
    }
    function isDoSay(type) {
        return ((type === "do") || (type === "say"));
    }
    function permitOutput() {
        return ((AC.config.deleteAllAutoCards === null) && (AC.signal.outputReplacement === ""));
    }
    function isAwaitingGeneration() {
        return (0 < AC.generation.pending.length);
    }
    function isPendingGeneration() {
        return notEmptyObj(AC.generation.workpiece);
    }
    function isPendingCompression() {
        return (AC.compression.titleKey !== "");
    }
    function notEmptyObj(obj) {
        return (obj && (0 < Object.keys(obj).length));
    }
    function clearTransientTitles() {
        AC.database.titles.used = [];
        [used, forenames, surnames].forEach(nameset => nameset.clear());
        return;
    }
    function banTitle(title, isFinalAssignment) {
        title = limitString(title.replace(/\s+/g, " ").trim(), 100);
        const lowerTitle = title.toLowerCase();
        if (bans.size !== 0) {
            bans.add(lowerTitle);
        }
        if (!lowArr(Internal.getBannedTitles()).includes(lowerTitle)) {
            AC.database.titles.banned.unshift(title);
            if (isFinalAssignment) {
                return;
            }
            AC.database.titles.pendingBans.unshift([title, 3]);
            const index = AC.database.titles.pendingUnbans.findIndex(pair => (pair[0].toLowerCase() === lowerTitle));
            if (index !== -1) {
                AC.database.titles.pendingUnbans.splice(index, 1);
            }
        }
        return;
    }
    function unbanTitle(title) {
        title = title.replace(/\s+/g, " ").trim();
        const lowerTitle = title.toLowerCase();
        if (used.size !== 0) {
            bans.delete(lowerTitle);
        }
        let index = lowArr(Internal.getBannedTitles()).indexOf(lowerTitle);
        if (index !== -1) {
            AC.database.titles.banned.splice(index, 1);
            AC.database.titles.pendingUnbans.unshift([title, 3]);
            index = AC.database.titles.pendingBans.findIndex(pair => (pair[0].toLowerCase() === lowerTitle));
            if (index !== -1) {
                AC.database.titles.pendingBans.splice(index, 1);
            }
        }
        return;
    }
    function lowArr(arr) {
        return arr.map(str => str.toLowerCase());
    }
    function getControlVariants() {
        return O.f({
            configure: O.f({
                title: "Configure \nAuto-Cards",
                keys: "Edit the entry above to adjust your story card automation settings",
            }),
            enable: O.f({
                title: "Edit to enable \nAuto-Cards",
                keys: "Edit the entry above to enable story card automation",
            }),
        });
    }
    function getDataVariants() {
        return O.f({
            debug: O.f({
                title: "Debug Data",
                keys: "You may view the debug state in the notes section below",
            }),
            critical: O.f({
                title: "Critical Data",
                keys: "Never modify or delete this story card",
            }),
        });
    }
    // Prepare to export the codomain
    const codomain = CODOMAIN.read();
    const [stopPackaged, lastCall] = (function() {
        // Tbh I don't know why I even bothered going through the trouble of implementing "stop" within LSIv2
        switch(HOOK) {
        case "context": {
            const haltStatus = [];
            if (Array.isArray(codomain)) {
                O.f(codomain);
                haltStatus.push(true, codomain[1]);
            } else {
                haltStatus.push(false, STOP);
            }
            if ((AC.config.LSIv2 !== false) && (haltStatus[1] === true)) {
                // AutoCards will return [text, (stop === true)] onContext
                // The onOutput lifecycle hook will not be executed during this turn
                concludeEmergency();
            }
            return haltStatus; }
        case "output": {
            // AC.config.LSIv2 being either true or null implies (lastCall === true)
            return [null, AC.config.LSIv2 ?? true]; }
        default: {
            return [null, null]; }
        }
    })();
    // Repackage AC to propagate its state forward in time
    if (state.LSIv2) {
        // Facilitates recursive calls of AutoCards
        // The Auto-Cards external API is accessible through the LSIv2 scope
        state.LSIv2 = AC;
    } else {
        const memoryOverflow = (38000 < (JSON.stringify(state).length + JSON.stringify(AC).length));
        if (memoryOverflow) {
            // Memory overflow is imminent
            const dataVariants = getDataVariants();
            if (lastCall) {
                unbanTitle(dataVariants.debug.title);
                banTitle(dataVariants.critical.title);
            }
            setData(dataVariants.critical, dataVariants.debug);
            if (state.AutoCards) {
                // Decouple state for safety
                delete state.AutoCards;
            }
        } else {
            if (lastCall) {
                const dataVariants = getDataVariants();
                unbanTitle(dataVariants.critical.title);
                if (AC.config.showDebugData) {
                    // Update the debug data card
                    banTitle(dataVariants.debug.title);
                    setData(dataVariants.debug, dataVariants.critical);
                } else {
                    // There should be no data card
                    unbanTitle(dataVariants.debug.title);
                    if (data === null) {
                        data = getSingletonCard(false, O.f({...dataVariants.debug}), O.f({...dataVariants.critical}));
                    }
                    eraseCard(data);
                    data = null;
                }
            } else if (AC.config.showDebugData && (HOOK === undefined)) {
                const dataVariants = getDataVariants();
                setData(dataVariants.debug, dataVariants.critical);
            }
            // Save a backup image to state
            state.AutoCards = AC;
        }
        function setData(primaryVariant, secondaryVariant) {
            const dataCardTemplate = O.f({
                type: AC.config.defaultCardType,
                title: primaryVariant.title,
                keys: primaryVariant.keys,
                entry: (function() {
                    const mutualEntry = (
                        "If you encounter an Auto-Cards bug or otherwise wish to help me improve this script by sharing your configs and game data, please send me the notes text found below. You may ping me @LewdLeah through the official AI Dungeon Discord server. Please ensure the content you share is appropriate for the server, otherwise DM me instead. üòå"
                    );
                    if (memoryOverflow) {
                        return (
                            "Seeing this means Auto-Cards detected an imminent memory overflow event. But fear not! As an emergency fallback, the full state of Auto-Cards' data has been serialized and written to the notes section below. This text will be deserialized during each lifecycle hook, therefore it's absolutely imperative that you avoid editing this story card!"
                        ) + (function() {
                            if (AC.config.showDebugData) {
                                return "\n\n" + mutualEntry;
                            } else {
                                return "";
                            }
                        })();
                    } else {
                        return (
                            "This story card displays the full serialized state of Auto-Cards. To remove this card, simply set the \"log debug data\" setting to false within your \"Configure\" card. "
                        ) + mutualEntry;
                    }
                })(),
                description: JSON.stringify(AC)
            });
            if (data === null) {
                data = getSingletonCard(true, dataCardTemplate, O.f({...secondaryVariant}));
            }
            for (const propertyName of ["title", "keys", "entry", "description"]) {
                if (data[propertyName] !== dataCardTemplate[propertyName]) {
                    data[propertyName] = dataCardTemplate[propertyName];
                }
            }
            const index = storyCards.indexOf(data);
            if ((index !== -1) && (index !== (storyCards.length - 1))) {
                // Ensure the data card is always at the bottom of the story cards list
                storyCards.splice(index, 1);
                storyCards.push(data);
            }
            return;
        }
    }
    // This is the only return point within the parent scope of AutoCards
    if (stopPackaged === false) {
        return [codomain, STOP];
    } else {
        return codomain;
    }
} AutoCards(null); function isolateLSIv2(code, log, text, stop) { const console = Object.freeze({log}); try { eval(code); return [null, text, stop]; } catch (error) { return [error, text, stop]; } }

// TAS Library Script  modified
// added simple time format

// PASTE THIS ENTIRE BLOCK AFTER THE AUTOCARDS FUNCTION IN YOUR LIBRARY
// ==================================================================

(function() {
    'use strict';

    // --- MASTER CONTROL SWITCHES ---
    const enableFormatter = true; 
    // const enableSAE = true; 

    // --- SHARED AC API INSTANCE ---
    let sharedAcAPI = null;

    // --- HELPER FUNCTION FOR IN-BODY SYSTEM MESSAGES ---
    function formatSystemMessage(messageContent) {
        return `\n\nüîπüîπüîπüîπ ${messageContent.trim()} üîπüîπüîπüîπ\n\n`;

    }
    // --- TEXT SIMILARITY SCORE FUNCTION ---
    function textSimilarityScore(strA, strB) {
        if (strA === strB) return 1;
        const cleanA = (strA || "").replace(/[0-9\s]/g, " ").trim().replace(/  +/g, " ").toLowerCase();
        const cleanB = (strB || "").replace(/[0-9\s]/g, " ").trim().replace(/  +/g, " ").toLowerCase();
        if (cleanA === cleanB) return 1;
        const lengthA = cleanA.length; const lengthB = cleanB.length;
        if (lengthA === 0 || lengthB === 0) return 0;
        const dp = Array(lengthA + 1).fill(null).map(() => Array(lengthB + 1).fill(0));
        for (let i = 0; i <= lengthA; i++) dp[i][0] = i;
        for (let j = 0; j <= lengthB; j++) dp[0][j] = j;
        for (let i = 1; i <= lengthA; i++) {
            for (let j = 1; j <= lengthB; j++) {
                dp[i][j] = (cleanA[i - 1] === cleanB[j - 1]) ? dp[i-1][j-1] : 1 + Math.min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]);
            }
        }
        return 1 - (dp[lengthA][lengthB] / Math.max(lengthA, lengthB || 1));
    }

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // MODULE: Text Formatter
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    const Formatter = {
        defaults: {
            isEnabled: true, enableClicheRemover: true, enableRandomReplacer: true, enableRepetitionRemover: true,
            aggressive_delete: [ "casting long shadows", "Well, well, well", "knuckles go white", "taps her nails", "tapping her nails", "her fingers idly tapping", "Her fingers tap", "fingers drum", "fingers drumming idly", "Her fingers drum idly against the desk", "Her fingers tap idly against the desk", "tapping two fingers", "the cool air in the room making her skin prickle with goosebumps.", "You're something else", "You're full of surprises, aren't you?", "Knuckles white", "manicured nails", "knuckles whiten", "knuckles have turned stark white", "knuckles are bone-white", "knuckles are a stark white", "knuckles turn a stark white", "knuckles have turned a ghostly white", "knuckles are stark white", "knuckles turn stark white", "knuckles turn white", "Knuckles turning white", "knuckles turn a ghostly white", "little mortal", "glinting with mischief", "like a predator circling its prey", "casting long, angular shadows", "The morning sun cast long shadows", "The morning sun cast a warm glow", "practiced ease", "jaw clenching", "dim light", "speaking softly", "Intense", "A chill runs down your spine", "with messy dark hair", "casts a golden hue", "casts a warm glow", "casts long shadows", "ice queen", "look what the cat dragged in", "cat dragged in", "messy brown hair", "Piece of work", "cacophony", "predatory", "cocoon", "folded note", "crumpled piece of paper", "cast long shadows", "panties in a twist", "You've got some balls on you", "The morning sunlight filters through the windows, casting long shadows across the floor.", "the air is thick", "words hang heavy in the air", "The atmosphere is thick with", "you can't help", "Well, aren't you just full of surprises", "your heart beats", "your mind wanders", "voice crackles with", "dimly lit", "sweetheart", "a stark contrast", "a twisted sense of", "breath hot on your face", "hangs in the air", "feel a chill run down your spine", "shiver down your spine", "shiver up your spine", "your voice a mix of", "a wave of", "voice just above a whisper", "eyes gleaming with", "a mixture of surprise and curiosity", "pride and accomplishment", "jolt of electricity", "glowing with an otherworldly light", "smile playing at the corners of his lips", "smile playing at the corners of her lips", "face contorts with anger", "eyes glistening with unshed tears", "unshed tears", "intricately carved wooden box", "the tension in the room is palpable", "hips swaying enticingly", "takes a step closer", "brushes a stray hair from your face", "face set in a grim mask", "mouth set in a grim line", "hand resting on the hilt of his sword", "hand instinctively goes to the hilt of his sword", "the hum of machinery", "merely a pawn in a much larger game", "this changes everything", "could Have fooled me", "but tinged with" ],
            precise_delete: [ "looming ominously" ],
            replace: [ ["verdant", "green"], ["curtly", "shortly"], ["leverage", "use"], ["robust", "strong"], ["unprecedented", "new"], ["myriad", "many"], ["commence", "start"], ["ascertain", "find out"], ["endeavor", "try"], ["utilize", "use"], ["facilitate", "help"], ["plethora", "a lot"], ["elucidate", "explain"], ["exemplify", "show"], ["paradigm", "model"], ["synergy", "teamwork"], ["traverse", "cross"], ["illuminate", "explain"], ["manifest", "show"], ["intricate", "complex"], ["subsequent", "next"], ["procure", "get"], ["amidst", "among"], ["visage", "face"], ["peruse", "read"], ["cascade", "flow"], ["linger", "stay"], ["fervor", "excitement"], ["tranquil", "calm"], ["emanate", "come from"], ["beckon", "call"], ["venture", "go"], ["gaze", "look"], ["inquire", "ask"], ["exclaim", "shout"], ["murmur", "whisper"] ],
            name_replace: [ ["Li1ly", "Lorelei"], ["Lisf42a", "Larisa"], ["Sa1lawt", "Sol√®ne"], ["J32ake", "Jasper"], ["A14lx", "Abel"] ],
            randomReplacementGroups: [ { phrase: "Elara", options: [ "Areal", "Leara", "Alrea", "Reala", "Vaila", "Ealra", "Alear", "Alare", "Aaerl", "Alare", ] }, { phrase: "Sarah", options: [ "Amelia", "Evelyn", "Ashley", "Violet", "Elsie", "Lucy", "Jane", "Rebecca", "Madison", "Rachel", "Vanessa", "Mia", "Elsie", "Chloe", "Alice", "Emily", "Emma" ] }, { phrase: "Mr. Thompson", options: [ "Mr. Aldridge", "Mr. Barrington", "Mr. Kessler", "Mr. Coldwell", "Mr. Davenport", "Mr. Ellsworth", "Mr. Fairchild", "Mr. Hargrove", "Mr. Quillson", "Mr. Ainsworth", "Mr. Kensington", "Mr. Lancaster", "Mr. Montague", "Mr. Norwood", "Mr. Pennington", "Mr. Radcliffe", "Mr. Somerville", "Mr. Wentworth" ] }, { phrase: "Mrs. Thompson", options: [ "Mrs. Ashbourne", "Mrs. Blythe", "Mrs. Carrington", "Mrs. Dovewell", "Mrs. Everhart", "Mrs. Fenwick", "Mrs. Islington", "Mrs. Lockridge", "Mrs. Jasmere", "Mrs. Sterling", "Mrs. Claremont", "Mrs. Iverson", "Mrs. Quillan", "Mrs. Rosendale", "Mrs. Valmere" ] }, { phrase: "Ms. Thompson", options: [ "Ms. Durnell", "Ms. Blythe", "Ms. Everston", "Ms. Dovewell", "Ms. Everhart", "Ms. Fenwick", "Ms. Morrow", "Ms. Lockridge", "Ms. Jasmere", "Ms. Sterling", "Ms. Claremont", "Ms. Nightford", "Ms. Quillan", "Ms. Rosendale", "Ms. Valmere" ] } ],
            initialized: true
        },
        initialize: function(acAPI) {this.acAPI = acAPI; if (!state.formatter || !state.formatter.initialized) {state.formatter = JSON.parse(JSON.stringify(this.defaults));} else {for(const key in this.defaults){if(state.formatter[key]===undefined){state.formatter[key]=JSON.parse(JSON.stringify(this.defaults[key]));}} state.formatter.initialized = true;}},
        updateAndCreateCards: function() {if (!this.acAPI)return;const cT="Formatter Settings";const d="---";let sC=this.acAPI.getCard(c=>c&&c.title===cT);if(!sC){sC=this.acAPI.buildCard({title:cT,entry:"",keys:"formatter-settings",description:""});if(!sC)return;}const e=sC.entry||"";const pB=(t,k,f)=>{const m=t.match(new RegExp(`>\\s*${k}:\\s*(true|false)`,'i'));return m?(m[1].toLowerCase()==='true'):f;};state.formatter.isEnabled=pB(e,"isEnabled",state.formatter.isEnabled !== undefined ? state.formatter.isEnabled : this.defaults.isEnabled);state.formatter.enableClicheRemover=pB(e,"enableClicheRemover",state.formatter.enableClicheRemover !== undefined ? state.formatter.enableClicheRemover : this.defaults.enableClicheRemover);state.formatter.enableRandomReplacer=pB(e,"enableRandomReplacer",state.formatter.enableRandomReplacer !== undefined ? state.formatter.enableRandomReplacer : this.defaults.enableRandomReplacer);state.formatter.enableRepetitionRemover=pB(e,"enableRepetitionRemover",state.formatter.enableRepetitionRemover !== undefined ? state.formatter.enableRepetitionRemover : this.defaults.enableRepetitionRemover);const desc=sC.description||"";const dS=desc.split(d);const fH="Fixed Name Replacements:";const fT=dS.find(s=>s.trim().startsWith(fH))?.substring(fH.length).trim();if(fT){const p=fT.split(',').map(i=>{const pair=i.split('=').map(x=>x.trim());return pair.length===2?pair:null;}).filter(Boolean);state.formatter.name_replace=p.length>0?p:JSON.parse(JSON.stringify(this.defaults.name_replace));}else{state.formatter.name_replace=JSON.parse(JSON.stringify(this.defaults.name_replace));}const rH="Random Name Replacements:";const rB=dS.find(s=>s.trim().startsWith(rH));const rT=rB?.substring(rH.length).trim();if(rT){const p=rT.split('\n').map(l=>{l=l.trim();if(!l)return null;const pts=l.split(':');if(pts.length<2)return null;const ph=pts[0].trim();const op=pts.slice(1).join(':').split('|').map(o=>o.trim()).filter(Boolean);if(!ph||op.length===0)return null;return{phrase:ph,options:op};}).filter(Boolean);state.formatter.randomReplacementGroups=p.length>0?p:JSON.parse(JSON.stringify(this.defaults.randomReplacementGroups));}else{state.formatter.randomReplacementGroups=JSON.parse(JSON.stringify(this.defaults.randomReplacementGroups));}const nE=`> isEnabled: ${state.formatter.isEnabled}\n> enableClicheRemover: ${state.formatter.enableClicheRemover}\n> enableRandomReplacer: ${state.formatter.enableRandomReplacer}\n> enableRepetitionRemover: ${state.formatter.enableRepetitionRemover}`;const nF=state.formatter.name_replace.map(p=>p.join('=')).join(', ');const nR=state.formatter.randomReplacementGroups.map(g=>`${g.phrase}:${g.options.join('|')}`).join('\n');const nD=`${fH} ${nF}\n${d}\n${rH}\n${nR}`;if(sC.entry!==nE)sC.entry=nE;if(sC.description!==nD)sC.description=nD;},
        format: function(text, context) {if(!state.formatter||!state.formatter.isEnabled||!text||typeof text!=='string')return text||'';const paras=text.split('\n\n');const procParas=paras.map(para=>{let p=para.trim();if(p.startsWith('"')&&p.endsWith('"')){if(state.formatter.name_replace){for(const [t,r]of state.formatter.name_replace)p=p.replace(new RegExp(this.escapeRegex(t),'gi'),r);}if(state.formatter.randomReplacementGroups)p=this.applyRandomReplacements(p);return p;}if(state.formatter.enableClicheRemover)p=this.delete_cliches(p);if(state.formatter.enableRandomReplacer)p=this.applyRandomReplacements(p);if(state.formatter.enableRepetitionRemover)p=this.removeRepeatedPhrases(p,context);return p;});let finTxt=procParas.filter(p=>p&&p.trim()!=="").join('\n\n');finTxt=this.removeEmptyQuotes(finTxt);return finTxt.trim();},
        delete_cliches: function(text){const aggr=(state.formatter?.aggressive_delete)??this.defaults.aggressive_delete;const prec=(state.formatter?.precise_delete)??this.defaults.precise_delete;const repl=(state.formatter?.replace)??this.defaults.replace;const nameRepl=(state.formatter?.name_replace)??this.defaults.name_replace;const sentences=text.match(/[^.!?]+[.!?]*\s*/g)||[text];let newText="";for(const sentence of sentences){let d=false;const trimS=sentence.trim();if(trimS===""){newText+=sentence;continue;}for(const ip of aggr){if(trimS.toLowerCase().includes(ip.toLowerCase())){d=true;break;}}if(!d){newText+=sentence;}}let filt=newText.trim()?newText:text;if(filt.trim()==="")return"";for(const p of prec)filt=filt.replace(new RegExp(this.escapeRegex(p),'gi'),'');for(const [t,r]of repl)filt=filt.replace(new RegExp(this.escapeRegex(t),'gi'),r);for(const [t,r]of nameRepl)filt=filt.replace(new RegExp(this.escapeRegex(t),'gi'),r);return filt;},
        applyRandomReplacements: function(text){const groups=(state.formatter?.randomReplacementGroups)??this.defaults.randomReplacementGroups;groups.forEach(g=>{if(!g.phrase||!g.options||g.options.length===0)return;const rgx=new RegExp('(?<![\\w-])'+this.escapeRegex(g.phrase)+'(?![\\w-])','gi');if(rgx.test(text)){const r=g.options[Math.floor(Math.random()*g.options.length)];text=text.replace(rgx,r);}});return text;},
        removeRepeatedPhrases: function(out,ctx,minWL=6){const cln=(t)=>(t?t.toString().trim().replace(/\s+/g,' '):'');out=cln(out);ctx=cln(ctx);if(!out||!ctx)return out;const w=out.split(' ');if(w.length<minWL)return out;const rm=new Set();for(let l=minWL;l<=Math.min(w.length,10);l++){for(let i=0;i<=w.length-l;i++){const phr=w.slice(i,i+l).join(' ');if(phr.length<15&&l<4)continue;if(ctx.includes(phr))rm.add(phr);}}let filt=out;rm.forEach(p=>{filt=filt.replace(new RegExp('\\b'+this.escapeRegex(p)+'\\b','g'),'');});return filt.replace(/\s+/g,' ').trim();},
        removeEmptyQuotes: function(text){return text.replace(/"\s*"/g,"").replace(/'\s*'/g,"");},
        escapeRegex: function(str){if(typeof str!=='string')return'';return str.replace(/[-\/\\^$*+?.()|[\]{}]/g,'\\$&');}
    };

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // MODULE: SIMPLIFIED TIME TRACKER (STT)
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    const STT = {
        daysOfWeek:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],defaultSettings:{isEnabled:true,timePassOnDo:5,timePassOnSay:1,timePassOnStory:5,timePassOnContinue:5,pinSettingsCard:true,showTimeTimestamp:false,timeTimestampFrequency:1,showDateTimestamp:false,dateTimestampFrequency:5,useToastForTimestamps:true,gameHour:7,gameMinute:11,dayOfMonth:24,month:6,year:2025,dayOfWeek:3,timeSkipInfo:null,initialized:true},
        initialize:function(acAPI){
            this.acAPI = acAPI;
            let needsDateRecalc = false;
            if (!state.stt || !state.stt.initialized) {
                state.stt = JSON.parse(JSON.stringify(this.defaultSettings));
                needsDateRecalc = true;
            } else {
                for (const key in this.defaultSettings) {
                    if (state.stt[key] === undefined) {
                        state.stt[key] = JSON.parse(JSON.stringify(this.defaultSettings[key]));
                        if (['gameHour', 'gameMinute', 'dayOfMonth', 'month', 'year'].includes(key)) {
                            needsDateRecalc = true;
                        }
                    }
                }
            }
            state.stt.initialized = true;

            try {
                const currentDate = new Date(
                    state.stt.year, state.stt.month, state.stt.dayOfMonth,
                    state.stt.gameHour, state.stt.gameMinute
                );
                if (isNaN(currentDate.getTime())) {
                    // Simplified error handling for cleaned version
                    console.warn("STT.initialize: Invalid date in state. Resetting.");
                    state.stt = JSON.parse(JSON.stringify(this.defaultSettings));
                    const validDefaultDate = new Date(state.stt.year, state.stt.month, state.stt.dayOfMonth);
                    state.stt.dayOfWeek = validDefaultDate.getDay();
                } else if (needsDateRecalc || state.stt.dayOfWeek !== currentDate.getDay()) {
                    state.stt.dayOfWeek = currentDate.getDay();
                }
            } catch (e) {
                console.error("STT.initialize: Date validation error. Resetting.", e);
                state.stt = JSON.parse(JSON.stringify(this.defaultSettings));
                const validDefaultDate = new Date(state.stt.year, state.stt.month, state.stt.dayOfMonth);
                state.stt.dayOfWeek = validDefaultDate.getDay();
            }
        },
        updateSettingsFromCard:function(){if(!this.acAPI)return;if(!state.stt)state.stt=JSON.parse(JSON.stringify(this.defaultSettings));const sc=this.acAPI.getCard(c=>c&&c.title==="Time Tracker Settings");if(!sc||!sc.entry)return;const et=sc.entry;const gV=(rgx,fb,isB=false)=>{const m=et.match(rgx);if(m&&m[1]!==undefined){if(isB)return m[1].toLowerCase()==='true';const pN=parseInt(m[1]);return Number.isFinite(pN)?pN:fb;}return fb;};state.stt.isEnabled=gV(/isEnabled:\s*(true|false)/i,state.stt.isEnabled !== undefined ? state.stt.isEnabled : this.defaultSettings.isEnabled,true);state.stt.timePassOnDo=gV(/timePassOnDo:\s*(\d+)/i,state.stt.timePassOnDo !== undefined ? state.stt.timePassOnDo : this.defaultSettings.timePassOnDo);state.stt.timePassOnSay=gV(/timePassOnSay:\s*(\d+)/i,state.stt.timePassOnSay !== undefined ? state.stt.timePassOnSay : this.defaultSettings.timePassOnSay);state.stt.timePassOnStory=gV(/timePassOnStory:\s*(\d+)/i,state.stt.timePassOnStory !== undefined ? state.stt.timePassOnStory : this.defaultSettings.timePassOnStory);state.stt.timePassOnContinue=gV(/timePassOnContinue:\s*(\d+)/i,state.stt.timePassOnContinue !== undefined ? state.stt.timePassOnContinue : this.defaultSettings.timePassOnContinue);},
        checkAndCreateCards:function(){if(!this.acAPI)return;const t="Time Tracker Settings";let sc=this.acAPI.getCard(c=>c&&c.title===t);if(!sc){sc=this.acAPI.buildCard({title:t,entry:"",keys:"stt-settings",description:""});if(!sc)return;}const s=state.stt||this.defaultSettings;const nE=`> Settings below. Edit & act.\n> ---\n> isEnabled: ${s.isEnabled}\n> timePassOnDo: ${s.timePassOnDo}\n> timePassOnSay: ${s.timePassOnSay}\n> timePassOnStory: ${s.timePassOnStory}\n> timePassOnContinue: ${s.timePassOnContinue}`;const nD=`Mins/action. 0="free".\n\nCmds:\n/settime HH:MM\n/setdate YYYY-MM-DD\n/defer N unit\n/wait until [time]`;if(sc.entry!==nE)sc.entry=nE;if(sc.description!==nD)sc.description=nD;},
        advanceInGameTime:function(mins){
            if(!state.stt||!state.stt.isEnabled||typeof mins!=='number'||!Number.isFinite(mins)||mins<=0)return;
            const cY=Number.isFinite(state.stt.year)?state.stt.year:this.defaultSettings.year; const cMo=Number.isFinite(state.stt.month)?state.stt.month:this.defaultSettings.month; const cD=Number.isFinite(state.stt.dayOfMonth)?state.stt.dayOfMonth:this.defaultSettings.dayOfMonth; const cH=Number.isFinite(state.stt.gameHour)?state.stt.gameHour:this.defaultSettings.gameHour; const cMi=Number.isFinite(state.stt.gameMinute)?state.stt.gameMinute:this.defaultSettings.gameMinute; const OD=1440;
            if(mins>=OD){if(mins<OD*7)state.stt.timeSkipInfo="a few days";else if(mins<OD*30)state.stt.timeSkipInfo="several weeks";else if(mins<OD*365)state.stt.timeSkipInfo="several months";else state.stt.timeSkipInfo="several years";state.stt.timeSkipInfo+=" passed";}else{state.stt.timeSkipInfo=null;}
            const date=new Date(cY,cMo,cD,cH,cMi);
            if(isNaN(date.getTime())){
                console.warn("STT Error: Invalid date in advanceInGameTime. Resetting.");
                Object.assign(state.stt, JSON.parse(JSON.stringify(this.defaultSettings)));
                const rD=new Date(state.stt.year,state.stt.month,state.stt.dayOfMonth,state.stt.gameHour,state.stt.gameMinute); state.stt.dayOfWeek=rD.getDay(); return;
            }
            date.setMinutes(date.getMinutes()+mins);
            state.stt.year=date.getFullYear();state.stt.month=date.getMonth();state.stt.dayOfMonth=date.getDate();state.stt.gameHour=date.getHours();state.stt.gameMinute=date.getMinutes();state.stt.dayOfWeek=date.getDay();
        },
        getDayNightStatus:function(){if(!state.stt||!Number.isFinite(state.stt.gameHour))return "Unknown";const h=state.stt.gameHour;if(h>=5&&h<12)return"Morning";if(h>=12&&h<17)return"Afternoon";if(h>=17&&h<21)return"Evening";return"Night";},
        getFormattedTime:function(inclDN=true){if(!state.stt||!Number.isFinite(state.stt.dayOfWeek)||!Number.isFinite(state.stt.month)||state.stt.dayOfWeek<0||state.stt.dayOfWeek>=this.daysOfWeek.length||state.stt.month<0||state.stt.month>=this.months.length)return"üï∞Ô∏è Time data error";const pad=(n)=>String(Number.isFinite(n)?n:0).padStart(2,'0');const dN=this.daysOfWeek[state.stt.dayOfWeek];const mN=this.months[state.stt.month];let tS=`${dN}, ${mN} ${Number.isFinite(state.stt.dayOfMonth)?state.stt.dayOfMonth:1}, Year ${Number.isFinite(state.stt.year)?state.stt.year:1}, ${pad(state.stt.gameHour)}:${pad(state.stt.gameMinute)}`;if(inclDN)tS+=` (${this.getDayNightStatus()})`;return tS;},
        calculateMinutesUntilHour:function(tH){if(!state.stt||!Number.isFinite(state.stt.gameHour)||!Number.isFinite(state.stt.gameMinute)||!Number.isFinite(tH)||tH<0||tH>23)return 0;let cTM=(state.stt.gameHour*60)+state.stt.gameMinute;let tTM=tH*60;return(tTM<=cTM)?((1440)-cTM)+tTM:tTM-cTM;},
        handleInput:function(rawPlayerInput){ 
            let txt=rawPlayerInput;let cmdH=false;if(!state.stt)return{text:txt,commandHandled:false};
            const ci=rawPlayerInput.trim().toLowerCase(); 
            if(!state.stt.isEnabled)return{text:txt,commandHandled:false};
            if(ci.startsWith("/settime")){const m=rawPlayerInput.match(/(\d{1,2}):(\d{2})/);if(m){let [_,h,mm]=m.map(Number);if(h>=0&&h<=23&&mm>=0&&mm<=59){state.stt.gameHour=h;state.stt.gameMinute=mm;txt=formatSystemMessage(`‚úÖ Time set: ${String(h).padStart(2,'0')}:${String(mm).padStart(2,'0')}`);}else{txt=formatSystemMessage("‚ö†Ô∏è Invalid time (H 0-23, M 0-59).");}}else{txt=formatSystemMessage("ü§î Use: /settime HH:MM");}cmdH=true;}
            else if(ci.startsWith("/setdate")){const m=rawPlayerInput.match(/(\d{4})-(\d{1,2})-(\d{1,2})/);if(m){const [_,y,mo,d]=m.map(Number);if(y>0&&mo>=1&&mo<=12&&d>=1&&d<=31){state.stt.year=y;state.stt.month=mo-1;state.stt.dayOfMonth=d;const tD=new Date(y,mo-1,d);state.stt.dayOfWeek=tD.getDay();txt=formatSystemMessage(`üìÖ Date set: Year ${y}, ${this.months[mo-1]} ${d}.`);}else{txt=formatSystemMessage("‚ö†Ô∏è Invalid date values.");}}else{txt=formatSystemMessage("ü§î Use: /setdate YYYY-MM-DD");}cmdH=true;}
            else if(ci.startsWith("/defer")){
                const m=rawPlayerInput.match(/\/defer\s+(\d+)\s*(minutes?|mins?|hours?|hrs?|days?|weeks?|wks?|months?|mos?|years?|yrs?)/i); 
                if(m){
                    const amt=parseInt(m[1]); const u=m[2]?.toLowerCase()??'minutes'; let mins=0; let dU=u;
                    if(u.startsWith('min')){mins=amt;dU=amt===1?"minute":"minutes";} else if(u.startsWith('h')){mins=amt*60;dU=amt===1?"hour":"hours";} else if(u.startsWith('d')){mins=amt*1440;dU=amt===1?"day":"days";} else if(u.startsWith('w')){mins=amt*10080;dU=amt===1?"week":"weeks";} else if(u.startsWith('mo')){mins=amt*43800;dU=amt===1?"month":"months";} else if(u.startsWith('y')){mins=amt*525600;dU=amt===1?"year":"years";}
                    if(mins > 0) { this.advanceInGameTime(mins); txt = formatSystemMessage(`‚è© Time advanced ${amt} ${dU}. New time: ${this.getFormattedTime()}`);
                    } else { if (amt > 0 && mins === 0) { txt = formatSystemMessage(`‚ö†Ô∏è Invalid unit for defer: '${u}'. Use minutes, hours, days, weeks, months, or years.`); } else { txt = formatSystemMessage("‚ö†Ô∏è Invalid amount or unit for defer. Amount must be positive."); } }
                } else { txt = formatSystemMessage("ü§î Use: /defer N unit (e.g. /defer 5 hours, /defer 10 mins)"); }
                cmdH=true;
            }
            else if(ci.startsWith("/wait until")){const m=rawPlayerInput.match(/\/wait\s+until\s+(morning|noon|afternoon|evening|night)/i);if(m){const tod=m[1].toLowerCase();let th;switch(tod){case'morning':th=6;break;case'noon':th=12;break;case'afternoon':th=14;break;case'evening':th=18;break;case'night':th=22;break;default:th=(state.stt.gameHour||0);}const mtw=this.calculateMinutesUntilHour(th);if(mtw>=0){this.advanceInGameTime(mtw);txt=formatSystemMessage(`üåÖ Time is now ${tod}. Current: ${this.getFormattedTime()}`);}else{txt=formatSystemMessage("ü§î Error calculating wait.");}}else{txt=formatSystemMessage("ü§î Use: /wait until [morning/etc]");}cmdH=true;}
            return{text:txt,commandHandled:cmdH};
        },
        advanceTimeBasedOnAction: function(){
            if(!state.stt || !state.stt.isEnabled) {
                return;
            }

            const actionTypeToUse = state.currentActionTypeForTimeAdvance || 'continue'; 
            
            if (actionTypeToUse === 'system_command' || actionTypeToUse === 'system_message_ignored') { 
                state.currentActionTypeForTimeAdvance = 'continue'; 
                return;
            }

            let tp = 0;
            const s = state.stt;

            switch(actionTypeToUse){
                case 'do':
                    tp = Number.isFinite(s.timePassOnDo) ? s.timePassOnDo : 0;
                    break;
                case 'say':
                    tp = Number.isFinite(s.timePassOnSay) ? s.timePassOnSay : 0;
                    break;
                case 'story':
                    tp = Number.isFinite(s.timePassOnStory) ? s.timePassOnStory : 0;
                    break;
                case 'continue':
                case 'start': 
                    tp = Number.isFinite(s.timePassOnContinue) ? s.timePassOnContinue : 0; 
                    break;
                default:
                    // Intentionally no time passage for unknown types in cleaned version
            }

            if (tp > 0 && typeof tp === 'number' && Number.isFinite(tp)) {
                this.advanceInGameTime(tp);
            }
            state.currentActionTypeForTimeAdvance = 'continue'; 
        },
        appendTimestampsToText: function(txtToMod){if(!state.stt||!state.stt.isEnabled||typeof txtToMod!=='string')return txtToMod;const turn=(typeof info!=='undefined'&&Number.isFinite(info.actionCount))?info.actionCount:0;let tsStr="";const isSysOut=/\[SYSTEM-MSG-START\]|\[SYSTEM:.*\]|>>>|<<<|{>/.test(txtToMod.trim());if(state.stt.showDateTimestamp&&turn>0&&turn%state.stt.dateTimestampFrequency===0){tsStr+=` [üìÖ Date: ${this.getFormattedTime(false)}]`;}if(state.stt.showTimeTimestamp&&turn>0&&turn%state.stt.timeTimestampFrequency===0){tsStr+=` [‚è∞ Time: ${String(state.stt.gameHour||0).padStart(2,'0')}:${String(state.stt.gameMinute||0).padStart(2,'0')} (${this.getDayNightStatus()})]`;}if(tsStr){if(state.stt.useToastForTimestamps&&!isSysOut){if(!state.toastQueue)state.toastQueue=[];state.toastQueue.push(tsStr.trim());return txtToMod;}else if(!isSysOut){return`${txtToMod.trim()}\n${tsStr.trim()}`;}}return txtToMod;},
        handleContext: function(text) {
            if(!state.stt || !state.stt.isEnabled || typeof text!=='string') return text;
            let p = "";
            const formattedTimeForContext = this.getFormattedTime(); 

            if (state.stt.timeSkipInfo) {
                p = `\n[SYSTEM INFO: A skip of roughly ${state.stt.timeSkipInfo} occurred. New date: ${formattedTimeForContext}. Adapt the story to reflect this passage of time.]\n`;
                state.stt.timeSkipInfo = null;
            } else {
                p = `\n[Current In-Game Time: ${formattedTimeForContext}. If asked for the time, present it exactly in this format: "${formattedTimeForContext}". Ensure your narrative response is consistent with this time.]\n`;
            }

            const anM = text.match(/(\[Author's note:[\s\S]*?)(\])/i);
            if (anM) {
                return text.replace(anM[0], `${anM[1]}${p.trim()} ${anM[2]}`);
            }
            return text + p;
        }
    };


// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// MODULE: STORY ARC ENGINE (SAE)- with mid game fix
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
const SAE = { 
        defaults: { isEnabled: true, turnsPerAICall: 25, arcPrompt: `\n[SYSTEM: Stop story. List 11 brief, chronological future events (under 7 words each). Focus on turning points/twists, adhering to specified tone/intensity.]\n`, arcTone: null, arcIntensity: null, toneChosen: false, intensityChosen: false, storyArc: [], activePointIndex: 0, completionSuggested: false, isGenerating: false, saveOutput: false, attemptCounter: 0, hasRunEarly: false, initialized: true, initialized_mid_game: undefined, trigger_initial_arc_on_load: false, postReinitMessage: null },
        tonePrompts:{"sliceoflife":" Focus on personal relationships, daily routines, gentle challenges, character growth. Avoid grand conflicts.","adventure":" Emphasize exploration, discovery, overcoming obstacles, exciting journeys. Include danger & reward.","mystery":" Weave clues, red herrings, secrets, a central puzzle. Build suspense.","romance":" Center on romantic relationship development, emotional connection, obstacles to love, milestones.","intrigue":" Involve political maneuvering, espionage, hidden agendas, betrayal, power struggles. Subtlety & deception.","horror":" Create dread, fear, unease. Unsettling elements, psychological tension, supernatural threats. Player vulnerability.","darkfantasy":" Morally grey characters, bleak settings, corruption. Good may not triumph. Magic dangerous/costly.","heroicfantasy":" Clear good vs evil, brave heroes, powerful villains, magical quests, triumph of good.","comedy":" Prioritize humor, witty dialogue, absurd situations, lighthearted resolutions.","gritty":" Harsh, realistic world, difficult choices, moral ambiguity, consequences. Survival themes.","custom":""},
        intensityPrompts:{"relaxed":" Leisurely pace, minimal pressure/threat. Pleasant interactions, minor issues.","moderate":" Meaningful challenges & stakes requiring effort, without overwhelming pressure.","challenging":" Significant obstacles, tough decisions with consequences, palpable risk. Success earned.","intense":" High-stakes, constant pressure, difficult moral choices, potential for severe consequences/failure."},
        initialize: function(acAPI) { this.acAPI = acAPI; let wasFreshSAEInit = false; if (!state.sae || !state.sae.initialized) { state.sae = JSON.parse(JSON.stringify(this.defaults)); wasFreshSAEInit = true; } else { for (const key in this.defaults) { if (state.sae[key] === undefined) { state.sae[key] = JSON.parse(JSON.stringify(this.defaults[key])); } } } state.sae.initialized = true; state.sae.postReinitMessage = null; if (state.sae.initialized_mid_game === undefined || wasFreshSAEInit) { const currentTurn = (typeof info !== 'undefined' && info.actionCount !== undefined) ? info.actionCount : 0; if (currentTurn > 7 && (wasFreshSAEInit || (!state.sae.hasRunEarly && (!state.sae.storyArc || state.sae.storyArc.length === 0)))) { state.sae.trigger_initial_arc_on_load = true; } state.sae.initialized_mid_game = true; } if (wasFreshSAEInit) { state.sae.postReinitMessage = `Story Arc Engine initialized/reset. Use /setarctype [tone] / [intensity] to begin.`; } },
        updateAndCreateCards: function() { if (!this.acAPI) return; if (!state.sae) state.sae = JSON.parse(JSON.stringify(this.defaults)); let settingsCard = this.acAPI.getCard(c => c && c.title === "Story Arc Settings"); if (!settingsCard) { settingsCard = this.acAPI.buildCard({ title: "Story Arc Settings", entry: "", keys: "Story Arc Settings", description: "" }); if (!settingsCard) return; } const s = state.sae; if (settingsCard.entry) { const cardEntryText = settingsCard.entry; const settingsOnCard = {}; const lines = cardEntryText.split('\n'); lines.forEach(line => { const parts = line.split('='); if (parts.length >= 2) { const key = parts[0].trim(); const value = parts.slice(1).join('=').trim(); settingsOnCard[key] = value; } }); s.isEnabled = settingsOnCard.hasOwnProperty('isEnabled') ? (settingsOnCard.isEnabled.toLowerCase() === 'true') : (s.isEnabled !== undefined ? s.isEnabled : this.defaults.isEnabled); const parsedTurns = settingsOnCard.hasOwnProperty('turnsPerAICall') ? parseInt(settingsOnCard.turnsPerAICall) : NaN; s.turnsPerAICall = Number.isFinite(parsedTurns) ? parsedTurns : (s.turnsPerAICall !== undefined ? s.turnsPerAICall : this.defaults.turnsPerAICall); if (settingsOnCard.hasOwnProperty('arcTone') && !s.toneChosen) { const cardTone = settingsOnCard.arcTone.toLowerCase(); if (this.tonePrompts.hasOwnProperty(cardTone)) { s.arcTone = cardTone; } } else if (!s.toneChosen && s.arcTone === undefined) { s.arcTone = this.defaults.arcTone; } if (settingsOnCard.hasOwnProperty('arcIntensity') && !s.intensityChosen) { const cardIntensity = settingsOnCard.arcIntensity.toLowerCase(); if (this.intensityPrompts.hasOwnProperty(cardIntensity)) { s.arcIntensity = cardIntensity; } } else if (!s.intensityChosen && s.arcIntensity === undefined) { s.arcIntensity = this.defaults.arcIntensity; } s.arcPrompt = settingsOnCard.hasOwnProperty('arcPrompt') ? settingsOnCard.arcPrompt : (s.arcPrompt !== undefined ? s.arcPrompt : this.defaults.arcPrompt); } else { s.isEnabled = s.isEnabled !== undefined ? s.isEnabled : this.defaults.isEnabled; s.turnsPerAICall = s.turnsPerAICall !== undefined ? s.turnsPerAICall : this.defaults.turnsPerAICall; s.arcTone = (!s.toneChosen && s.arcTone === undefined) ? this.defaults.arcTone : s.arcTone; s.arcIntensity = (!s.intensityChosen && s.arcIntensity === undefined) ? this.defaults.arcIntensity : s.arcIntensity; s.arcPrompt = s.arcPrompt !== undefined ? s.arcPrompt : this.defaults.arcPrompt; } const displayTone = s.arcTone || "Not Set"; const displayIntensity = s.arcIntensity || "Not Set"; const newCardEntry = `isEnabled = ${s.isEnabled}\nturnsPerAICall = ${s.turnsPerAICall}\narcTone = ${displayTone}\narcIntensity = ${displayIntensity}\narcPrompt = ${s.arcPrompt}`; const toneOptions = Object.keys(this.tonePrompts).join(', '); const intensityOptions = Object.keys(this.intensityPrompts).join(', '); const newCardDescription = `‚öôÔ∏è SAE Controls:\n/setarctype [tone] / [intensity] ‚ú®üî•\n/regeneratearc ‚ú®\n/saestop üõë\n/currentarcsettings ‚ÑπÔ∏è\n\nTone Opt: ${toneOptions}\nIntensity Opt: ${intensityOptions}\n\nSettings in entry. 'custom' tone uses arcPrompt.`; if (settingsCard.entry !== newCardEntry) settingsCard.entry = newCardEntry; if (settingsCard.description !== newCardDescription) settingsCard.description = newCardDescription; let arcContentCard = this.acAPI.getCard(c => c && c.title === "Current Story Arc"); if (!arcContentCard) { arcContentCard = this.acAPI.buildCard({ title: "Current Story Arc", entry: "", keys: "Current Story Arc", description: "ü§´ SPOILERS! Plot outline." }); if (arcContentCard) s.storyArc = []; } else if (arcContentCard.entry) { const cardArcText = arcContentCard.entry.trim(); if (!s.isGenerating) { s.storyArc = cardArcText ? cardArcText.split('\n').map(l => l.trim()).filter(ln => /^\d+\.\s/.test(ln)) : []; } } else { if (!s.isGenerating) { s.storyArc = []; } } },
        handleInput: function(rawPlayerInput) { let txt = rawPlayerInput; let cmdH = false; if (!state.sae) return { text: txt, commandHandled: false }; let cmd = (rawPlayerInput || "").trim().toLowerCase(); if (!state.sae.isEnabled && (cmd.startsWith("/regeneratearc") || cmd.startsWith("/setarctype") || cmd.startsWith("/currentarcsettings"))) { txt = formatSystemMessage("‚öôÔ∏è SAE is off. Check settings card to enable."); cmdH = true; return { text: txt, commandHandled: cmdH }; } if (cmd.startsWith("/setarctype")) { const argString = rawPlayerInput.substring("/setarctype".length).trim(); const parts = argString.split('/'); if (parts.length === 2) { let rawNewTone = parts[0].trim(); let rawNewIntensity = parts[1].trim(); const newTone = rawNewTone.replace(/[.!?]+$/, "").trim().toLowerCase(); const newIntensity = rawNewIntensity.replace(/[.!?]+$/, "").trim().toLowerCase(); let toneValid = this.tonePrompts.hasOwnProperty(newTone); let intensityValid = this.intensityPrompts.hasOwnProperty(newIntensity); if (toneValid && intensityValid) { state.sae.arcTone = newTone; state.sae.arcIntensity = newIntensity; state.sae.toneChosen = true; state.sae.intensityChosen = true; state.sae.isGenerating = true; state.sae.saveOutput = true; state.sae.attemptCounter = 0; state.sae.completionSuggested = false; state.sae.trigger_initial_arc_on_load = false; txt = formatSystemMessage(`üé≠ Arc Tone set to: '${newTone}'.\nüî• Arc Intensity set to: '${newIntensity}'.\nüß† Brainstorming new story arc...`); } else { let errorMsg = "ü§î Invalid input for /setarctype.\n"; if (!toneValid) errorMsg += `- Unknown tone: '${newTone}' (from input '${rawNewTone}'). Valid: ${Object.keys(this.tonePrompts).join(', ')}\n`; if (!intensityValid) errorMsg += `- Unknown intensity: '${newIntensity}' (from input '${rawNewIntensity}'). Valid: ${Object.keys(this.intensityPrompts).join(', ')}\n`; txt = formatSystemMessage(errorMsg.trim() + "\nUsage: /setarctype [tone] / [intensity]"); } } else { txt = formatSystemMessage("ü§î Usage: /setarctype [tone] / [intensity]\nExample: /setarctype adventure / moderate"); } cmdH = true; } else if (cmd.startsWith("/currentarcsettings")) { const currentToneDisplay = state.sae.arcTone ? `'${state.sae.arcTone}'` : "Not Set (Use /setarctype)"; const currentIntensityDisplay = state.sae.arcIntensity ? `'${state.sae.arcIntensity}'` : "Not Set (Use /setarctype)"; txt = formatSystemMessage(`Current Settings:\nüé≠ Tone: ${currentToneDisplay}\nüî• Intensity: ${currentIntensityDisplay}`); cmdH = true; } else if (cmd.startsWith("/regeneratearc")) { const choicesMade = state.sae.toneChosen && state.sae.intensityChosen; const toneIsValid = choicesMade && state.sae.arcTone && this.tonePrompts.hasOwnProperty(state.sae.arcTone); const intensityIsValid = choicesMade && state.sae.arcIntensity && this.intensityPrompts.hasOwnProperty(state.sae.arcIntensity); if (toneIsValid && intensityIsValid) { state.sae.isGenerating = true; state.sae.saveOutput = true; state.sae.completionSuggested = false; state.sae.attemptCounter = 0; state.sae.trigger_initial_arc_on_load = false; txt = formatSystemMessage(`üß† Brainstorming new arc (Tone: ${state.sae.arcTone}, Intensity: ${state.sae.arcIntensity})...`); } else { txt = formatSystemMessage(`ü§î Set arc type first using: /setarctype [tone] / [intensity]`); } cmdH = true; } else if (cmd.startsWith("/saestop")) { state.sae.isGenerating = false; state.sae.saveOutput = false; state.sae.attemptCounter = 0; state.sae.trigger_initial_arc_on_load = false; txt = formatSystemMessage("üõë Arc generation cancelled!"); cmdH = true; } return { text: txt, commandHandled: cmdH }; },
        handleContext: function(text) { if (!state.sae || !state.sae.isEnabled || typeof text !== 'string') return text; if (state.sae.isGenerating && state.sae.saveOutput) { let basePrompt = state.sae.arcPrompt || this.defaults.arcPrompt; let toneModifier = ""; let intensityModifier = ""; const currentTone = state.sae.arcTone; const currentIntensity = state.sae.arcIntensity; if (currentTone && currentTone !== "custom" && this.tonePrompts.hasOwnProperty(currentTone)) { toneModifier = this.tonePrompts[currentTone]; } if (currentIntensity && this.intensityPrompts.hasOwnProperty(currentIntensity)) { intensityModifier = this.intensityPrompts[currentIntensity]; } let finalPrompt = basePrompt + toneModifier + intensityModifier; return text + finalPrompt; } if (state.sae.storyArc?.length > 0 && state.sae.activePointIndex < state.sae.storyArc.length && !(state.sae.isGenerating && state.sae.saveOutput)) { const currentToneDisplay = state.sae.arcTone || "N/A"; const currentIntensityDisplay = state.sae.arcIntensity || "N/A"; const currentPointText = state.sae.storyArc[state.sae.activePointIndex].replace(/^\d+\.\s*/, ''); const guidancePrompt = `\n[Plot Hint (T:${currentToneDisplay},I:${currentIntensityDisplay}): Towards "${currentPointText}".]\n`; const authorsNoteMatch = text.match(/(\[Author's note:[\s\S]*?)(\])/i); if (authorsNoteMatch) { return text.replace(authorsNoteMatch[0], `${authorsNoteMatch[1]}${guidancePrompt.trim()} ${authorsNoteMatch[2]}`); } return text + `\n[Author's note:${guidancePrompt.trim()}]`; } return text; },
        shouldTriggerGeneration: function() { const currentTurn = (typeof info !== 'undefined' && Number.isFinite(info.actionCount)) ? info.actionCount : 0; if (!state.sae || state.sae.isGenerating || !state.sae.isEnabled) return false; const choicesMade = state.sae.toneChosen && state.sae.intensityChosen; const toneActuallyValid = choicesMade && state.sae.arcTone && this.tonePrompts.hasOwnProperty(state.sae.arcTone); const intensityActuallyValid = choicesMade && state.sae.arcIntensity && this.intensityPrompts.hasOwnProperty(state.sae.arcIntensity); const typeSettingsAreValidAndChosen = toneActuallyValid && intensityActuallyValid; if (state.sae.trigger_initial_arc_on_load) { if (!typeSettingsAreValidAndChosen) return "choose_type"; return "generate_now"; } if (currentTurn < 2) return false; if (state.sae.hasRunEarly !== true && currentTurn >= 2 && currentTurn <= 7) { if (!typeSettingsAreValidAndChosen) return "choose_type"; return "generate_now"; } if (state.sae.turnsPerAICall > 0 && (currentTurn > 1) && (currentTurn % state.sae.turnsPerAICall === 0)) { if (!typeSettingsAreValidAndChosen) return "choose_type"; return "generate_now"; } return false; },
        handleOutput: function(text) { if (!state.sae || !state.sae.isEnabled || !state.sae.saveOutput) return text; if (!text || typeof text !== 'string' || text.trim() === '') { state.sae.attemptCounter++; if (state.sae.attemptCounter >= 3) { state.sae.isGenerating = false; state.sae.saveOutput = false; state.sae.attemptCounter = 0; state.sae.trigger_initial_arc_on_load = false; return formatSystemMessage(`üò• AI shy! No arc ideas after 3 tries.`); } else { return formatSystemMessage(`üòÆ Empty AI response. Retrying arc (${state.sae.attemptCounter + 1}/3)...`); } } const pts = text.split('\n').map(l => l.trim()).filter(ln => /^\d+\.\s/.test(ln)); if (pts.length < 8) { state.sae.attemptCounter++; if (state.sae.attemptCounter >= 3) { state.sae.isGenerating = false; state.sae.saveOutput = false; state.sae.attemptCounter = 0; state.sae.trigger_initial_arc_on_load = false; return formatSystemMessage(`üò• Invalid arc (less than 8 points after 3 tries).`); } else { return formatSystemMessage(`ü§î Not a full arc (got ${pts.length} points). Retrying (${state.sae.attemptCounter + 1}/3)...`); } } else { state.sae.isGenerating = false; state.sae.saveOutput = false; state.sae.attemptCounter = 0; state.sae.activePointIndex = 0; state.sae.completionSuggested = false; state.sae.storyArc = pts; state.sae.trigger_initial_arc_on_load = false; if (state.sae.hasRunEarly !== true) { state.sae.hasRunEarly = true; } if (this.acAPI) { const arcContentCard = this.acAPI.getCard(c => c && c.title === "Current Story Arc"); if (arcContentCard) { const oldEntry = arcContentCard.entry || "No previous arc."; const turn = (typeof info !== 'undefined' && Number.isFinite(info.actionCount)) ? info.actionCount : 'N/A'; arcContentCard.description = `Log(Turn ${turn})|Previous Arc:\n${oldEntry}\n\n` + (arcContentCard.description || "").substring(0, 1000); arcContentCard.entry = pts.join('\n'); } } return formatSystemMessage(`üéâ New arc (Tone: ${state.sae.arcTone}, Intensity: ${state.sae.arcIntensity}) saved to card!`); } },
        checkForCompletion: function(currentAiOutputText) { if (!state.sae || !state.sae.isEnabled || !state.sae.storyArc?.length || state.sae.completionSuggested || state.sae.activePointIndex >= state.sae.storyArc.length) return; const activePointText = (state.sae.storyArc[state.sae.activePointIndex] || "").replace(/^\d+\.\s*/, '').trim(); if (!activePointText) return; if (currentAiOutputText && typeof currentAiOutputText === 'string' && currentAiOutputText.trim()) { if (textSimilarityScore(activePointText, currentAiOutputText) > 0.45) { if (!state.toastQueue) state.toastQueue = []; state.toastQueue.push(`[SAEüí°: Point "${activePointText}" seems complete.]`); state.sae.completionSuggested = true; } } }
    };
    
// ==================================================================
// MASTER HOOK FUNCTIONS
// ==================================================================

function initializeCombinedModules() {
    if (sharedAcAPI === null && typeof AutoCards === 'function') {
        try {
            const acI = AutoCards();
            if (acI && typeof acI.API === 'object') { sharedAcAPI = acI.API; } 
            else { console.warn(`AutoCards() did not return expected API object.`); sharedAcAPI = null; }
        } catch (e) { console.error(`Error getting AutoCards API.`, e); sharedAcAPI = null; }
    }
    Formatter.initialize(sharedAcAPI);
    STT.initialize(sharedAcAPI); 
    SAE.initialize(sharedAcAPI);   

    if (state.toastQueue === undefined) state.toastQueue = [];
    if (state.currentActionTypeForTimeAdvance === undefined) {
        const currentTurn = (typeof info !== 'undefined' && Number.isFinite(info.actionCount)) ? info.actionCount : 0;
        state.currentActionTypeForTimeAdvance = (currentTurn === 0 && (typeof info !== 'undefined' && info.actionType === 'start')) ? 'start' : 'continue';
    }
}

globalThis.onInput_Combined = function(text) {
    initializeCombinedModules(); 
    
    let postInitMessages = [];
    if (state.stt && state.stt.postReinitMessage) {
        postInitMessages.push(state.stt.postReinitMessage);
        state.stt.postReinitMessage = null; 
    }
    if (state.sae && state.sae.postReinitMessage) {
        postInitMessages.push(state.sae.postReinitMessage);
        state.sae.postReinitMessage = null; 
    }
    if (postInitMessages.length > 0) {
        const messageStr = postInitMessages.join('\n');
        if (state.message && typeof state.message === 'string') {
            state.message += '\n' + messageStr;
        } else {
            state.message = messageStr;
        }
    }
    
    Formatter.updateAndCreateCards();
    STT.checkAndCreateCards(); STT.updateSettingsFromCard();
    SAE.updateAndCreateCards();

    let currentText = text;
    let finalStopSignal = false;
    const originalTextForAC = text; 
    let rawInputForActionTypeCheck = (text || "").trim(); 

    let identifiedPlayerActionForSTT = null;
    let isSystemMessageToIgnore = false;

    const systemMessagePatterns = [ /\[SYSTEM-MSG-START\]\s*üé≠\s*Arc Tone set to:/i, /üß†\s*Brainstorming new story arc/i, />>>\s*please select "continue"/i ];
    for (const pattern of systemMessagePatterns) { if (pattern.test(rawInputForActionTypeCheck)) { isSystemMessageToIgnore = true; break; } }

    if (!isSystemMessageToIgnore) {
        if (rawInputForActionTypeCheck.startsWith("> You say") || rawInputForActionTypeCheck.match(/^\s*say\s*["‚Äú]/i)) { identifiedPlayerActionForSTT = "say";
        } else if (rawInputForActionTypeCheck.startsWith("> You do") || rawInputForActionTypeCheck.match(/^\s*do\s*["‚Äú]/i) || rawInputForActionTypeCheck.match(/^\s*>\s*you\s+[^s][^a][^y]/i) ) { identifiedPlayerActionForSTT = "do";
        } else if (rawInputForActionTypeCheck.startsWith("> You add to the story") || rawInputForActionTypeCheck.startsWith("> Story:")) { identifiedPlayerActionForSTT = "story";
        } else if (!rawInputForActionTypeCheck.startsWith("/")) { if (rawInputForActionTypeCheck && !identifiedPlayerActionForSTT && rawInputForActionTypeCheck.length > 0) { identifiedPlayerActionForSTT = "story"; } }
    }

    let commandInput = (text || "").trim();
    let commandCandidateAfterPrefixStrip = commandInput;
    const playerActionPrefixes = [ /^\s*>\s*you\s+verb\s+/i, /^\s*>\s*you\s*say\s*:\s*/i, /^\s*>\s*you\s*/i, /^\s*>\s*/i ];
    for (const prefixRegex of playerActionPrefixes) { if (prefixRegex.test(commandCandidateAfterPrefixStrip)) { commandCandidateAfterPrefixStrip = commandCandidateAfterPrefixStrip.replace(prefixRegex, "").trim(); break; } }
    let potentialDirectCommand = commandCandidateAfterPrefixStrip;
    const sayWrappedCommandRegex = /^\s*say\s+["'](.+?)["']\s*$/i; const justQuotedCommandRegex = /^\s*["'](.+?)["']\s*$/i;
    let sayMatch = potentialDirectCommand.match(sayWrappedCommandRegex);
    if (sayMatch && sayMatch[1] && sayMatch[1].trim().startsWith('/')) { potentialDirectCommand = sayMatch[1].trim();
    } else { let quoteMatch = potentialDirectCommand.match(justQuotedCommandRegex); if (quoteMatch && quoteMatch[1] && quoteMatch[1].trim().startsWith('/')) { potentialDirectCommand = quoteMatch[1].trim(); } }
    const cleanedCommandForMatching = potentialDirectCommand.toLowerCase();

    let modRes = null; 
    let commandWasHandledByModule = false;

    if (cleanedCommandForMatching.startsWith('/')) {
        if (cleanedCommandForMatching.startsWith('/ac') || cleanedCommandForMatching.startsWith('/acredo')) { 
            if (typeof AutoCards === 'function') { 
                let acResult = AutoCards("input", originalTextForAC, false);
                currentText = (typeof acResult === 'object' && acResult.text !== undefined) ? acResult.text : (Array.isArray(acResult) ? acResult[0] : originalTextForAC);
                finalStopSignal = (typeof acResult === 'object' && acResult.stop !== undefined) ? acResult.stop : (Array.isArray(acResult) ? acResult[1] : false);
            }
            commandWasHandledByModule = true; // Mark /ac as handled by a module
            state.currentActionTypeForTimeAdvance = 'system_command'; 
            return { text: currentText, stop: finalStopSignal }; 
        }
        else if (cleanedCommandForMatching === '/reinit_plugins') {
            state.formatter = null; state.stt = null; state.sae = null;
            initializeCombinedModules(); 
            currentText = formatSystemMessage("üîå All core plugins re-initialized to their default states.");
            
            postInitMessages = []; // Re-collect messages after re-init
            if (state.stt && state.stt.postReinitMessage) { postInitMessages.push(state.stt.postReinitMessage); state.stt.postReinitMessage = null; }
            if (state.sae && state.sae.postReinitMessage) { postInitMessages.push(state.sae.postReinitMessage); state.sae.postReinitMessage = null; }
            if (postInitMessages.length > 0) { currentText += "\n" + postInitMessages.join("\n"); }

            commandWasHandledByModule = true;
            finalStopSignal = true;
            // No early return here, let the normal flow set currentActionTypeForTimeAdvance
        }
        else if (STT.handleInput && (cleanedCommandForMatching.startsWith('/settime') || cleanedCommandForMatching.startsWith('/setdate') || cleanedCommandForMatching.startsWith('/defer') || cleanedCommandForMatching.startsWith('/wait'))) {
            modRes = STT.handleInput(potentialDirectCommand);
            if (modRes && modRes.commandHandled) { commandWasHandledByModule = true; }
        }
        else if (SAE.handleInput && (cleanedCommandForMatching.startsWith('/setarctype') || cleanedCommandForMatching.startsWith('/currentarcsettings') || cleanedCommandForMatching.startsWith('/regeneratearc') || cleanedCommandForMatching.startsWith('/saestop'))) {
            modRes = SAE.handleInput(potentialDirectCommand);
            if (modRes && modRes.commandHandled) { commandWasHandledByModule = true; }
        }
        
        if (commandWasHandledByModule && modRes) { 
            if (cleanedCommandForMatching.startsWith('/defer')) {
                 let playerNarrative = "";
                if (commandCandidateAfterPrefixStrip.toLowerCase().includes(cleanedCommandForMatching)) {
                    let tempNarrative = commandCandidateAfterPrefixStrip; const escapedCmd = potentialDirectCommand.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'); const cmdRegex = new RegExp(escapedCmd, "i"); tempNarrative = tempNarrative.replace(cmdRegex, "").trim(); if (tempNarrative) { playerNarrative = tempNarrative; }
                }
                if (playerNarrative) { currentText = `${playerNarrative}\n\n${modRes.text.trim()}\n\n[The story continues after this time skip.]`;
                } else { currentText = `${modRes.text.trim()}\n\n[The story jumps forward. Describe what happens or the scene after this passage of time.]`; }
            } else { currentText = modRes.text; }
            
            if (cleanedCommandForMatching.startsWith('/currentarcsettings') || cleanedCommandForMatching.startsWith('/saestop') || cleanedCommandForMatching === '/reinit_plugins' ) { finalStopSignal = true;
            } else { finalStopSignal = false; } 
        }
    }

    if (isSystemMessageToIgnore) { state.currentActionTypeForTimeAdvance = 'system_message_ignored';
    } else if (commandWasHandledByModule) { state.currentActionTypeForTimeAdvance = 'system_command';
    } else if (identifiedPlayerActionForSTT) { state.currentActionTypeForTimeAdvance = identifiedPlayerActionForSTT;
    } else {
        const currentTurn = (typeof info !== 'undefined' && Number.isFinite(info.actionCount)) ? info.actionCount : -1;
        if (currentTurn === 0 && (typeof info !== 'undefined' && info.actionType === 'start')) { state.currentActionTypeForTimeAdvance = 'start';
        } else if (rawInputForActionTypeCheck === "" && currentTurn > 0) { state.currentActionTypeForTimeAdvance = 'continue';
        } else { state.currentActionTypeForTimeAdvance = 'continue';  }
    }
    
    if (typeof AutoCards === 'function' && !commandWasHandledByModule) { 
        let acResult = AutoCards("input", originalTextForAC, finalStopSignal); 
        if (!isSystemMessageToIgnore) { 
            currentText = (typeof acResult === 'object' && acResult.text !== undefined) ? acResult.text : (Array.isArray(acResult) ? acResult[0] : currentText);
        }
        finalStopSignal = (typeof acResult === 'object' && acResult.stop !== undefined) ? acResult.stop : (Array.isArray(acResult) ? acResult[1] : finalStopSignal);
    }
    
    return { text: currentText, stop: finalStopSignal };
};

globalThis.onContext_Combined = function(text, stop) {
    initializeCombinedModules();
    let currentText = text;
    let currentStop = stop;

    const sysRgx = /\n*\s*\[SYSTEM-MSG-START\]\n?([\s\S]*?)\n?\[SYSTEM-MSG-END\]\s*\n*/g;
    currentText = (currentText || "").replace(sysRgx, (m, c) => `\n\n${c.trim()}\n\n`).replace(/\n{3,}/g, '\n\n').trim();

    if (STT.handleContext) currentText = STT.handleContext(currentText);
    if (SAE.handleContext) currentText = SAE.handleContext(currentText);

    if (typeof AutoCards === 'function') { 
        let acResult = AutoCards("context", currentText, currentStop); 
        if (Array.isArray(acResult) && acResult.length >= 2) { currentText = acResult[0]; currentStop = acResult[1];
        } else if (typeof acResult === 'object' && acResult !== null && acResult.text !== undefined && acResult.stop !== undefined) { currentText = acResult.text; currentStop = acResult.stop;
        }
        const isACG = (state.AutoCards?.generation?.workpiece && Object.keys(state.AutoCards.generation.workpiece).length > 0);
        const isSAEG = (state.sae?.isGenerating && state.sae.saveOutput);
        if (isACG || isSAEG) { currentStop = false; }
    }
    return { text: currentText, stop: currentStop };
};

globalThis.onOutput_Combined = function(text) {
    initializeCombinedModules(); 
    if(STT.advanceTimeBasedOnAction) STT.advanceTimeBasedOnAction();

    let aiNarrativeOutput = text; let systemMessages = []; let saeSystemMessageGeneratedThisHook = null;
    const isInputFromOurSystem = /\[SYSTEM-MSG-START\][\s\S]*?\[SYSTEM-MSG-END\]/.test((text||"").trim());
    const isACGActive = (state.AutoCards?.generation?.workpiece && Object.keys(state.AutoCards.generation.workpiece).length > 0);
    const isSAEExpectingAIOutputAsArc = (state.sae?.isEnabled && state.sae.saveOutput);
    const currentTurnForOutputLog = typeof info !== 'undefined' && info.actionCount !== undefined ? info.actionCount : 'N/A';

    if (isInputFromOurSystem && !isACGActive && !isSAEExpectingAIOutputAsArc) {
        if (typeof text === 'string' && text.trim()) systemMessages.push(text); aiNarrativeOutput = "";
    }
    else if (isACGActive) {
        if (typeof AutoCards === 'function') { 
            let acOutput = AutoCards("output", aiNarrativeOutput);
            if (typeof acOutput === 'string' && acOutput.trim()) {
                if (/\[SYSTEM-MSG-START\]|>>>|<<<|{>/.test(acOutput.trim())) { systemMessages.push(acOutput); aiNarrativeOutput = ""; }
                else { aiNarrativeOutput = acOutput; }
            } else { aiNarrativeOutput = ""; }
        }
    }
    else if (isSAEExpectingAIOutputAsArc) {
        if (SAE.handleOutput) { saeSystemMessageGeneratedThisHook = SAE.handleOutput(aiNarrativeOutput); if(saeSystemMessageGeneratedThisHook && typeof saeSystemMessageGeneratedThisHook === 'string') systemMessages.push(saeSystemMessageGeneratedThisHook); }
        aiNarrativeOutput = ""; 
    }
    else { 
        if (typeof AutoCards === 'function') { aiNarrativeOutput = AutoCards("output", aiNarrativeOutput); }
        if (SAE.shouldTriggerGeneration) { 
            const triggerResult = SAE.shouldTriggerGeneration();
            if (triggerResult === "choose_type") {
                saeSystemMessageGeneratedThisHook = formatSystemMessage( `‚ú® Set Story Arc Type! ‚ú® (Turn ${currentTurnForOutputLog})\n` + `Type: /setarctype [tone] / [intensity]\n\n` + `Tone Options: ${Object.keys(SAE.tonePrompts || {}).join(', ')}\n` + `(Current: '${state.sae?.arcTone || "null"}')\n\n` + `Intensity Options: ${Object.keys(SAE.intensityPrompts || {}).join(', ')}\n` + `(Current: '${state.sae?.arcIntensity || "null"}')\n\n` + `Example: /setarctype adventure / moderate` );
                aiNarrativeOutput = ""; 
            } else if (triggerResult === "generate_now") {
                if (state.sae) {
                    state.sae.isGenerating = true; state.sae.saveOutput = true; state.sae.attemptCounter = 0; state.sae.completionSuggested = false;
                    state.sae.trigger_initial_arc_on_load = false; 
                    saeSystemMessageGeneratedThisHook = formatSystemMessage(`üìù SAE preparing new plot (Tone: ${state.sae.arcTone}, Intensity: ${state.sae.arcIntensity}) for next turn! (Turn ${currentTurnForOutputLog})`);
                }
            }
        }
        if (saeSystemMessageGeneratedThisHook && typeof saeSystemMessageGeneratedThisHook === 'string') { systemMessages.push(saeSystemMessageGeneratedThisHook); }
        if (typeof aiNarrativeOutput === 'string' && aiNarrativeOutput.trim()) {
            const isNowSysMsg = /\[SYSTEM-MSG-START\]|\[SYSTEM:.*\]|>>>|<<<|{>|AFK/.test(aiNarrativeOutput.trim());
            if (enableFormatter && Formatter.format && !isNowSysMsg) { const ctx = (typeof history !== 'undefined' && Array.isArray(history)) ? history.map(h => h.text || "").join('\n') : ''; aiNarrativeOutput = Formatter.format(aiNarrativeOutput, ctx); }
        }
    }

    let outputParts = [];
    if (typeof aiNarrativeOutput === 'string' && aiNarrativeOutput.trim()) { outputParts.push(aiNarrativeOutput); }
    outputParts.push(...systemMessages.filter(p => typeof p === 'string' && p.trim()));
    let combinedOutput = outputParts.map(p => { const sr = /\n*\s*\[SYSTEM-MSG-START\]\n?([\s\S]*?)\n?\[SYSTEM-MSG-END\]\s*\n*/g; return p.replace(sr, (m, c) => c.trim()); }).filter(p => p && p.trim() !== "").join("\n\n");
    combinedOutput = combinedOutput.replace(/\n{3,}/g, '\n\n').trim();

    if (STT.appendTimestampsToText) { combinedOutput = STT.appendTimestampsToText(combinedOutput); }
    if (SAE.checkForCompletion && typeof aiNarrativeOutput === 'string' && aiNarrativeOutput.trim()) { SAE.checkForCompletion(aiNarrativeOutput); }

    if (combinedOutput && combinedOutput.trim() !== "") {
        const isAnySystemOutput = /\[SYSTEM:.*\]|>>>|<<<|{>|AFK|Auto-Cards:|SAE\üí°|Time advanced|Time set|Date set|Current Settings:|Set Story Arc Type!|SAE preparing new plot|AI shy!|Empty AI response|Invalid arc|Not a full arc|New arc saved|üõë Arc generation cancelled!|‚öôÔ∏è SAE is off/.test(combinedOutput.trim());
        if (!isAnySystemOutput) { if (!combinedOutput.endsWith("\n\n")) { combinedOutput += combinedOutput.endsWith("\n") ? "\n" : "\n\n"; }
        } else { if (!combinedOutput.endsWith("\n")) { combinedOutput += "\n"; } }
    }
    if(state.toastQueue?.length>0){ const tM=state.toastQueue.join('\n'); if(state.message&&typeof state.message==='string'&&!state.message.includes(tM.split('\n')[0])){ state.message+='\n'+tM; } else if(!state.message){ state.message=tM; } state.toastQueue=[]; }
    return{text:combinedOutput};
};

})(); // End of IIFE wrapper

// TAS Library Script

// TRUE AUTOMATIC STATS (TAS) SCRIPT by Yi1i1i

// Credits
  // BinKompliziert - Idea for Capitalization weighting for skill learning
  // jackoneill2443 - Idea for modifying player input to show stat results
  // LewdLeah - General Scripting Knowledge
//

// This function runs the library hook
onLibrary_TAS();

// LIBRARY HOOK
function onLibrary_TAS() {
  // UNLOCK SCRIPT FOR DEBUG (Comment out to turn off)
  state.startScript = true;

  //Initialize the script lock only if undefined so its not set false each turn even if unlocked
  if (state.startScript == undefined) {
    // Script is naturally locked
    state.startScript = false;
  }
  if (state.msgHolder == undefined){
    state.msgHolder = "";
  }
  log("state.startScript: " + state.startScript);
  
}

// INPUT HOOK
function onInput_TAS(text) {
  //Check for unlocking
  text = unlockScript(text);

  //Check for locking
  text = lockScript(text);

  helpCommandInput(text);

  //Unlocking runs main()
  if (state.startScript == true && info.actionCount >= 0) {
    state.inputCount += 1;
    log("state.inputCount: " + state.inputCount);

    //Create story cards if none
    createIfNoStatSC();
    createIfNoInvSC();
    createIfNoTalentSC();
    createIfNoSkillSC();
    createIfNoModifierSC();
    createIfNoCurrSC();

    //Updates codebase if player edits their storage SCs
    retrieveStatsFromSC();
    retrieveTalentsFromSC();
    retrieveSkillsFromSC();
    retrieveInvFromSC();
    retrieveModifiersFromSC()


    text = detectStoreInv(text);

    text = detectAttack(text);

    text = detectPlrActionsCallingStorage(text);

    text = detectDodge(text);

    text = detectScout(text);

    text = detectResting(text);

    text = detectConsuming(text);

    text = upgradePlayerSkills(text);

    text = talentLearningProcess(text);

    text = warnPlayerHealth(text);

  }//end of main()

  return text;
}

// CONTEXT HOOK
function onContext_TAS(text){
  
  
  return text;
}

// OUTPUT HOOK
function onOutput_TAS(text) {
  text = helpCommandOutput(text);

  //start of main()
  if (state.startScript == true && info.actionCount >= 0) {
    state.outputCount += 1;
    log("state.outputCount: " + state.outputCount);

    //Create story cards if none
    createIfNoStatSC();
    createIfNoInvSC();
    createIfNoTalentSC();
    createIfNoSkillSC();
    createIfNoModifierSC();
    createIfNoCurrSC();


    //End of skill learning process. Do not disturb talent storage beforehand.
    text = getEnergyCost(text);

    //Updates player stats in code if player edits their stats in SC
    retrieveStatsFromSC();
    //Stat edits made by the code
    playerNaturalRegen();
    text = detectHurt(text);
    //Final stats store back to SC in correct formatting
    storeStatsToSC();

    //Updates player talents in code if player edits their talents in SC
    retrieveTalentsFromSC();
    //Final stats store back to SC in correct formatting
    storeTalentsToSC();

    //Updates player skills in code if player edits their skills in SC
    retrieveSkillsFromSC();
    //Final skill store back to SC in correct formatting
    storeSkillsToSC();

    //Updates player inv in code if player edits their inv in SC
    retrieveInvFromSC();
    //Final skill store back to SC in correct formatting
    storeInvToSC();

    //Updates player mods in code if player edits their mods in SC
    retrieveModifiersFromSC()
    //Final mods store back to SC in correct formatting
    storeModifiersToSC();

    // Message Handler
    state.message = state.msgHolder;
    state.msgHolder = "";

    turnCounter();
  }//end of main

  return text;
}
//Input /start unlocks the script else script naturally locked
function unlockScript(key){ 
  if (state.startScript == false) {
    if (key.includes("/start")) {
      state.startScript = true;
      text = text + "\n üîì TAS Script Unlocked!";
    }
  }
  return text;
}

//Detect input command /end to lock script
function lockScript(key){ 
  if (state.startScript == true) {
    if (key.includes("/end")) {
      state.startScript = false;
      text = text + "\n üîí TAS Script Locked!"
    }
  }
  return text;
}

//detect /help and display help
function helpCommandInput(text){
  if(text.includes("/help stats")){
    state.commandCenter = 
    `üìä Player Stats Guide

    - üì• Type "Player Stats" in the Story Cards to view your current stats.
    - üîÑ Stats auto-update based on natural player input and context.
    - ‚úèÔ∏è To manually adjust a stat, use the format: STAT: x/maxX.
    - üóíÔ∏è Stat change logs appear in the notes of the Player Stats Story Card.

    üß† Gameplay Mechanics

    - ‚ù§Ô∏è Health and üîµ Mana regenerate every turn.
    - ‚ö° Energy decreases every turn.
    - ‚ö†Ô∏è Low Health or Energy leads to consequences.
    - üìà Stats used in actions gain exp. Experience scales exponentially lower as your stats increase.
    - üéì When a stat is maxed, overflow EXP goes to your main EXP pool.
    - üÜô Leveling up increases all max stats.

    üìê Scaling & Calculations

    - üß† Mana scales with INTL.
    - üõ°Ô∏è X DEF = X/2 % damage reduction.
    - ‚ûï DEF above 100 reduces damage by an extra 0.01% per 10 points.
    - üçÄ Each point in LCK gives a 1% chance of a lucky boost.`
  }
  else if(text.includes("/help talents")){
    state.commandCenter = 
    `üéØ Talent System Guide

    - üß† Talents represent your character's aptitudes (e.g., Cooking, Lockpicking, Fishing).
    - ‚ö° Talents consume energy points (EP) when used.
    - ‚ú® Casting a talent transforms it into a skill, which uses mana (MP) instead.
    - üìù Edit talents in the Story Card using the format: "Talent Name (Lvl) (Ep)".
    - üìö Learn a talent by studying it and using its name repeatedly over a few turns.
    - üî§ Capitalized first-letter talent names are learned faster.
    - üß™ The system filters common words intelligently when detecting talent names.
    - üéì Learning talents grants INTL experience.
    - üìñ Talent learning progress is logged in the Player Talents Story Card notes.
    - üìà Using talents levels them up. Progress is also tracked in the Story Card.`
  }
  else if(text.includes("/help skills")){
    state.commandCenter = 
    `üéØ Skills System Guide

    - ü™Ñ Skills require mana points (MP) to use. Example: Fireball.
    - üîÑ Casting a talent transforms it into a skill.
    - üìù Edit skills in the Story Card using the format: "Skill Name (Lvl) (Mp)".
    - üìà Use skills to gain EXP ‚Äî progress is logged in the Story Card.
    - üß™ Skills upgrade every 5 levels (up to level 25), changing their name and reducing MP cost by 5%.
    - üí• Skill power increases every 10 levels.`
  }
  else if (text.includes("/help inventory")) {
  state.commandCenter = 
  `üì¶ Inventory Help

  - Store items by typing: "You [store words]... [item name]... [inventory words]."
  - Include a number to specify quantity. Ex: "You put 2 apples in your bag."
  - Edit your inventory in the story card using the format: "Item Name (Amt)".`
  }
  else if (text.includes("/help actions")) {
    state.commandCenter = 
    `üé¨ Action System Help

    - Item, talent, and skill usage requires name matching (exact or partial).
    - Vague actions are taken literally. Example: "You slice it" (slice with what?).
    - Cast skills: "You [cast verb] [skill name]."
    - Rest to recover HP, MP, and energy:
      ‚Ä¢ Light rest, moderate rest, full rest yield different recovery levels.
      ‚Ä¢ Format: "You [enter words] [sleep words]."
    - Use consumables for healing/energy. Example: "You drink a Mythical potion."
    - Use skills/talents on yourself to heal. Format: "You [heal word] [yourself] [skill/talent]."
    - ATK & SPD:
      ‚Ä¢ +10 ATK & SPD ‚Üí stronger attacks
      ‚Ä¢ +10 SPD ‚Üí faster actions, better dodging
      ‚Ä¢ Attacking and dodging costs energy based on your ATK and SPD
    - INTL:
      ‚Ä¢ +10 INTL ‚Üí greater detail when scouting.
      ‚Ä¢ Scouting Format: "You [scout words]."`
  }
  else if (text.includes("/help")) {
    state.commandCenter = 
    `üõ†Ô∏è Script Commands

    - Be sure to delete helper texts to avoid polluting the AI context.
    - /start ‚Äî Starts the script
    - /end ‚Äî Stops the script
    - /help stats ‚Äî Stat mechanics and usage
    - /help talents ‚Äî Talent mechanics and learning
    - /help skills ‚Äî Skill casting and upgrades
    - /help inventory ‚Äî Storing and managing items
    - /help actions ‚Äî Combat, healing, resting, and usage behaviors`
  }
}

function helpCommandOutput(text){
  if(state.commandCenter){
    text = state.commandCenter;
  }
  delete state.commandCenter
  return text;
}

/////////////////////////////////////////////////////////////////////////////////////

youWords = ["you", "You", "I"];

selfWords = ["me", "my", "myself", "mine", "your", "yourself", "yours", "us", "our", "ours", "ourselves"
];

castWords = [
  "bind", "cast", "casting", "channel", "channeling", "command", "conjure", 
  "enchant", "enchanting", "evoke", "expel", "exude", "flare", "glow", "harness", "hex", "infuse", "invoke", "invoking", "manifest", "project", "projecting", "pulse", "quicken", "release", "shape", "summon", "summoning", "transmute", "unbind", "unleash"
];

talentWords = ["build", "barter", "cook", "craft", "fish", "forge", "operate", "repair", "scavenge", "sneak", "convince", "manipulate" , "shoot" , "steal" , "perform"];

learnWords = [
  "learn", "learning", "practice", "practicing", "spend time", "study", "studying", "train", "training", "read", "reading", "focus", "find", "research", "researching"
];

equipWords = [
  "acquire", "add", "collect", "equip", "gather", "grab", "hold", "keep", "loot", "obtain", "pick", "put", "receive", "retrieve", "stash", "store", "take", "wear"
];

invWords = [
  "bag", "backpack", "body", "case", "chest", "collection",  "container", "crates", "equipment", "hands", "hand", "holder", "holdings", "inventory", "items", "legs", "loot", "pack", "pocket", "pouch", "sack", "satchel", "storage", "supplies", "tote", "wallet"
];

numWords = [
  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
  "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine",
  "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen",
  "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety",
  "hundred", "thousand", "million", "billion", "trillion"
];

titleWords = ["mr", "mrs", "ms", "dr", "prof", "captain", "sir", "lady", "officer", "detective", "colonel", "general", "lieutenant", "president", "governor", "mayor", "minister","ambassador", "director", "agent", "coach", "principal", "judge", "dean", "sister","brother", "father", "mother", "daughter", "son", "king", "queen", "prince", "princess","professor", "lord", "emperor", "empress"];

stopWords = [
  // Pronouns
  "I", "me", "my", "myself", "we", "our", "ours", "ourselves",
  "you", "your", "yours", "yourself", "yourselves",
  "he", "him", "his", "himself", "she", "her", "hers", "herself",
  "it", "its", "itself", "they", "them", "their", "theirs", "themselves",

  // Question Words
  "what", "which", "who", "whom", "whose", "when", "where", "why", "how",

  // Auxiliary & Modal Verbs
  "am", "is", "are", "was", "were", "be", "been", "being",
  "have", "has", "had", "having",
  "do", "does", "did", "doing",
  "can", "could", "will", "would", "shall", "should", "must", "might", "may",

  // Negatives
  "not", "no", "nor", "never", "none", "nothing", "nowhere", "neither",
  "isn't", "aren't", "wasn't", "weren't", "hasn't", "haven't", "hadn't",
  "doesn't", "don't", "didn't", "won't", "wouldn't", "shan't", "shouldn't",
  "can't", "cannot", "couldn't", "mightn't", "mustn't", "needn't",

  // Conjunctions & Prepositions
  "and", "but", "or", "because", "as", "until", "while",
  "of", "at", "by", "for", "with", "about", "against",
  "between", "into", "through", "during", "before", "after",
  "above", "below", "to", "from", "up", "down", "in", "out",
  "on", "off", "over", "under", "onto", "upon", "around",

  // Articles & Determiners
  "a", "an", "the", "this", "that", "these", "those",
  "some", "any", "each", "every", "either", "neither",
  "such", "own", "other", "another", "both", "all", "several", "many", "most", "few", "since",

  // Time-Related Words
  "again", "further", "then", "once", "already", "soon", "later", "finally", "next",

  // Place Words
  "here", "there", "everywhere", "somewhere", "anywhere", "nowhere",

  // Degree & Quantifier Words
  "very", "too", "just", "only", "more", "less", "than", "enough", "almost",
  "rather", "quite", "really", "such",

  // Common Verbs & Adverbs
  "try", "trying", "tries", "take", "takes", "taking",
  "look", "looks", "looking",
  "seem", "seems", "seemed", "appears", "appeared",
  "go", "goes", "going", "gone",
  "come", "comes", "coming",
  "get", "gets", "getting", "got", "gotten",
  "make", "makes", "making", "made",
  "say", "says", "saying", "said", "heard",
  "know", "knows", "knew", "stopping", "stops", "becomes",

  // Game-Specific Terms
  "skill", "talent", "ability", "executes", "existing",
  "consumes mana", "consumes energy", "successfully",
  "suddenly", "predictably", "efficiently", "cast"
];

healingActions = [
  "heal", "recover", "restore", "regenerate", "revitalize", 
  "rejuvenate", "mend", "cure", "bandage", "apply", "inject", "swallow", "absorb", "patch", "treat", "soothe"
];

consumeWords = [
  "drink", "eat", "consume", "inject", "swallow", "absorb", "devour", "ingest", "chew", "bite", "sip", "gulp"
];

// Light healing items (basic healing items)
lightHealWords = [
  "bandage", "herb", "potion", "water", "minor","salve","ointment","icepack","rinse","snack", "cooked","cook","cooking"
];

// Moderate healing items (more effective healing items)
moderateHealWords = ["healing", "elixir", "tincture", "small", "bandage","magic","oil","food","meal","breakfast","lunch","dinner","delicious"
];

// Strong healing items (stronger healing items for larger wounds)
strongHealWords = ["large", "larger", "strong", "big", "scroll", "balm", "alcohol", "cream"
];

// Intense healing items (used for serious injuries or magical healing)
greatHealWords = ["superior", "life elixir", "antibacterial", "vitality", "greater","great","rare"
];

// Powerful healing items (used for critical injuries or to restore near full health)
powerfulHealWords = ["immortality", "crystal", "revival", "divine", "surgery","enchanted","powerful","extremely","extreme","mystical","legendary"
];

enterWords = ["crawl", "drift", "enter", "fall", "get", "go", "head", "lay", "lie down", "make", "move", "nap", "prepare", "proceed", "slip", "sleep", "settle", "sink", "snuggle", "step", "surrender", "take", "turn in", "transition"];

restingWords = ["catnap", "doze", "hibernate", "nap", "relax", "rest", "sleep", "slumber", "asleep"];

lightRestWords = ["brief", "fleeting", "minor", "momentary", "passing", "quick", "relax", "short", "small", "tiny", "transient", "breath", "breathe", "breathing"];

moderateRestWords = ["catnap", "doze", "light sleep", "nap", "power nap", "repose", "rest", "siesta", "snooze", "rest"];

fullRestWords = ["deep", "deeply", "hibernation", "hibernate", "long", "prolonged", "rejuvenating", "sleep", "slumber", "sound", "uninterrupted"];

dialoguePhrases = ["You say", "You tell", "You add", "You ask", "You reply", "You state", "You note", "You claim", "You remark", "You mutter", "You insist", "You whisper", "You mention", "You declare", "You respond", "You warn", "You said", "You see", "You hear"];

realizePhrases = ["It becomes apparent", "It becomes clear that", "It clicks that", "You start to realize", "You come to realize", "You come to understand", "You feel that", "You grasp the fact that", "You notice", "You realize", "You recognize that", "You see that", "It dawns on you that"];

becauseYouPhrases = ["because you", "since you", "as you", "given that you", "considering that you", "owing that you", "on account that you", "by virtue that you", "seeing as you", "thanks that you", "as a result that you", "in light that you", "for the reason that you", "in view that you", "due to the fact that you"
];

assumedWrongPhrases = ["assumed competence", "assumed preparation", "assumed you had on hand what you didn't", "didn't harness existent skills", "didn't harness existent talents", "didn't specify proficiency", "didn't specify reasonably", "expected the air to do something", "failed to secure necessary resources", "forgot to bring the right tools", "had a moment of inexperience", "missed key details", "neglected to prepare properly", "neglected proper planning", "overestimated your readiness", "rushed past your experience", "skipped on clarity", "skipped the resource", "underestimated the necessities", "underprepared", "weren't thorough enough", "were ill-equipped", "were not clear", "were too hasty"];


slightlyWorseResults = ["the outcome was close, but mostly off the mark", "the outcome was mostly underwhelming", "the outcome was less than ideal", "the outcome was disappointing", "the outcome was not as good as anticipated", "the result didn't quite measure up", "the result fell short of expectations", "the result was below the expected level", "the result was not quite what was hoped for", "the performance didn't meet expectations", "the performance was below expectations", "the performance was shy of expectations", "the performance was quite subpar", "the final outcome was mildly disappointing", "the final result was a bit of a letdown"];

attackWords = ["attack", "ambush", "bash", "batter", "bite", "bludgeon", "chop", "claw", "cleave", "club", "crack", "crush", "elbow", "flail", "fling", "gouge", "hack", "impale", "jab", "kick", "lunge", "maul", "pound", "pummel", "pierce", "punch", "ram", "rend", "shred", "slash", "slam", "slice", "smash", "stab", "strike", "swipe", "sweep", "swing", "smack", "thrust", "whack", "wreck"];

const attackTier1 = [
  "A hesitant impact leaves a soft but clear mark.",
  "A clumsy strike stirs the air noticeably.",
  "The blow lands with a hint of effect.",
  "A weak connection is made, just enough to be felt.",
  "The strike glances off, carrying some force.",
  "A light tap echoes with a gentle thud.",
  "A slight poke leaves a subtle but real impression.",
  "The hit brushes past, leaving a small trace.",
  "A hopeful flail finds its mark with modest impact.",
  "The effort shows, with a bit more strength than before.",
  "The movement is quick but still leaves a clear trace.",
  "A faint energy pulses from the impact point.",
  "The jab lingers briefly, not fading so fast.",
  "The warning registers, causing slight unease.",
  "A flicker of contact draws a small reaction.",
  "The strike carries more weight, hinting at threat.",
  "A hesitant impact barely registers.",
  "A clumsy strike barely disturbs the air.",
  "The blow lands with uncertain effect.",
  "A weak connection is made, barely felt.",
  "The strike glances off without much force.",
  "A light tap echoes faintly.",
  "A slight poke leaves a minor impression.",
  "The hit brushes past with little consequence.",
  "A hopeful flail reaches its mark, barely.",
  "The effort is noticeable but lacks strength.",
  "The movement is rushed, leaving a faint trace.",
  "An energy sighs away from the impact point.",
  "The jab seems unsure, fading quickly.",
  "A minor tremble follows the effort.",
  "The strike is more suggestion than threat.",
  "An unsteady hit makes barely a difference."
];

const attackTier2 = [
  "A decent impact settles on the target.",
  "A steady thud marks the connection.",
  "The strike finds its place without fuss.",
  "The hit pushes slightly against the defense.",
  "A clean contact echoes calmly.",
  "The jab lands with clear but modest effect.",
  "The impact is steady, leaving a small dent.",
  "The blow connects and holds its ground.",
  "A practiced move leaves a noticeable mark.",
  "The force carries a measured weight.",
  "The strike resonates with steady rhythm.",
  "A slight shift follows the connection.",
  "The weapon's touch is firm but not harsh.",
  "A forward push accompanies the hit.",
  "A quiet grunt follows the impact.",
  "The movement holds just enough power.",
  "The warning slightly registers with the target.",
  "A flicker of contact is acknowledged.",
  "The strike carries more intention than threat.",
  "The hit lands but lacks full follow-through.",
  "A mild force nudges the opponent.",
  "Contact is made, but leaves little impression."
];

const attackTier3 = [
  "A confident strike unsettles the target.",
  "The blow cuts through with purpose.",
  "A sharp impact causes a momentary stagger.",
  "The hit lands cleanly and with intent.",
  "A practiced motion sends ripples through the defense.",
  "Swift contact disrupts the opponent's stance.",
  "The blow presses through with steady force.",
  "Momentum drives the impact deeper.",
  "The movement feels well-rehearsed and sure.",
  "The strike resonates like a controlled pulse.",
  "Adjustments mid-motion still deliver the blow.",
  "The hit causes the target to hesitate.",
  "A message is conveyed through the impact.",
  "The rhythm of the strike flows naturally.",
  "The strike hints at growing skill.",
  "Precision underlies the connection.",
  "The effort is steady, if not sharp.",
  "A push more than a strike, but effective.",
  "Contact is solid, though not overwhelming."
];

const attackTier4 = [
  "A firm impact leaves a visible mark.",
  "The strike breaks through the guard.",
  "The target reels from the force.",
  "Momentum flows like water into steel.",
  "A heavy thud echoes with weight.",
  "The blow cuts a clean arc through defense.",
  "The hit lands fully on a weak point.",
  "The momentum drives the strike home.",
  "The stance holds firm beneath the impact.",
  "The strike lands with quiet certainty.",
  "A jolt runs through the opponent's posture.",
  "The blow locks into its intended angle.",
  "The hit ends any further resistance.",
  "Respect is earned with that connection.",
  "Control is evident in the impact.",
  "The strike carries the weight of experience.",
  "The motion is not flawless, but firm.",
  "A noticeable hit, though less than perfect.",
  "The force strikes true but lacks flourish."
];

const attackTier5 = [
  "The blow drives the target back noticeably.",
  "Force behind the hit disrupts balance.",
  "The air shifts sharply with the impact.",
  "Focused strength punishes the defense.",
  "The swing finds an opening wide enough to exploit.",
  "The sound of impact warns nearby foes.",
  "A disciplined strike lands with solid force.",
  "Momentum disrupts the opponent's rhythm.",
  "Hesitation breaks under the weight of the hit.",
  "The strike cuts through doubt and hesitation.",
  "Movement flows like water through resistance.",
  "The impact carries practiced momentum.",
  "The target lurches in response.",
  "The blow speaks of determination and strength.",
  "The hit unsettles with quiet authority.",
  "The connection leaves no room for recovery.",
  "The swing is effective, if not clean.",
  "Pressure builds behind the hit, just enough.",
  "Strength surges, though briefly delayed."
];

const attackTier6 = [
  "A forceful blow lands with sharp clarity.",
  "Resistance is sliced cleanly away.",
  "The motion flashes with practiced precision.",
  "The target is knocked back with graceful power.",
  "The strike lands like a measured command.",
  "Momentum flows with disciplined grace.",
  "The hit hums with controlled violence.",
  "A clean impact sends a ripple through the target.",
  "The movement cuts through defenses smoothly.",
  "Even gravity seems to respect the strike.",
  "The opponent braces, but the hit connects.",
  "A gasp escapes those watching the impact.",
  "The weapon's motion carries unyielding intent.",
  "The blow lands like a falling star‚Äôs certainty.",
  "The strike leaves a lasting impression.",
  "Momentum and precision unite in the hit.",
  "The delivery wavers slightly, but recovers.",
  "Control dips, yet the hit lands well.",
  "A moment's imbalance doesn't stop the strike."
];

const attackTier7 = [
  "Precision and power combine in the strike.",
  "Momentum fuels a decisive impact.",
  "The guard shudders under a sharp cut.",
  "A rhythmic force pulses through the blow.",
  "The hit arrives like the first drop of a storm.",
  "The enemy stumbles back in surprise.",
  "The weapon moves as if guided by instinct.",
  "Motion and violence merge seamlessly.",
  "The strike lands just ahead of expectation.",
  "The attack flows like a dancer‚Äôs movement.",
  "The air vibrates with the blow‚Äôs precision.",
  "Time seems to pause briefly at impact.",
  "Breath catches before the force lands.",
  "The connection speaks of practiced skill.",
  "The strike lands as if anticipated.",
  "Art and pain intertwine in the hit.",
  "One step falters, but the hit stays true.",
  "Sharp, but not quite flawless.",
  "Timing slips slightly, yet power holds."
];

const attackTier8 = [
  "The strike arrives almost unseen.",
  "The motion feels part of a larger force.",
  "Focused chaos drives the impact.",
  "The target barely perceives the blow.",
  "The hit rings out across the battlefield.",
  "Time itself seems to slow around the strike.",
  "Stance collapses beneath crashing force.",
  "The attack lands with quiet inevitability.",
  "Sound trails behind the motion.",
  "Movement weaves between magic and steel.",
  "The hit flows like a living gust.",
  "Shadows linger after the strike.",
  "Air warps where the blow lands.",
  "Presence alone seems to deliver the hit.",
  "A glint of light precedes impact.",
  "Pain wraps itself around the connection.",
  "The blur fades slightly before impact.",
  "Precision stutters but the strike connects.",
  "A pulse of force overcomes a shaky start."
];

const attackTier9 = [
  "The strike becomes a force of pure intent.",
  "The air parts before the hit.",
  "Expectations shatter along with defense.",
  "The blow thunders with deadly direction.",
  "Motion adjusts without losing force.",
  "Defense collapses under sheer will.",
  "Sound trails behind the impact.",
  "The target reacts too late to avoid it.",
  "A flash marks the turning point.",
  "The hit lands like fate fulfilled.",
  "Mastery speaks through the strike.",
  "Guard dissolves into suggestion.",
  "Recovery is denied by the blow.",
  "The world narrows to the weapon‚Äôs path.",
  "Space itself seems torn apart.",
  "The strike is a final verdict.",
  "Power is held, though briefly misaligned.",
  "Speed falters for a breath, but recovers.",
  "The hit stumbles, then erupts with force."
];

const attackTier10 = [
  "The strike carries the full weight of your being.",
  "This blow could close a chapter.",
  "Reality flickers with the swing's speed.",
  "The hit cuts like a blade from legend.",
  "Every atom agrees on the force delivered.",
  "Air and enemy alike are displaced.",
  "Belief itself feels cleaved by the strike.",
  "Possibility crumbles beneath the blow.",
  "Stillness splits like a whispered verdict.",
  "The swing feels like an ending.",
  "Muscle and myth combine in the hit.",
  "Air recoils from the passage of force.",
  "This is no mere strike ‚Äî it‚Äôs judgment.",
  "History is written in the motion.",
  "Silence reigns before, awe after.",
  "The battlefield feels smaller in its wake.",
  "A ripple of imperfection rides a perfect blow.",
  "The strike trembles ‚Äî then erupts.",
  "A final moment of doubt precedes a storm."
];

const atkSpdTier1 = [
  "A hesitant shuffle barely stirs the air",
  "Your movement feels a bit sluggish",
  "A slow step carries little urgency",
  "A slow shuffle signals your move",
  "You move with gentle hesitation",
  "Your movement barely stirs the air",
  "A careful step precedes the strike",
  "The motion is tentative, almost cautious",
  "You move with measured calm",
  "Your approach is soft and unhurried",
  "A subtle adjustment hints at your intent",
  "Your action unfolds with quiet restraint",
  "The speed feels easy, almost lazy"
];

const atkSpdTier2 = [
  "Your step drags slightly behind your intent",
  "A mild hesitation delays your movement",
  "Your pace feels a touch uneven",
  "Your step quickens slightly",
  "A light breeze follows your motion",
  "You move with steady purpose",
  "A deliberate pace guides your action",
  "The flow is smooth but unassuming",
  "Your movement has quiet determination",
  "You prepare with a mild surge of energy",
  "The motion gains a bit of momentum",
  "You advance with modest speed",
  "Your actions become more assured"
];

const atkSpdTier3 = [
  "Your motion starts a bit slow but builds",
  "The first step lacks some confidence",
  "You move with cautious energy",
  "Your movement picks up pace",
  "The air shifts around your motion",
  "You flow with balanced energy",
  "A sharper rhythm marks your steps",
  "You move with clear intent",
  "Your speed adds weight to your presence",
  "The motion feels precise and ready",
  "You approach with a confident glide",
  "Your steps echo mild assurance",
  "The pace feels natural and focused"
];

const atkSpdTier4 = [
  "Your momentum hesitates for a moment",
  "Your pace is a touch uneven",
  "The motion lingers before picking up",
  "Your motion cuts through the air",
  "A brisk rhythm underlies your move",
  "You advance with crisp clarity",
  "The flow hums with growing energy",
  "Your steps land with noticeable speed",
  "Your movement sharpens, gains focus",
  "A quickened pulse marks your action",
  "You press forward with steady force",
  "Your motion brims with readiness",
  "You move with clear, controlled speed"
];

const atkSpdTier5 = [
  "Your movement carries a mild drag",
  "A slight wobble marks your step",
  "Your pace wavers before steadying",
  "Your speed commands attention",
  "The air ripples from your motion",
  "You move with crisp determination",
  "A vibrant energy fuels your pace",
  "Your steps fall with bold intent",
  "The motion is sharp and precise",
  "Your presence quickens markedly",
  "You push forward with clear momentum",
  "Your movement holds assured power",
  "The speed carries a steady edge"
];

const atkSpdTier6 = [
  "Your stride starts hesitant, then sharpens",
  "The pace momentarily slips before firming",
  "Your motion hesitates then flows",
  "Your motion flows like a sharp breeze",
  "You cut through space with grace",
  "Your steps ring with confident speed",
  "A focused energy drives your movement",
  "You advance with quick, measured force",
  "Your speed is keen and effective",
  "The flow carries purposeful rhythm",
  "You move like a sharpened blade",
  "Your pace is lively and exact",
  "Your motion is a clear signal of intent"
];

const atkSpdTier7 = [
  "Your burst slows slightly before surging",
  "A slight stumble before regaining speed",
  "The motion briefly falters but continues",
  "Your speed feels like a quick gust",
  "You strike the air with sharp precision",
  "Your movement blends speed and grace",
  "The motion crackles with kinetic energy",
  "You advance like a sudden breeze",
  "Your steps flash with clear intent",
  "Your flow carries dynamic force",
  "You push forward with swift confidence",
  "The pace hums with controlled power",
  "Your motion cuts cleanly through space"
];

const atkSpdTier8 = [
  "Your motion blurs, then slows briefly",
  "A flicker of hesitation passes",
  "The strike stutters before cutting through",
  "Your motion blurs briefly in the air",
  "A swift current follows your steps",
  "You move with lightning-quick focus",
  "The air buzzes at your approach",
  "You press forward with striking velocity",
  "Your movement slices sharply",
  "The rhythm of your steps commands space",
  "You glide forward with fierce intent",
  "Your speed hints at latent power",
  "Your motion is a sudden, clear force"
];

const atkSpdTier9 = [
  "Your quickness wavers just before impact",
  "A momentary slack in your pace",
  "The strike pauses briefly, then strikes true",
  "You flash forward with sharp precision",
  "The air parts sharply before you",
  "Your steps echo with rapid intent",
  "You move like a sudden gust of wind",
  "Your motion strikes with clear force",
  "The pace is fierce but controlled",
  "Your speed carries focused energy",
  "You push through space with crisp power",
  "The rhythm of your steps is electric",
  "Your movement demands attention"
];

const atkSpdTier10 = [
  "Your motion falters, then rockets forward",
  "A brief hesitation in the storm of your strike",
  "The speed ebbs, then surges with force",
  "Your motion is a streak of clarity",
  "You slice through space with perfect timing",
  "The air crackles as you move",
  "Your steps thunder with swift authority",
  "You strike with unstoppable speed",
  "Your movement is a force of nature",
  "You blur through the moment, precise and fierce",
  "The pace is relentless and exact",
  "Your speed commands the battlefield",
  "You move with the certainty of a storm"
];

const spdTier1 = [
  "You moved with hesitation.",
  "Your pace was unhurried.",
  "You reacted a bit late.",
  "Your steps were cautious.",
  "You lagged slightly behind.",
  "Your movement was mild.",
  "You shuffled along.",
  "You stayed near the edge of action.",
  "You moved, but not urgently.",
  "You followed the pace of others.",
  "You almost missed the moment.",
  "You caught yourself just in time.",
  "You moved late‚Äîbut not too late.",
  "You stumbled, but kept going."
];

const spdTier2 = [
  "You responded at a decent pace.",
  "You kept steady footing.",
  "You moved in time with the flow.",
  "Your reaction was acceptable.",
  "You stayed alert but not rushed.",
  "You acted without delay.",
  "Your motion was timely.",
  "You took a firm step forward.",
  "You held your ground and advanced.",
  "You moved as needed.",
  "You wavered, but followed through.",
  "You hesitated, then acted fast enough.",
  "You nearly lagged but recovered.",
  "You were a beat behind, but stayed effective."
];

const spdTier3 = [
  "You stepped in smoothly.",
  "You navigated with focus.",
  "Your pace matched the moment.",
  "You moved with intention.",
  "You dodged with calm control.",
  "You adjusted fluidly.",
  "You kept up with ease.",
  "You slipped past at the right moment.",
  "You moved when it mattered.",
  "You engaged without delay.",
  "You flinched first, then found flow.",
  "You nearly lost the beat, but recovered.",
  "You hesitated mid-step but regained your rhythm.",
  "You reacted just shy of perfect timing."
];

const spdTier4 = [
  "You shifted before it hit.",
  "You sidestepped without thinking.",
  "You stepped into a better position.",
  "Your reflex was sharp.",
  "You moved with natural readiness.",
  "You flowed around the threat.",
  "You anticipated the motion.",
  "You edged ahead.",
  "You slipped out of reach.",
  "You kept your momentum.",
  "You nearly lost your footing but held course.",
  "You stumbled into a better position.",
  "Your motion faltered‚Äîbarely‚Äîbut held.",
  "You made the move just in time."
];

const spdTier5 = [
  "You intercepted with swift control.",
  "You adjusted in mid-move.",
  "You reacted just in time.",
  "You slipped through a narrow gap.",
  "Your motion was barely seen.",
  "You read the moment instantly.",
  "You darted into advantage.",
  "You accelerated through the gap.",
  "You breezed past the pressure.",
  "You moved ahead of time.",
  "You clipped the edge but made it through.",
  "You misread slightly, but recovered fast.",
  "You almost lost balance in motion.",
  "You got through‚Äîbut only just."
];

const spdTier6 = [
  "You moved before the signal.",
  "You faded out of reach.",
  "Your steps blurred slightly.",
  "You interrupted the moment.",
  "You vanished between thoughts.",
  "You moved in the in-between.",
  "You bent around timing.",
  "You surged through a blink.",
  "You crossed the line unseen.",
  "You glided without friction.",
  "You flickered once, then regained form.",
  "You lost track for a beat‚Äîthen vanished.",
  "You barely avoided being seen.",
  "You left a tremor behind your slip."
];

const spdTier7 = [
  "You broke formation with grace.",
  "You accelerated without effort.",
  "Your response came before need.",
  "You slipped around consequence.",
  "You were gone before it mattered.",
  "You slid past their intent.",
  "You darted without windup.",
  "You opened space where there was none.",
  "You broke timing subtly.",
  "You disappeared and returned.",
  "You felt resistance‚Äîbut outpaced it.",
  "You nearly got caught in flow.",
  "You reappeared a breath too soon.",
  "You paused for a flicker‚Äîthen moved again."
];

const spdTier8 = [
  "You arrived where no path existed.",
  "Your pace disrupted expectation.",
  "You moved in silence between moments.",
  "You broke through reaction time.",
  "You created a gap with motion alone.",
  "You turned presence into motion.",
  "You operated ahead of awareness.",
  "You passed through anticipation.",
  "You lapped the moment itself.",
  "You escaped momentum's reach.",
  "You faltered slightly before vanishing.",
  "Your blur returned with a wobble.",
  "You nearly collided with time‚Äîbut twisted free.",
  "A brief hesitation almost caught you."
];

const spdTier9 = [
  "You moved through the margin of possibility.",
  "You were felt but not seen.",
  "You skipped the buildup and acted.",
  "You merged instinct with motion.",
  "You danced outside rhythm.",
  "You ignored delay entirely.",
  "You left reactions behind.",
  "You passed thought by.",
  "You slipped through stillness.",
  "You left only a trace.",
  "You shimmered oddly before stabilizing.",
  "You nearly brushed against reaction.",
  "You arrived a sliver too early.",
  "You flickered‚Äîalmost noticed."
];

const spdTier10 = [
  "You existed only between actions.",
  "You distorted the sense of time.",
  "You were presence without motion.",
  "You shaped space with pace.",
  "You eluded reality‚Äôs steps.",
  "You moved while the world paused.",
  "You blurred into position.",
  "You reacted before intention formed.",
  "You bypassed delay like a breath.",
  "You became the echo of speed.",
  "Reality briefly rejected your step‚Äîthen bent.",
  "You trembled at the edge of being seen.",
  "You flickered out‚Äîthen fully vanished.",
  "You slipped‚Äîbut impossibly corrected mid-vanish."
];

dodgeWords = [
  // Running
  "run", "running", "sprint", "sprinting", "dash", "dashing", "jog", "jogging",  
  "rush", "rushing", "flee", "fleeing",  
  "hurry", "hurrying", "escape", "escaping", "scurry", "scurrying",

  // Dodging
  "dodge", "dodging", "sidestep", "sidestepping", "evade", "evading", "ducking", "swerve", "swerving", "weave", "weaving",  
  "avoid", "avoiding", "jump", "jumping", "leap", "leaping", "skid", "skidding",  

  // Retreating
  "retreat", "retreating", "withdraw", "withdrawing", "fall back", "falling back", "back away", "backing away",
];

luckyPhrases = [
  "a bit of good fortune",
  "a slight stroke of luck",
  "a touch of serendipity",
  "a minor lucky break",
  "a tad more fortunate",
  "a little extra luck",
  "a slight favor of fate",
  "luck's gentle nudge",
  "a small lucky charm at play",
  "a modest turn of fortune",
  "a hint of providence",
  "just enough luck to matter",
  "luck by a hair",
  "a whisper of good fortune",
  "some luck"
];

graspPhrases = [
  "You clutch",
  "You seize",
  "You take hold of",
  "You latch onto",
  "You clasp",
  "You catch hold of",
  "You cling to",
  "You grasp"
];

healthFeelsHalfway = ["your health feels average", "your health is at a mid-point", "your health feels balanced", "you're in fair health", "your health is in the middle", "your health is at an even keel", "your health feels stable but moderate", "you're halfway to full strength", "your health is neither strong nor weak", "your health is moderate", "you're at half strength", "your health stands at the halfway mark", "your vitality is halfway depleted", "you're in a neutral state of health", "your health is balanced at half", "you're halfway from full vigor", "your health is split right down the middle", "you're not in great shape, but not at rock bottom", "your body feels neither strong nor weak, just halfway there", "you're at the middle of your strength"]

healthVeryLow = ["your health is hanging by a few threads", "your vitality is on the brink of collapse", "you're hanging on by a thread", "your health is barely holding together", "your body feels like it's on its last leg", "you're one step away from falling", "your strength is nearly depleted", "you're hanging in there by sheer will", "you're on the edge of total exhaustion", "your health is almost gone, just a breath away from falling", "you're teetering on the edge of unconsciousness", "your body is at its breaking point", "you're seconds away from complete collapse", "your health is almost a memory"];

healthDeathArray = [
  "the world slows as your life ends, and everything goes dark.",
  "time seems to freeze as your life slips away, leaving you in the void of death.",
  "everything blurs as your life gives out, and you fade into nothing.",
  "the world spins around you as your body gives in, you have died.",
  "everything goes silent as you collaspe and die.",
  "the world grows distant as your health drains, and death takes you.",
  "your vision dims and the world around you disappears as death claims you.",
  "the air grows heavy, and with one final breath, you fade from existence.",
  "the ground fades beneath you as your body finally succumbs to death.",
  "the world keeps turning as you fall into the abyss of your own demise.",
  "your body gives way, and with a final breath, death embraces you.",
  "the world fades into stillness, and with it, your life slips away.",
  "your final moments pass as you embrace death.",
  "you surrender to death as your health has fallen to zero."
];

 halfEnergyArray = [
  "you feel drained, like only half of your energy remains.",
  "your energy is running half of what it should be.",
  "you feel a bit sluggish, with just half the energy you normally have.",
  "your vitality feels halved, leaving you feeling sluggish.",
  "you must be running on a hungry stomach, since you feel like you have half your usual energy.",
  "you feel like you've only got half the energy left to keep going.",
  "your energy reserves are half spent, making everything feel slightly more difficult.",
  "you are craving a nap and its affecting you.",
  "you're craving an energy drink considering you're half spent",
  "you feel half as lively.",
  "your body feels a bit tired, like it‚Äôs only working with half the energy.",
  "you feel halfway exhausted and could use a meal."
];

exhaustedArray = [
  "you feel almost drained.",
  "your energy is nearly depleted.",
  "you feel close to utterly spent.",
  "you feel almost completely wiped out.",
  "you feel like you can't go on any longer.",
  "your body is fatigued, every movement is a struggle.",
  "you feel utterly exhausted, as if you've run out of fuel.",
  "your energy is an inch away from being used up.",
  "you're so tired, every muscle aches.",
  "you feel like you're at the end of your rope and need rest."
];

exhaustionSleepArray = [
  "you find the need for a place for deep sleep as your body succumbs to its weariness.",
  "you urgently need to crawl into slumber, the exhaustion is too much to bear.",
  "you are about to drift away into unconscious sleep as fatigue takes hold.",
  "you need to get sleep, your body is about to let go of its fight with exhaustion.",
  "you need to go under rest, the overwhelming tiredness is pulling you.",
  "you need to head into sleep, your mind is shutting down as exhaustion claims you.",
  "you need to lay down, the exhaustion almost pulling you into a deep, much-needed rest.",
  "you require deliberate action to lie down, and wish for sleep to come quickly, your body finally giving in.",
  "you mind needs you to make your way into sleep, the exhaustion is too much to resist.",
  "you need to purposely move into slumber, your mind surrendering to the weight of your fatigue.",
  "you urgently require deliberate sleep, the fatigue finally overtaking you.",
  "you need to settle into sleep, your body letting go of the day‚Äôs exhaustion.",
  "you need to sink into sleep, the weight of your weariness dragging you under.",
  "you need to step into slumber, your exhaustion becoming too much to fight.",
  "you need to surrender to sleep, the exhaustion finally winning over your body.",
  "you need to take a deep breath and fall into sleep, your body letting go.",
  "you need to turn in immediately, and sleep will claim you effortlessly.",
  "you need to transition into slumber, else your body will fail you."
];

bodyParts = [
  // Standard humanoid body parts
  "abdomen", "achilles tendon", "ankle", "arm", "arteries", "back", "biceps", "bladder", "buttocks", "body",
  "calf", "cheek", "chest", "chin", "collarbone", "deltoid", "diaphragm", "ear", "elbow", "esophagus",
  "eyebrow", "eyelid", "face", "fingers", "foot", "flesh", "forearm", "forehead", "gums", "gut", "groin", "hamstring",
  "hand", "head", "heart", "heel", "hip", "intestines", "jaw", "kidney", "knee", "knuckles", "leg",
  "lips", "liver", "lungs", "lung", "lower back", "nape", "neck", "nose", "palm", "pancreas", "pelvis",
  "quadriceps", "ribs", "scapula", "shin", "shinbone", "shoulder", "side", "skull", "solar plexus",
  "spine", "spleen", "stomach", "sternum", "tailbone", "teeth", "temple", "thigh", "throat", "thumb",
  "toes", "triceps", "upper back", "veins", "waist", "wrist",

  // Fantasy/Sci-Fi Races
  "antlers", "barb", "beak", "carapace", "chitin", "claw", "crest", "eye stalk", "fang", "feathers",
  "fin", "frill", "gill", "horn", "hoof", "mandible", "membrane", "proboscis", "scales", "shell",
  "snout", "spikes", "stinger", "talon", "tail", "thorax", "trunk", "tusk", "whiskers", "wing"
];

beginnerMageSpells = ["Aegis Spark", "Air Slash", "Arcane Bolt", "Astral Pulse", "Breeze Cutter", "Blink Step", "Cinder Pop", "Chain Zap", "Chilling Breeze", "Crystal Ray", "Cyclone Flick", "Dark Grasp", "Dimensional Skip", "Dust Surge", "Echo Bolt", "Eclipse Ray", "Ember Spark", "Enchanted Breeze", "Ether Grasp", "Ethereal Dash", "Fireball", "Flame Flicker", "Frost Spritz", "Frost Touch", "Frozen Grasp", "Gale Wave", "Glacial Spike", "Gravity Nudge", "Gust Levitate", "Healing Touch", "Hex Drizzle", "Holy Flicker", "Illusion Drift", "Illusory Veil", "Inferno Puff", "Ice Shard", "Lightning Jolt", "Light Beam", "Lunar Ripple", "Lumina Shot", "Mana Burst", "Mana Spark", "Mana Wave", "Minor Curse", "Minor Shield", "Molten Drip", "Mystic Bind", "Mystic Flick", "Mystic Missile", "Nature‚Äôs Whisper", "Pebble Blast", "Phase Shift", "Pocket Flame", "Protective Ward", "Radiant Glow", "Runic Bind", "Runic Shot", "Searing Drizzle", "Scorch Burst", "Seismic Tap", "Shadow Whisper", "Shock Tap", "Spark", "Spirit Mend", "Starburst Jolt", "Static Shock", "Stone Toss", "Storm Spark", "Sunflare Orb", "Temporal Tick", "Thunder Snap", "Tidal Ripple", "Verdant Glow", "Void Tendril", "Whispering Ember", "Wind Gust", "Wisp Summon", "Zephyr Strike"];

beginnerHealerSkills = [
  "Heal", "Mend", "Soothing Touch", "Restore", "First Aid", "Cure", "Refresh", "Recovery", 
  "Light Mend", "Renew", "Purify", "Gentle Light", "Healing Wave", "Vitality Surge", "Rejuvenate", 
  "Blessing", "Protect", "Minor Ward", "Holy Light", "Divine Touch", "Harmonic Flow", "Revitalize", 
  "Aura Shield", "Cleansing Light", "Hope‚Äôs Embrace", "Guardian‚Äôs Whisper", "Spirit Balm", 
  "Hallowed Glow", "Tranquil Pulse", "Vital Spark", "Graceful Recovery", "Lifeforce Drizzle", 
  "Mercy‚Äôs Touch", "Serene Veil", "Blessed Whisper", "Alleviate", "Sanctuary", "Dew of Life"
];

beginnerSwordsmanSkills = [
  "Slash", "Thrust", "Guard", "Parry", "Lunge", "Swipe", "Cleave", "Shield Bash", "Strike", 
  "Shield Block", "Quick Cut", "Power Slash", "Aimed Strike", "Counterattack", "Heavy Blow", 
  "Basic Combo", "Sword Stance", "Rolling Strike", "Piercing Thrust", "Wide Swing", "Quickdraw", 
  "Guard Break", "Rising Slash", "Spin Attack", "Leg Sweep", "Charge", "Crushing Blow", 
  "Counter Slash", "Berserk Swing", "Slash and Dash", "Power Thrust", "Defensive Stance", 
  "Balanced Cut", "Fury Strike", "Serrated Strike", "Whirlwind Slash", "Combat Focus", "Blade Dance"
];

beginnerPriestSkills = [
  "Holy Light", "Blessing", "Divine Touch", "Sacred Prayer", "Healing Prayer", "Purify", "Aura of Faith", 
  "Radiant Heal", "Sanctify", "Spiritual Cleansing", "Light's Embrace", "Cleansing Wave", "Divine Shield", 
  "Sacred Shield", "Spirit Mend", "Holy Barrier", "Grace of the Divine", "Renewing Touch", "Blessed Restoration", 
  "Holy Radiance", "Spiritual Ward", "Faith's Embrace", "Light of Hope", "Sacred Grace", "Prayer of Renewal", 
  "Healing Breath", "Divine Protection", "Soulbind", "Holy Strike", "Serenity", "Healing Blessing", "Divine Intervention",
  "Protection of the Light", "Aura of Peace", "Luminous Heal", "Radiant Blessing", "Circle of Light", 
  "Spiritual Resurgence", "Wings of the Spirit", "Faithful Resurgence", "Purifying Light", "Blessed Hands", 
  "Spiritual Ward", "Graceful Touch"
];

beginnerTankSkills = [
  "Shield Bash", "Taunt", "Defensive Stance", "Shield Block", "Block", "Guard", "Challenge", 
  "Iron Will", "Fortify", "Protective Shield", "Threaten", "Roar", "Sturdy Stance", "Power Guard", 
  "Guardian's Ward", "Heavy Defense", "Unyielding", "Damage Absorption", "Battle Cry", "Counter Guard", 
  "Enduring Will", "Body Block", "Shield Wall", "Aggro Hold", "Crushing Counter", "Deflect", 
  "Reckless Block", "Taunting Roar", "Revenge Strike", "Iron Wall", "Unbreakable", "Fortitude", 
  "Toughened Flesh", "Battle Focus", "Momentum Shield", "Defensive Charge", "Block and Strike", 
  "Shield Slam", "Bastion", "Unshakable Defense", "Stabilizing Guard", "Sustain", "Absorb Impact", 
  "Guardian‚Äôs Protection", "Crippling Block", "Protective Stance", "Hold the Line"
];

beginnerPaladinSkills = [
  "Holy Strike", "Blessing", "Divine Shield", "Radiant Heal", "Smite", "Sacred Ward", "Lay on Hands", 
  "Shield of Light", "Aura of Protection", "Divine Strike", "Holy Wrath", "Protection Aura", 
  "Judgment", "Holy Light", "Sacred Defense", "Righteous Blow", "Light's Embrace", "Cleansing Touch", 
  "Avenging Strike", "Blessed Shield", "Divine Intervention", "Healing Aura", "Divine Grace", 
  "Retribution", "Sacred Cleansing", "Seal of Faith", "Divine Smite", "Holy Barrier", "Aura of Faith", 
  "Justice Strike", "Shield Bash", "Blessed Hammer", "Divine Healing", "Crusader's Might", "Radiant Ward", 
  "Shield of Justice", "Guardian's Blessing", "Faithful Touch", "Healing Light", "Aura of Courage", 
  "Purifying Flame", "Judgment of the Light", "Holy Fury", "Righteous Protection", "Spirit of Valor", 
  "Sacred Strike", "Beacon of Light", "Divine Hammer", "Light Infusion"
];

beginnerHeroSkills = [
  "Power Strike", "Quick Slash", "Shield Bash", "Healing Touch", "Agility Boost", "Charge", "Energy Burst",
  "Flame Lash", "Ice Leap", "Thunder Clap", "Defensive Stance", "Sprint", "Vigilance", "Life Leech",
  "Cloak of Shadows", "Fury Strike", "Fireball", "Ice Spike", "Wind Dash", "Stone Fist", "Heal Pulse",
  "Arcane Blast", "Speed Burst", "Shield Wall", "Rallying Cry", "Smash", "Ranged Shot", "Elemental Fist",
  "Healing Aura", "Flash Step", "Summon Familiar", "Poison Strike", "Haste", "Battle Roar", "Guardian Shield",
  "Magnetic Pull", "Water Walk", "Gravity Slam", "Spirit Bind", "Invisibility", "Flash Heal", "Stunning Strike",
  "Flare", "Mana Shield", "Blinding Flash", "Charge Strike", "Cleansing Wave", "Power Shield", "Summon Beast",
  "Dragon Breath", "Quick Heal", "Light‚Äôs Grace", "Force Push", "Healing Wind", "Thunder Strike", "Arcane Shield"
];

const upgradeTier1 = [
  "Amplified", "Bright", "Formed", "Gentle", "Greater", "Light", 
  "Modest", "Quiet", "Rare", "Raw", "Shaped", "Spirited", 
  "Swift", "Tested", "Trial", "Tuned", "Warmed", "Wild"
];

const upgradeTier2 = [
  "Angled", "Balanced", "Bouncy", "Bright", "Calculated", "Clear", 
  "Controlled", "Crisp", "Dark", "Efficient", "Enhanced", "Firm", 
  "Frosted", "Honed", "Improved", "Keen", "Measured", "Polished", 
  "Precise", "Refined", "Sharpened", "Settled", "Stable", "Steady"
];

const upgradeTier3 = [
  "Awakened", "Black", "Blue", "Brisk", "Charged", "Crystalled", 
  "Empowered", "Energetic", "Evolved", "Fortified", "Ignited", 
  "Infused", "Quickened", "Reactive", "Red", "Resonant", "Sharp", 
  "Stirring", "Swift", "Vibrant", "Welled", "Zapped"
];

const upgradeTier4 = [
  "Arc-lit", "Blazing", "Crackling", "Cursed", "Echoing", "Emberlit", 
  "Fiery", "Flamelaced", "Ghostflame", "Groundbreaking", "Howling", 
  "Impeccable", "Infernal", "Mystic", "Rainbow", "Shocking", 
  "Smoldering", "Spellburned", "Stormlit", "Twilight", "Warding", 
  "Wildborn"
];

const upgradeTier5 = [
  "Arcane", "Astral", "Celestial", "Chronoscarred", "Divine", 
  "Ethereal", "Glimmering", "Godly", "Godsent", "Heavenlit", 
  "Impossible", "Insane", "Legendary", "Luminous", "Mythforged", 
  "Omnipotent", "Omniscient", "Perfect", "Radiant", "Runebound", 
  "Starwoven", "Temporal", "Transcendent", "Vengeful", "Voidtouched"
];


const scoutWords = [
  "assess", "check", "examine", "inspect", "investigate",
  "look around", "observe", "scan", "scope out", "scout", "survey", "take in"
];

const detail1 = [
  "You didn't notice much.",
  "Nothing stands out.",
  "It all seems normal to your untrained mind.",
  "You can only see the basics, but that's about it.",
  "Your glance passes over everything without meaning.",
  "There's little your eyes can make sense of.",
  "The area feels vague and indistinct.",
  "Whatever might be here, it's lost on you.",
  "You wish you studied more.",
  "Your brain is foggy.",
  "Your eyes are sharp but your mind isn't.",
  "You rack your puny mind only to make out some small details."
];

const detail2 = [
  "You notice a few obvious features.",
  "There‚Äôs not much that catches your eye.",
  "You spot one or two things of interest.",
  "Your attention grazes the surface.",
  "Your mind snags briefly on something out of place.",
  "You register something small but can‚Äôt quite define it.",
  "You sense the bare outlines of activity.",
  "You catch a glimpse, but it fades before it‚Äôs clear.",
  "You thank the heavens that you can at least make out a detail or two."
];

const detail3 = [
  "You pick up on a few small details.",
  "Something feels off, but you're not sure what.",
  "You catch glimpses of subtle patterns.",
  "There‚Äôs more here than meets the eye.",
  "Your eyes trace uneven paths in the environment.",
  "A sound or motion almost makes sense to you.",
  "You feel the tug of something unspoken.",
  "Hints of order tease your awareness.",
  "You embrace some naivety in your surveying skills."
];

const detail4 = [
  "You notice patterns others might miss.",
  "Your thoughts linger on a few specific details.",
  "You recognize some purposeful arrangements.",
  "You catch onto a few underlying cues.",
  "Objects seem placed with intent, not randomness.",
  "You notice odd alignments that suggest deeper function.",
  "A faint mark draws your gaze, meaningful or not.",
  "You detect symmetry hidden beneath the clutter.",
  "Your mind sparks with some tiny clues."
];

const detail5 = [
  "You discern useful clues.",
  "Your mind starts connecting dots.",
  "You get a sense of structure in your surroundings.",
  "You begin to grasp the bigger picture.",
  "Faint impressions resolve into hints of narrative.",
  "There‚Äôs rhythm in the way things are spaced.",
  "Your mind fills in the blanks naturally.",
  "Disparate parts start to form a whole."
];

const detail6 = [
  "You quickly spot key elements of the scene.",
  "You see layers of meaning others overlook.",
  "Your perception filters noise from signal.",
  "You identify important features with ease.",
  "The scene unfolds before you like a planned arrangement.",
  "Each item seems to tell part of a greater story.",
  "You detect movement where others would miss stillness.",
  "Details leap out like words in a book."
];

const detail7 = [
  "You understand the implications of what you see.",
  "Your insight draws out subtle truths.",
  "You recognize hidden patterns and meanings.",
  "Nothing escapes your notice.",
  "Even the silence has structure to your ears.",
  "You sense motive behind seemingly random choices.",
  "Your thoughts flow with the shape of the space.",
  "You interpret the stillness as something waiting to act."
];

const detail8 = [
  "Your mind pieces together invisible threads.",
  "You interpret the scene with clarity and speed.",
  "Even faint traces yield meaningful conclusions.",
  "Your intuition and logic work in perfect sync.",
  "You sense memory lingering in corners and echoes.",
  "Mundane details crystallize into valuable insights.",
  "You perceive intent beneath design and behavior.",
  "Your mind stitches everything together instantly."
];

const detail9 = [
  "You analyze your surroundings with surgical precision.",
  "You intuit layers of complexity with ease.",
  "Every detail seems to speak to you.",
  "You comprehend not just the what, but the why.",
  "Your thoughts dissect the space like a scholar with diagrams.",
  "Even stillness suggests history to you.",
  "You distinguish illusion from function with ease.",
  "Your awareness stretches beyond what is visible."
];

const detail10 = [
  "You perceive truths hidden from ordinary minds.",
  "The full scope of the environment opens itself to you.",
  "You see behind appearances to the reality beneath.",
  "Your awareness feels nearly omniscient.",
  "You interpret the moment as though reading fate itself.",
  "Every shadow, scent, and silence is meaningful.",
  "You perceive time‚Äôs passage through dust and echoes.",
  "The world reveals its secrets before you even ask.",
  "Your eyes locks into every single detail.",
  "Your extreme intelligence aids you."
];

const skillPower1 = [
  "[Skill], amateurish.",
  "[Skill], tentative and raw.",
  "[Skill] flickers in.",
  "A soft hum of [Skill] stirs and buzzes.",
  "You fumble slightly as [Skill] begins to form.",
  "[Skill] shly whispers through the air",
  "You exude some inexperience with [Skill].",
  "A cute display of [Skill] executes.",
  "You manage to cast your [Skill].",
  "'[Skill], let's try this!'",
  "Your mana violently exudes as you bet your experience on [Skill].",
  "Your mana surges, fueled by hope for [Skill].",
  "Like a student of magic, your [Skill] executes.",
  "A steady show magic unfolds as [Skill] is casted.",
  "A cautious burst of magic announces your [Skill] skill."
];

const skillPower2 = [
  "You manage a quiet execution of [Skill].",
  "[Skill] winds from your fingertips.",
  "The atmosphere around you shifts in response to your [Skill].",
  "The air around you shifts subtly as [Skill] activates.",
  "[Skill] activates.",
  "Your [Skill] moves with purpose and grace.",
  "You call on [Skill], and it obeys.",
  "Your display of [Skill] arrives.",
  "Your [Skill] responds to your aura.",
  "You wield [Skill] with growing assurance.",
  "The power of [Skill] resonates calmly around you.",
  "You watch your skill [Skill] execute."
];

const skillPower3 = [
  "You perform [Skill] with steady control.",
  "[Skill] manifests with focus and clarity.",
  "There‚Äôs balance in your motion as [Skill] takes shape.",
  "You cast [Skill] like a practiced movement.",
  "The air listens as your [Skill] begins to exert.",
  "Your [Skill] shows practice.",
  "The flow of [Skill] feels reliable and calm.",
  "[Skill] appears with ease and intention.",
  "You hesitate slightly, but [Skill] still forms.",
  "[Skill] emerges with some effort.",
  "You begin to shape [Skill], slowly finding your rhythm."
];

const skillPower4 = [
  "[Skill] flows from you with growing strength.",
  "You shape [Skill] with visible intent.",
  "A steady pulse of [Skill] radiates outward.",
  "[Skill] stretches from your hands, confident and sure.",
  "Your presence deepens as [Skill] gathers momentum.",
  "[Skill] begins to answer your deeper will.",
  "Your hands move with purpose as [Skill] grows.",
  "You steady yourself as [Skill] begins to surge.",
  "A touch of control helps bring [Skill] into focus.",
  "[Skill] begins to form, guided by mild focus.",
  "You call forth [Skill] with some concentration."
];

const skillPower5 = [
  "Your [Skill] cuts through the moment with precision.",
  "You command [Skill] like a seasoned wielder.",
  "[Skill] echoes through the space with purpose.",
  "The energy of [Skill] answers your call instantly.",
  "You strike the air with [Skill], crisp and controlled.",
  "Your [Skill] shows diligence.",
  "[Skill] weaves into the moment with clarity.",
  "You place [Skill] with practiced poise.",
  "[Skill] arrives a little delayed but steady.",
  "Your posture slips slightly as [Skill] ignites.",
  "[Skill] builds slower than usual but holds form."
];

const skillPower6 = [
  "[Skill] bursts forward with confident energy.",
  "You unleash [Skill] with clear focus and strength.",
  "[Skill] rushes from you, drawing attention.",
  "The air crackles as your [Skill] expands outward.",
  "You drive [Skill] forward like a rolling wave.",
  "You propel [Skill] with unwavering purpose.",
  "[Skill] ripples outward with firm resolve.",
  "You steady your stance as [Skill] builds pressure.",
  "[Skill] sparks briefly before catching stride.",
  "A slight delay precedes your release of [Skill].",
  "Your grip tightens as [Skill] begins to respond."
];

const skillPower7 = [
  "[Skill] tears through the moment like thunder.",
  "You channel [Skill] with explosive force.",
  "Your [Skill] roars out, wild yet honed.",
  "The air begins to quivers under your [Skill]‚Äôs advance.",
  "A storm of [Skill] arcs from your stance.",
  "You shape [Skill] like a crashing tide.",
  "[Skill] erupts with raw, controlled fury.",
  "[Skill] briefly stutters before finding its power.",
  "You summon [Skill] with effort, then let it surge.",
  "[Skill] starts less violently, but ramps up quickly.",
  "A sharp breath helps you anchor your [Skill]."
];

const skillPower8 = [
  "Your [Skill] lights the scene with brilliance.",
  "[Skill] surges like a tidal force through your hands.",
  "You bend the battlefield with the strength of your [Skill].",
  "Light fractures and reforms around your [Skill].",
  "Everything shifts to accommodate your [Skill]‚Äôs presence.",
  "[Skill] pulses with undeniable clarity.",
  "You channel [Skill] with a sense of destiny.",
  "Some strain precedes your full release of [Skill].",
  "You feel [Skill] climb before unleashing.",
  "The brilliance of [Skill] dims briefly before growing.",
  "It takes a moment, but [Skill] aligns with your will."
];

const skillPower9 = [
  "[Skill] blazes with overwhelming intensity.",
  "You become a beacon of [Skill], feared and admired.",
  "[Skill] reverberates like an anthem through space.",
  "You wield [Skill] like a blade of pure will.",
  "Even time seems to hesitate at your display of [Skill].",
  "[Skill] radiates from you like a final warning.",
  "The sheer volume of [Skill] overwhelms the moment.",
  "Your [Skill] flares, briefly uneven, then locks into place.",
  "You struggle slightly, but [Skill] dominates nonetheless.",
  "An edge of chaos tempers your display of [Skill].",
  "[Skill] takes a moment to stabilize before blazing."
];

const skillPower10 = [
  "[Skill] erupts with grandeur.",
  "You are the epicenter of myth, and [Skill] is your signature.",
  "The world bends as [Skill] pours from your soul.",
  "[Skill] transcends power‚Äîit becomes legend in motion.",
  "You don‚Äôt use [Skill]; you **are** [Skill], made manifest.",
  "Your sage mastery of [Skill] speaks for itself.",
  "[Skill] reshapes the moment like a sovereign decree.",
  "You command [Skill] as if born to it.",
  "A flicker of effort breaks through before [Skill] takes hold.",
  "There‚Äôs a crack in your flow, but [Skill] still triumphs.",
  "Your form falters‚Äîbut [Skill] holds, vast and imposing."
];

const harnessSkill = [
  "You attempt to harness your [Skill].",
  "You attempt a quickened execution of [Skill].",
  "You attempt to shortcut cast [Skill].",
  "Your shortened incantation of [Skill] attempts to execute.",
  "You try to quick cast [Skill].",
  "You focus intently to channel [Skill] rapidly.",
  "You speed up your [Skill] casting.",
  "You hasten your gestures, trying to control [Skill].",
  "You push your limits to harness [Skill] faster.",
  "Your quickened [Skill] flickers in.",
  "You grasp at the edge of your [Skill], trying to unleash it swiftly.",
  "Your hurried words shape your [Skill] skill.",
  "You risk a rapid cast, hoping to avoid misfire.",
  "You rush your concentration, testing the speed of [Skill].",
  "You force [Skill] into a quicker form, with successful execution."
];

/////////////////////////////////////////////////////////////////////////////////////

/// TAS STANDARD FUNCTIONS

// Increment turn counter at end of onOutput
function turnCounter(){
  if (state.turnCount == undefined) {
    state.turnCount = 0;
  }
  
  state.turnCount += 1;
  log("state.turnCount: " + state.turnCount);
}


// Function to capitalize first letter of a string
function capitalizeFirst(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

///Function to return all indices of one target in array 
function indicesOf(arr,target){  
    indices = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            // Found the word, store its index
            indices.push(i);
        }
    }

    if(indices.length == 0){
        return null;
    }
    else{
        return indices; //arr
    }
    
}

//With a words arr and arr of targets, find all indices for each target in word arr and put them together in one arr
function indicesOfTargets(wordsArr,targetWordsArr){
  allTargetsIndicesArr = [];

  //Loop through each target word and store their indices from words arr in an array
  targetWordsArr.forEach(word => {
    //unused target words return null so filter them out of index holder
    if(indicesOf(wordsArr,word)){
      //indicesOf returns an array, alltargetindices becomes an array of arrays so concat them
      allTargetsIndicesArr = allTargetsIndicesArr.concat(indicesOf(wordsArr,word));
      allTargetsIndicesArr.sort((a, b) => a - b);
    }
  });

  //if no indices found return null
  if(allTargetsIndicesArr.length <= 0){
    return null;
  }

  return allTargetsIndicesArr;
}

//Input a string and remove punctuation
function removeSpecificPunctuation(str) {
  return str.replace(/[.><,!?;:"()\-\n]/g, " ");
}

//Return true or false for first letter capitalized
function isFirstLetterCapitalized(word) {
  if (!word) return false;  // Return false for empty string
  return word.charAt(0) === word.charAt(0).toUpperCase();
}

function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randomFloat(min, max){
  return Math.random() * (max - min) + min;
}

//Check for targets in text and split text string into words arr if there are. Replace all target words with first target word if simplify is true
function findTargetsThenSplit(text, targetWordsArr, wordsArrHolder, simplifyTF) {
  if (text == null) return null;

  yesSplit = false

  // Remove punctuation first to standardize text processing
  cleanText = removeSpecificPunctuation(text); //str

  //loop through target words check if text has target
  targetWordsArr.forEach(target => {
    targetRegex = new RegExp(`\\b${target}\\b`, "gi");
    
    //if text has target, set yessplit true
    if(targetRegex.test(cleanText)){
      //Optional replace large target words with first target word
      if (simplifyTF === true && target.split(" ").length > 1) {
        cleanText = cleanText.replace(targetRegex, targetWordsArr[0]);
      }

      yesSplit = true;
    }
  });
  //log("cleanText postregex: " + cleanText);
  //log("yesSplit: " + yesSplit);

  //split text if target was found
  if (yesSplit){
    wordsArrHolder = cleanText.split(/\s+/).filter(word => word.trim() !== "");
    //console.log("wordsArrHolder: ", wordsArrHolder);
    return wordsArrHolder;
  }
  else{
    return null;
  }

}

//Give an arr of targets and a string, clean text and check if string has a target
function cleanStringCheckForTargets(targetWordsArr, text) {
  if (text == null) {return false};

  text = text.toLowerCase();
  let cleanText = removeSpecificPunctuation(text);
  //log(cleanText);

  // Loop through target words
  for (let target of targetWordsArr) {
    let targetRegex = new RegExp(`\\b${target}\\b`, "gi");
    //log(target);

    // Check if target is found in the text
    if (targetRegex.test(cleanText)) {
      return true; // Immediately return true if a match is found
    }
  }

  return false; // Return false if no matches are found
}

//Given a words arr, checks if there is a "you" a num specificed before target indicesarr
function checkYouBeforeIndicesArr(wordsArr,indicesArr,numWordsBefore){
  //loop through array of target indices
  for(i = 0; i < indicesArr.length; i++){
    //get the current target index
    currentIndex = indicesArr[i];

    // Store words from current target index up to specified indices before them without going out of bounds into a holder
    let prevWordsHolder = wordsArr.slice(Math.max(0, currentIndex - numWordsBefore), currentIndex);

    //Check in holder containing words before current target index if it has "you"
    if(prevWordsHolder.some(word => youWords.includes(word))){
      return true;
    }
  }

  return false;
}

//Given a words arr, checks if there is a "and" a num specificed before target indicesarr
function checkAndBeforeIndicesArr(wordsArr,indicesArr,numWordsBefore){
  //loop through array of target indices
  for(i = 0; i < indicesArr.length; i++){
    //get the current target index
    currentIndex = indicesArr[i];

    // Store words from current target index up to specified indices before them without going out of bounds into a holder
    let prevWordsHolder = wordsArr.slice(Math.max(0, currentIndex - numWordsBefore), currentIndex);

    //Check in holder containing words before current target index if it has "and"
    if(prevWordsHolder.includes("and")){
      return true;
    }
  }

  return false;
}

//Counts how frequent words appear in text and decays less appeared words
function mostFrequentOutputWords(text){
  //Split text into words and clean
  outText = removeSpecificPunctuation(text).split(" ");

  //Include uppercase stop words
  capitalStopWords = [];
  capitalStopWords = stopWords.map(word => word.charAt(0).toUpperCase() + word.slice(1));

  //Remove stop words
  outText = outText.filter(word => 
  ![...stopWords, ...capitalStopWords, ...youWords].some(stopWord => stopWord === word)
  );
  
  //Holders
  state.freqWords = state.freqWords || [];
  state.wordWeights = state.wordWeights || [];

  //Push new words and weight to holders
  outText.forEach(word => {
    if(!state.freqWords.includes(word) && word != ""){
    state.freqWords.push(word);
    state.wordWeights.push(1);
    }
  })

  //Words that appear again increment over time
  state.freqWords.forEach((word,ii) => {
    if(outText.includes(word)){
      state.wordWeights[ii]++;
    }
    else{
      //Decay factor for unused words
      state.wordWeights[ii]--;
    }
  });

  //Remove decayed words and weights from holders
  state.freqWords = state.freqWords.filter((word, ii) => state.wordWeights[ii] >= 0);
  state.wordWeights = state.wordWeights.filter((count) => count >= 0);
  
  //sortTwoLinkedArrForConsole(state.freqWords,state.wordWeights);
}

//sort two linked arrs and display each element together in console
function sortTwoLinkedArrForConsole(arr1,arrToSort){
  //Combine for console log debugging
  combined = arr1.map((word, index) => [word,arrToSort[index]]);
  // Sort the combined array based on the second element (arrToSort values)
  combined.sort((a, b) => a[1] - b[1]);  // Sort by count (ascending)
  // Extract sorted arr1 and arrToSort from the combined array
  arr1 = combined.map(item => item[0]);
  arrToSort = combined.map(item => item[1]);
  arr1.forEach((word,ind)=>{
    log(arr1[ind] + ": " + arrToSort[ind]);
  })
}

// Check if any guest is distance after any home, and push weight into weightarr if true
function isAfterIndex(guestIndices, homeIndices, minDis, maxDis, weightIfTrue, arrOfWeights) {
  if(guestIndices && homeIndices){
    guestIndices.forEach((g, index) => {
      homeIndices.forEach((h, index2) => {
        // Check if the guest element is after the home element within the given distance
        if (g - h <= maxDis && g - h >= minDis) {
          arrOfWeights[index] += weightIfTrue;
        }
      });
    });
  }
}

// Check if any guest is distance before any home, and push weight into weightarr if true
function isBeforeIndex(guestIndices, homeIndices, minDis,maxDis, weightIfTrue, weightArr) {
  if(guestIndices && homeIndices){
    guestIndices.forEach((g, index) => {
      homeIndices.forEach((h, index2) => {
        // Check if the guest element is before the home element within the given distance
        if (g - h >= -maxDis && g - h <= -minDis) {
          weightArr[index] += weightIfTrue;
        }
      });
    });
  }
}

//For specificed target index, returns the index of the closest number or -1 if no number is found
function findClosestNumberIndex(arr, targetIndex) {
  let closestIndex = -1;
  let minDistance = Infinity;

  for (let i = 0; i < arr.length; i++) {
    //arr[i] = Number(arr[i]);
    if (!isNaN(arr[i])) { // Check if the element is a valid number
      let distance = Math.abs(i - targetIndex);
      if (distance < minDistance) {
        minDistance = distance;
        closestIndex = i;
      }
    }
  }

  return closestIndex; 
}

function getPlrRace() {
  // Get PE text
  let plotEssentials = state.memory.context.toLowerCase();

  // Default race to human
  let race = "human";

  // Get player race from PE
  raceNames.forEach(name => {
    if (plotEssentials.includes(name.toLowerCase() + " race")) {
      race = name.toLowerCase();
    }
  });

  // Remove spaces in race name
  race = race.replace(/\s+/g, '');

  return race;
}
/////////////////////////////////////////////////////////////////////////////////////

//Initialize player modifiers
state.playerModifiers = state.playerModifiers || {
  lvlMod: 0,
  hpMod: 0,
  mpMod: 0,
  epMod: 0,
  atkMod: 0,
  defMod: 0,
  spdMod: 0,
  lckMod: 0,
  intlMod: 0
};

const raceMods = {
  human: {
    lvlMod: 0,
    hpMod: 0,
    mpMod: 0,
    epMod: 0,
    atkMod: 0,
    defMod: 0,
    spdMod: 0,
    lckMod: 0,
    intlMod: 0
  },
  dwarf: {
    lvlMod: -5,
    hpMod: 20,
    mpMod: -10,
    epMod: -5,
    atkMod: 5,
    defMod: 15,
    spdMod: -5,
    lckMod: -5,
    intlMod: 0
  },
  beastfolk: {
    lvlMod: 0,
    hpMod: 10,
    mpMod: -5,
    epMod: 10,
    atkMod: 10,
    defMod: 0,
    spdMod: 10,
    lckMod: 0,
    intlMod: -5
  },
  elf: {
    lvlMod: 0,
    hpMod: -10,
    mpMod: 20,
    epMod: 0,
    atkMod: -5,
    defMod: 0,
    spdMod: 5,
    lckMod: 10,
    intlMod: 15
  },
  orc: {
    lvlMod: -5,
    hpMod: 15,
    mpMod: -10,
    epMod: 5,
    atkMod: 20,
    defMod: 10,
    spdMod: -10,
    lckMod: -10,
    intlMod: -5
  },
  lizardmen: {
    lvlMod: 0,
    hpMod: 10,
    mpMod: -5,
    epMod: 5,
    atkMod: 10,
    defMod: 5,
    spdMod: 0,
    lckMod: 0,
    intlMod: -5
  },
  goblin: {
    lvlMod: 5,
    hpMod: -10,
    mpMod: 0,
    epMod: 0,
    atkMod: -5,
    defMod: -10,
    spdMod: 15,
    lckMod: 10,
    intlMod: 0
  },
  majin: {
    lvlMod: 10,
    hpMod: 0,
    mpMod: 10,
    epMod: 10,
    atkMod: 10,
    defMod: 0,
    spdMod: 5,
    lckMod: 5,
    intlMod: 10
  },
  vampire: {
    lvlMod: 0,
    hpMod: -5,
    mpMod: 15,
    epMod: 5,
    atkMod: 10,
    defMod: -5,
    spdMod: 10,
    lckMod: 10,
    intlMod: 10
  },
  fairy: {
    lvlMod: 5,
    hpMod: -15,
    mpMod: 20,
    epMod: 10,
    atkMod: -10,
    defMod: -5,
    spdMod: 15,
    lckMod: 10,
    intlMod: 15
  },
  god: {
    lvlMod: 20,
    hpMod: 20,
    mpMod: 20,
    epMod: 20,
    atkMod: 20,
    defMod: 20,
    spdMod: 20,
    lckMod: 20,
    intlMod: 20
  },
  yokai: {
    lvlMod: 5,
    hpMod: 0,
    mpMod: 10,
    epMod: 0,
    atkMod: 5,
    defMod: 0,
    spdMod: 10,
    lckMod: 15,
    intlMod: 10
  },
  dragon: {
    lvlMod: -10,
    hpMod: 25,
    mpMod: 5,
    epMod: 5,
    atkMod: 20,
    defMod: 15,
    spdMod: -10,
    lckMod: -5,
    intlMod: 5
  },
  zombie: {
    lvlMod: -5,
    hpMod: 20,
    mpMod: -10,
    epMod: -5,
    atkMod: 5,
    defMod: 10,
    spdMod: -10,
    lckMod: -15,
    intlMod: -10
  },
  insectoid: {
    lvlMod: 0,
    hpMod: 5,
    mpMod: 0,
    epMod: 5,
    atkMod: 5,
    defMod: 5,
    spdMod: 15,
    lckMod: -5,
    intlMod: -5
  },
  angel: {
    lvlMod: 10,
    hpMod: 5,
    mpMod: 15,
    epMod: 10,
    atkMod: 5,
    defMod: 5,
    spdMod: 5,
    lckMod: 10,
    intlMod: 15
  },
  demon: {
    lvlMod: 5,
    hpMod: 10,
    mpMod: 5,
    epMod: 10,
    atkMod: 15,
    defMod: 5,
    spdMod: 5,
    lckMod: -5,
    intlMod: 5
  },
  daemon: {
    lvlMod: 10,
    hpMod: 5,
    mpMod: 10,
    epMod: 10,
    atkMod: 10,
    defMod: 10,
    spdMod: 10,
    lckMod: 0,
    intlMod: 10
  },
  slime: {
    lvlMod: -10,
    hpMod: 10,
    mpMod: 5,
    epMod: 5,
    atkMod: -5,
    defMod: 10,
    spdMod: -5,
    lckMod: 0,
    intlMod: 5
  },
  harpy: {
    lvlMod: 0,
    hpMod: -10,
    mpMod: 0,
    epMod: 10,
    atkMod: 0,
    defMod: -5,
    spdMod: 20,
    lckMod: 5,
    intlMod: 0
  },
  lich: {
    lvlMod: 0,
    hpMod: -15,
    mpMod: 20,
    epMod: 0,
    atkMod: -5,
    defMod: 0,
    spdMod: -5,
    lckMod: 10,
    intlMod: 20
  }
};

modKeys = ["lvlMod", "hpMod", "mpMod", "epMod", "atkMod", "defMod", "spdMod", "lckMod", "intlMod"];
raceNames = ["Human", "Dwarf", "Beastfolk", "Elf", "Orc", "Lizardmen", "Goblin", "Majin", "Vampire", "Fairy", "God", "Yokai", "Dragon", "Zombie", "Insectoid", "Angel", "Demon", "Daemon", "Slime", "Harpy", "Lich"];
statKeysForMod = ["lvl", "hp", "mp", "ep", "atk", "def", "spd", "lck", "intl"];



//CREATE new sc with player Modifiers if sc doesnt exist
function createIfNoModifierSC(){
  if (!storyCards.find(sc => sc.title === "Player Modifiers")) {
    // If "Player Modifiers" card doesn't exist, create it
    addStoryCard("Player Modifiers", "Blank", "Player Stats");

    plrRace = getPlrRace();

    // Fetch the "Player Modifiers" card
    const modSC = storyCards.find(sc => sc.title === "Player Modifiers");
    modSC.description = `Format: Stat: num\nModifiers influence your starting stats and modify the exp you receive.\nYour race is ${capitalizeFirst(plrRace)}.`;

    //Set player modifier values in SC based on their race
    modKeys.forEach(key => {
      state.playerModifiers[key] = raceMods[plrRace][key];
    });

    // Apply initial race mods to stats and display them to sc
    statKeysForMod.forEach(key => {
      // Modify normal stat
      temp1 =  state.playerStats[key] * state.playerModifiers[key + "Mod"]/100;
      state.playerStats[key] = state.playerStats[key] + temp1;
      state.playerStats[key] = Math.round(state.playerStats[key] * 100) / 100;

      // Modify max stats
      maxKey = "max" + capitalizeFirst(key);
      temp2 = state.playerStats[maxKey] * state.playerModifiers[key + "Mod"]/100;
      state.playerStats[maxKey] = state.playerStats[maxKey] + temp2;
      state.playerStats[maxKey] = Math.round(state.playerStats[maxKey] * 100) / 100;

    });

    storeStatsToSC();
  }
}

//STORES and displays the modifiers to player in sc
function storeModifiersToSC(){
  //Format player modifiers holder for SC 
  formatForSC = [];
  
  modKeys.forEach((key, index) => {
    const modName = key.replace("Mod","").toUpperCase();  //ATK
    const modFormatPart = `${modName} Modifier: ${state.playerModifiers[key]}%\n`; //ATK Modifier: 0%

    //Holder to hold all formatted strings
    formatForSC.push(modFormatPart);
  });
  //log(formatForSC);

  // Fetch the "Player Modifiers" card
  const modSC = storyCards.find(sc => sc.title === "Player Modifiers");

  //Convert holder to string, clean commas, and finally store to sc entry
  modSC.entry = String(formatForSC).replace(/,/g, '');
}

//RETRIEVE data from sc and store to playerModifiers
function retrieveModifiersFromSC(){
  // Fetch the "Player Modifiers" card
  const modSC = storyCards.find(sc => sc.title === "Player Modifiers");

  // Retrieve and split sc entry into (modName, value) lines
  const modEntries = modSC.entry.split("\n"); //arr of strings

  //Loop through each line of entry from the split and extract values
  modEntries.forEach(entry => {
      // Match and extract stat and max stat values using regex
      const match = entry.trim().match(/^([A-Z]+)\s+Modifier:\s*(-?\d+(?:\.\d+)?)(?:%)?$/);
      log("mod sc match: " + match); // HP Modifier: 0%

      //Store value in holder
      if (match) {
        modName = match[1].toLowerCase() + 'Mod'; // e.g., "HP"
        modValue = Number(match[2]); // e.g., 0

        // Finally store modValue in playerModifier
        //OR operator safeguards against null values    
        state.playerModifiers[modName] = modValue ?? state.playerModifiers[modName];
        
      }
  });

  log(state.playerModifiers);
}

/////////////////////////////////////////////////////////////////////////////////////

//Initialize player stats
state.playerStats = state.playerStats || {
  lvl: 0,
  exp: 0,
  hp: 0,
  mp: 0,
  ep: 0,
  atk: 0,
  def: 0,
  spd: 0,
  lck: 0,
  intl: 0,
  
  maxLvl: 0,
  maxExp: 0,
  maxHp: 0,
  maxMp: 0,
  maxEp: 0,
  maxAtk: 0,
  maxDef: 0,
  maxSpd: 0,
  maxLck: 0,
  maxIntl: 0
};

maxStatKeys = ["maxLvl", "maxExp", "maxHp", "maxMp", "maxEp", "maxAtk", "maxDef", "maxSpd", "maxLck", "maxIntl"];
statKeys = ["lvl", "exp", "hp", "mp","ep", "atk", "def", "spd", "lck", "intl"];


//NOTE: Players stats will be stored in a sc. CREATE initial stats. RETRIEVE from or STORE to player stats: sc> <playerstats

//Function to create new random player stats
function newPlayerStats(){  
  //Get a random max level
  state.playerStats.maxLvl = randomInt(2,30);

  //Loop through each maxstat, and set max stats equal to max level
  maxStatKeys.forEach((mStat) => {
    state.playerStats[mStat] = state.playerStats.maxLvl;
  });
  
  //Give player random initialized stats capped by max level
  statKeys.forEach((stat) => {
    state.playerStats[stat] = randomInt(1,state.playerStats.maxLvl);
  });

  // Level is always equal to max level
  state.playerStats.lvl = state.playerStats.maxLvl;

  // EXP starts at 0 and caps at 100
  state.playerStats.exp = 0;
  state.playerStats.maxExp = 100;
  
  // Stat scaling
  state.playerStats.maxHp = state.playerStats.maxLvl * 2 + 20;
  state.playerStats.maxEp = state.playerStats.maxLvl * 2 + 80;
  state.playerStats.maxMp = (state.playerStats.maxLvl * 1.5) + (state.playerStats.intl * 2) + 80;

  // Player starts at full health
  state.playerStats.hp = state.playerStats.maxHp;
  state.playerStats.ep = state.playerStats.maxEp;
  state.playerStats.mp = state.playerStats.maxMp;

}

//CREATE new sc with random playerstats if sc doesnt exist
function createIfNoStatSC(){
  if (!storyCards.find(sc => sc.title === "Player Stats")) {
    // If "Player Stats" card doesn't exist, create it
    addStoryCard("Player Stats", "Blank", "Player Stats");

    // Fetch the "Player Stats" card
    const statSC = storyCards.find(sc => sc.title === "Player Stats");
    statSC.description = "Format: Stat: num/maxNum";

    //Initialize and randomize new player stats
    newPlayerStats();

    storeStatsToSC();
  }
}

//STORES and displays the stats to player in sc
function storeStatsToSC(){
  //Format player stats holder for SC 
  formatForSC = [];
  

  maxStatKeys.forEach((key, index) => {
    // Remove 'max' and capitalize. Ex: maxAtk -> ATK
    const statName = key.substring(3).toUpperCase();  //ATK
    const statFormatPart = `${statName}: ${state.playerStats[statName.toLowerCase()]}/${state.playerStats[key]}\n`; //(ATK:)  atk/maxAtk \n

    //Holder to hold all formatted strings
    formatForSC.push(statFormatPart);
  });
  //log(formatForSC);

  // Fetch the "Player Stats" card
  const statSC = storyCards.find(sc => sc.title === "Player Stats");

  //Convert holder to string, clean commas, and finally store to sc entry
  statSC.entry = String(formatForSC).replace(/,/g, '');
}

//RETRIEVE data from sc and store to playerstats
function retrieveStatsFromSC(){
  const statMappings = {
    lvl: 'maxLvl',
    exp: 'maxExp',
    hp: 'maxHp',
    mp: 'maxMp',
    ep: 'maxEp',
    atk: 'maxAtk',
    def: 'maxDef',
    spd: 'maxSpd',
    lck: 'maxLck',
    intl: 'maxIntl',
  };
  
  //Fetch stat sc
  const statSC = storyCards.find(sc => sc.title === "Player Stats");

  // Retrieve and split sc entry into (statname, value, maxvalue) lines
  const statEntries = statSC.entry.split("\n"); //arr of strings

  //Loop through each line of entry from the split and extract values
  statEntries.forEach(entry => {
      // Match and extract stat and max stat values using regex
      const match = entry.trim().match(/^([a-zA-Z]+)\s*:\s*(\d+(?:\.\d+)?)\s*\/\s*(\d+(?:\.\d+)?)$/);
      log("stat sc match: " + match); // ATK: atk/maxAtk

      //Store value in holder
      if (match) {
        const statName = match[1].toLowerCase();  // stat name (e.g., 'hp', 'atk')
        const statValue = Number(match[2]);    // current stat value (e.g., '50')
        const maxStatValue = Number(match[3]); // max stat value (e.g., '100')

        // Finally store stat and max stat in the playerStats if name is valid
        if (statMappings[statName]) { //Ex: statMappings[atk] = 'maxAtk'
          //OR operator safeguards against null values    
          state.playerStats[statName] = statValue ?? state.playerStats[statName];
          state.playerStats[statMappings[statName]] = maxStatValue ?? state.playerStats[statMappings[statName]];
        }
      }
  });

  log(state.playerStats);
}

//Function to increment the player's stats
function statUp(statName, incAmt) {
  // Ensure incAmt is a number
  if (typeof incAmt !== "number") {
    incAmt = 0;
  }
  incAmt = Number(incAmt);
  incAmt = Math.round(incAmt * 100) / 100;
  log("incAmt: " + incAmt + " " + statName);

  //Intialize incAmt trackers for logging
  preModIncAmt = incAmt;
  scaledIncAmt = incAmt;

  //Race modifiers influence stat gains
  plrRace = getPlrRace();
  temp = incAmt * state.playerModifiers[statName + 'Mod'] / 100;
  //Multiply temp by negative to ensure modifiers dont modify oppositely when incAmt is negative
  if (incAmt < 0) {
    temp = temp * -1;
  }
  incAmt = incAmt + temp;
  incAmt = Math.round(incAmt * 100) / 100;
  log("Race modded incAmt: " + incAmt + " " + statName);

  //Get maxstat string key Ex: maxATK
  maxStatName = "max" + statName.charAt(0).toUpperCase() + statName.slice(1);

  //Save current stat
  stat = state.playerStats[statName];
  log("stat: " + stat);
  log("----------");

  // Exception: Extra hp,mp,ep shouldnt lvl up player, simply increment available value
  if (statName == "hp" || statName == "mp" || statName == "ep") {
    state.playerStats[statName] += incAmt;

    //Only two decimal places
    state.playerStats[statName] = Math.round(state.playerStats[statName] * 100) / 100;

    //No overflow for hp, mp, ep
    if (state.playerStats[statName] > state.playerStats[maxStatName]) {
      state.playerStats[statName] = state.playerStats[maxStatName];
    }

    // Fetch the "Player Stats" card and log stat changes in description
    const statSC = storyCards.find(sc => sc.title === "Player Stats");

    if (incAmt >= 0) { sign = "‚¨ÜÔ∏è" }
    if (incAmt < 0) { sign = "üîª" }

    statSC.description = `Log ${state.turnCount} | ${statName.toUpperCase()} ${sign} :  ${stat} ‚Üí ${state.playerStats[statName]} (Modded: ${incAmt}, Raw: ${preModIncAmt})\n` + statSC.description;

    state.msgHolder = state.msgHolder + `${statName.toUpperCase()} ${sign} :  ${stat} ‚Üí ${state.playerStats[statName]}\n`;
  }
  else {
    //Formula which decreases value of exp the higher your level and gets the new stat value after exp gain. (stat + incAmt*PercentReduction)
    //New stat after exp scaling formula
    newStat = 0.01 + stat + incAmt * (1.32 * Math.exp(-0.02 * stat));

    // Get scaled incAmt for logging
    scaledIncAmt = incAmt * (1.32 * Math.exp(-0.02 * stat));
    scaledIncAmt = Math.round(scaledIncAmt * 100) / 100;
    log("scaledIncAmt: " + scaledIncAmt);

    // Two decimal places only
    newStat = Math.round(newStat * 100) / 100;
    log("newStat: " + newStat);
    // todo: fix rounding at very high levels

    // Update the player stat to its new stat
    state.playerStats[statName] = newStat;

    // Stat cant pass max stat so it overflows, get the overflow if it exists
    overflow = state.playerStats[statName] - state.playerStats[maxStatName];
    overflow = Math.round(overflow * 100) / 100;
    log("overflow: " + overflow);

    // Fix stat to not pass maxstat
    if (state.playerStats[statName] > state.playerStats[maxStatName]) {
      state.playerStats[statName] = state.playerStats[maxStatName];
    };

    // Fetch sc and log
    const statSC = storyCards.find(sc => sc.title === "Player Stats");

    if (incAmt >= 0) { sign = "‚¨ÜÔ∏è" }
    if (incAmt < 0) { sign = "üîª" }

    statSC.description = `Log ${state.turnCount} | ${statName.toUpperCase()} ${sign} :  ${stat} ‚Üí ${state.playerStats[statName]} (Scaled: ${scaledIncAmt}, Modded: ${incAmt}, Raw: ${preModIncAmt})\n` + statSC.description;

    // Log to msg
    state.msgHolder = state.msgHolder + `${statName.toUpperCase()} ${sign} :  ${stat} ‚Üí ${state.playerStats[statName]}\n`;

    //If there is positive stat overflow, pass it to player EXP
    if (overflow > 0) {
      // Get current max level
      level = state.playerStats.maxLvl;
      log("level: " + level);

      // Scale overflow and add to EXP (Must scale overflow to account when player is high level but has a low stat which will overflow too much to EXP)
      state.playerStats.exp = 0.01 + state.playerStats.exp + (100 * overflow * (1.32 * Math.exp(-0.02 * level)));

      // Round to two decimal places
      state.playerStats.exp = Math.round(state.playerStats.exp * 100) / 100;
      log("state.playerStats.exp: " + state.playerStats.exp);

      //When maxEXP is reached, increment plr level and reset EXP to 0
      if (state.playerStats.exp >= state.playerStats.maxExp) {
        // Calculate amt of times to increment LVL based on EXP
        lvlIncrement = Math.floor(state.playerStats.exp / state.playerStats.maxExp);
        log("lvlIncrement: " + lvlIncrement);

        // Calculate leftover EXP
        leftoverExp = 100 * (state.playerStats.exp / state.playerStats.maxExp - lvlIncrement);
        log("leftoverExp: " + leftoverExp);

        // Increment LVL
        state.playerStats.maxLvl += lvlIncrement;

        // Reset EXP to 0 and add leftover exp
        state.playerStats.exp = 0 + leftoverExp;
        state.playerStats.exp = Math.round(state.playerStats.exp * 100) / 100;

        // Fetch the "Player Stats" card and leave log in description
        const statSC = storyCards.find(sc => sc.title === "Player Stats");
        statSC.description = `Log ${state.turnCount} | LVL ${level} ‚Üí ${state.playerStats.maxLvl}\n` + statSC.description;

        state.msgHolder = state.msgHolder + `LVL ${level} ‚Üí ${state.playerStats.maxLvl}\n`;

        // Since player has leveled up, increase all max stats
        maxStatKeys.forEach((key) => {
          //Get mod key
          statKey = key.slice(3); // Remove "max"
          modName = statKey.toLowerCase() + "Mod";

          // Apply max stat changes
          if (key == "maxHp") {
            state.playerStats[key] += 5 + (5 * state.playerModifiers[modName] / 100);
          }
          else if (key == "maxEp") {
            state.playerStats[key] += 5 + (5 * state.playerModifiers[modName] / 100);
          }
          else if (key == "maxMp") {
            state.playerStats[key] += 5 + state.playerStats.intl * 0.1 + (5 * state.playerModifiers[modName] / 100);
          }
          else {
            if (key != 'maxLvl' && key != 'maxExp') {
              state.playerStats[key] += 5 + (5 * state.playerModifiers[modName] / 100);;
            }
          }

          // Round to two decimal places
          state.playerStats[key] = Math.round(state.playerStats[key] * 100) / 100;
        });

      } // End of level up
    } //end of positive overflow
  }

  storeStatsToSC();
}

function playerNaturalRegen(){
  //Player regens only if alive
  if(state.playerStats.hp > 0){
    statUp("hp",1);
    statUp("mp",2);

    //Player loses available energy only
    if(state.playerStats.ep > 0){
      statUp("ep",-1 * randomFloat(0,1));
    }
  }
 
}

//Edit text to show player health
function warnPlayerHealth(text) {
  plrHealth = state.playerStats.hp;
  plrMaxHealth = state.playerStats.maxHp;
  plrEnergy = state.playerStats.ep;
  plrMaxEnergy = state.playerStats.maxEp;
  numTurnsDisplay = 5;

  // Warn player every 5 inputs, they have half health
  if ((plrHealth / plrMaxHealth) >= 0.45 && (plrHealth / plrMaxHealth) <= 0.50 && state.inputCount % numTurnsDisplay === 0) {
    text = text + ` ${realizePhrases[randomInt(0, realizePhrases.length - 1)]} ${healthFeelsHalfway[randomInt(0, healthFeelsHalfway.length - 1)]}.`;
  }
  // Warns at 1% to 10% health
  else if ((plrHealth / plrMaxHealth) >= 0.01 && (plrHealth / plrMaxHealth) <= 0.10 && state.inputCount % numTurnsDisplay === 0) {
    text = text + ` ${realizePhrases[randomInt(0, realizePhrases.length - 1)]} ${healthVeryLow[randomInt(0, healthVeryLow.length - 1)]}.`;
  }

  // Player Death at 0%
  if (plrHealth <= 0 && state.inputCount % 2 === 0) {
    text = text + ` Suddenly, ${healthDeathArray[randomInt(0, healthDeathArray.length - 1)]} The world continues without you.`;

    state.msgHolder = state.msgHolder + `GAME OVER. You died!\n`;
  }


  // Warns every 5 input, at 50% energy
  if ((plrEnergy / plrMaxEnergy) >= 0.45 && (plrEnergy / plrMaxEnergy) <= 0.50 && state.inputCount % numTurnsDisplay === 0) {
    text = text + ` ${realizePhrases[randomInt(0, realizePhrases.length - 1)]} ${halfEnergyArray[randomInt(0, halfEnergyArray.length - 1)]}`;
  }
  // Warns at 1% to 10% energy
  else if ((plrEnergy / plrMaxEnergy) >= 0.01 && (plrEnergy / plrMaxEnergy) <= 0.10 && state.inputCount % numTurnsDisplay === 0) {
    text = text + ` ${realizePhrases[randomInt(0, realizePhrases.length - 1)]} ${exhaustedArray[randomInt(0, exhaustedArray.length - 1)]}`;

    state.msgHolder = state.msgHolder + `Your energy is very low. You may want to rest or eat.\n`

  }

  // No energy at 0%
  if (plrEnergy <= 0 && state.inputCount % 5 === 0) {
    text = text + ` Suddenly, ${fullExhaustionArray[randomInt(0, fullExhaustionArray.length - 1)]}`;

    state.msgHolder = state.msgHolder + `You have no energy! Recover by consuming or sleeping.\n`
  }

  return text;
}

/////////////////////////////////////////////////////////////////////////////////////
//create world  sc if not present

//create world status sc
function createIfNoCurrSC(){
    formatForSC = [];
  if (!storyCards.find(sc => sc.title === "Story Status")) {
    // If "Story Status" card doesn't exist, create it
    addStoryCard("Story Status", "Blank", "world stats");

    // Fetch the "Story Status" card
    const currSC = storyCards.find(sc => sc.title === "Story Status");
     
// Convert holder to string, clean commas, and finally store to sc entry
  currSC.entry = String(formatForSC).replace(/,/g, '');
  currSC.description = String(formatForSC).replace(/,/g, '');
  };
  }
function storeCurrToSC() {
  // Fetch the "Story Status" card
  const currSC = storyCards.find(sc => sc.title === "Story Status");
  if (!currSC) return;

  // Format the heat, temperature, and author‚Äôs note info
  currSC.entry =
     `World Clock:""\n` +
  `Year: ${state.stt.year}\n` +
  `Month-Day: ${String(state.stt.month).padStart(2, '0')}-${String(state.stt.dayOfMonth).padStart(2, '0')}\n` +
  `Hour-Minute: ${String(state.stt.gameHour).padStart(2, '0')}:${String(state.stt.gameMinute).padStart(2, '0')}\n` +
    `Current Heat: ${state.heat}\n` +
    `Current Temperature: ${state.storyTemperature}\n` +
    `Current turn: ${state.turnCount}\n` +
    `Authors Note: ${state.authorsNoteStorage}`;

  // Initialize description if missing
  if (!currSC.description) {
      currSC.description = '';
  }

  // Add heatlogs if present
  if (state.heatlogs) {
      currSC.description = `Log ${state.turnCount} | ${state.heatlogs}\n` + currSC.description;
  }

  // Trim from the bottom if longer than 3000 chars
  if (currSC.description.length > 3000) {
      currSC.description = currSC.description.slice(0, 3000);
      log("Trimming currSC.description to keep only recent logs");
  }
}



function retrieveCurrFromSC() {
  // Fetch the "Story Status" card
  const currSC = storyCards.find(sc => sc.title === "Story Status");
  if (!currSC || !currSC.entry) return;

  // Split entry by lines
  const lines = currSC.entry.split('\n');

  lines.forEach(line => {
    const [key, ...rest] = line.split(':').map(s => s.trim());
    const value = rest.join(':'); // preserves hour:minute intact

    if (key === "Year") {
      state.stt.year = Number(value);
    }
    else if (key === "Month-Day") {
      const [month, day] = value.split('-').map(Number);
      state.stt.month = month;
      state.stt.dayOfMonth = day;
    }
    else if (key === "Hour-Minute") {
      const [hour, minute] = value.split(':').map(Number);
      state.stt.gameHour = hour;
      state.stt.gameMinute = minute;
    }
    else if (key === "Current Heat") {
      state.heat = Number(value);
    }
    else if (key === "Current Temperature") {
      state.storyTemperature = Number(value);
    }
    else if (key === "Authors Note") {
      state.memory.authorsNote = value || state.authorsNoteStorage;
    }
  });

  // --- Apply JSON/date recalculation logic exactly as given ---
  let needsDateRecalc = false;

  for (const key in this.defaultSettings) {
    if (state.stt[key] === undefined) {
      state.stt[key] = JSON.parse(JSON.stringify(this.defaultSettings[key]));
      if (['gameHour', 'gameMinute', 'dayOfMonth', 'month', 'year'].includes(key)) {
        needsDateRecalc = true;
      }
    }
  }
  state.stt.initialized = true;

  try {
    const currentDate = new Date(
      state.stt.year, state.stt.month, state.stt.dayOfMonth,
      state.stt.gameHour, state.stt.gameMinute
    );
    if (isNaN(currentDate.getTime())) {
      console.warn("STT.initialize: Invalid date in state. Resetting.");
      state.stt = JSON.parse(JSON.stringify(this.defaultSettings));
      const validDefaultDate = new Date(state.stt.year, state.stt.month, state.stt.dayOfMonth);
      state.stt.dayOfWeek = validDefaultDate.getDay();
    } else if (needsDateRecalc || state.stt.dayOfWeek !== currentDate.getDay()) {
      state.stt.dayOfWeek = currentDate.getDay();
    }
  } catch (e) {
    console.error("STT.initialize: Date validation error. Resetting.", e);
    state.stt = JSON.parse(JSON.stringify(this.defaultSettings));
    const validDefaultDate = new Date(state.stt.year, state.stt.month, state.stt.dayOfMonth);
    state.stt.dayOfWeek = validDefaultDate.getDay();
  }
}


function checkTimeOfDay() {
  // Ensure state variables exist
  if (typeof state.lastTimePeriod === "undefined") state.lastTimePeriod = null;
  if (typeof state.lastCheckedDay === "undefined") state.lastCheckedDay = null;

  let currentDay = state.stt.dayOfMonth;
  let hour = state.stt.gameHour;
  let minute = state.stt.gameMinute;

  // Detect any day change (forward or backward)
  if (currentDay !== state.lastCheckedDay) {
    state.lastCheckedDay = currentDay;
    state.lastTimePeriod = null; // reset so morning triggers
    return "";
  }

  let timeOfDay, emoji;
  if (hour >= 5 && hour < 12) {
    timeOfDay = "morning";
    emoji = "üåÖ"; // sunrise
  } else if (hour >= 12 && hour < 18) {
    timeOfDay = "evening";
    emoji = "üåá"; // sunset
  } else if (hour >= 0 && hour < 5) {
    timeOfDay = "late-night";
    emoji = "üåå"; // late night
  } else {
    timeOfDay = "night";
    emoji = "üåô"; // early night
  }

  // Trigger when time period changes
  if (timeOfDay !== state.lastTimePeriod) {
    state.lastTimePeriod = timeOfDay;
    return `${emoji} It is now ${timeOfDay}. Current time: ${String(hour).padStart(2, "0")}:${String(minute).padStart(2, "0")}`;
  }
  return "";
}



//Initialize player inventory
state.playerInv = state.playerInv || {
  item: [],
  amt: []
};
console.log("Player Inventory: " + state.playerInv.item + "\n" + state.playerInv.amt);

//CREATE new sc with player inv if sc doesnt exist
function createIfNoInvSC(){
  if (!storyCards.find(sc => sc.title === "Player Inventory")) {
    // If "Player Inventory" card doesn't exist, create it
    addStoryCard("Player Inventory", "Blank", "Player Stats");

    // Fetch the "Player Inventory" card
    const invSC = storyCards.find(sc => sc.title === "Player Inventory");
    invSC.description = "Format: ItemName (amt: X)";

  }
}

//STORE inv to sc
function storeInvToSC(){
  // Fetch the "Player Inventory" card
  const invSC = storyCards.find(sc => sc.title === "Player Inventory");

  //Format and display to sc
  invSC.entry = state.playerInv.item.map((item, index) => `${item} (Amt: ${state.playerInv.amt[index]})`).join("\n");
  return true;
}

// RETRIEVE inv data from sc
function retrieveInvFromSC(){
  // Fetch the "Player Inventory" card
  const invSC = storyCards.find(sc => sc.title === "Player Inventory");

  // Get inv sc entry
  fromInvSC = invSC.entry;
  //log("fromInvSC: " + fromInvSC);

  // Use regex to extract item names and amounts (Ex: Ball (Amt: 2), etc. )
  matches = fromInvSC.matchAll(/(.+?)\s*\(.*?(\d+(?:\.\d+)?).*?\)/g);

  itemHold = [];
  amtHold = [];
  for (const match of matches) {
    // Do not extract 0 amt items
    if(match[2] != 0){
    itemHold.push(match[1].trim()); // Extract item name to holder
    amtHold.push(Number(match[2])); // Extract amount as integer to holder2
    }
  }

  // Store retrieved data to codebase 
  state.playerInv.item = itemHold;
  state.playerInv.amt = amtHold;

  log("state.playerInv.item: " + state.playerInv.item);
  log("state.playerInv.amt: " + state.playerInv.amt);
}

// Detect when the player stores item and amt to their inventory
function detectStoreInv(text) {
  // Initialize condition var
  startEquip = false;

  // Verify player is not dialoguing (case-insensitive)
  dialogueCheck = true;
  dialoguePhrases.forEach(phrase => {
    if (text.toLowerCase().includes(phrase.toLowerCase())) {
      // Disable check dialoguing exists
      dialogueCheck = false;
    }
  });

  // If not a dialogue, check for inventory words in input then split text into words arr
  if (dialogueCheck == true) {
    equipTextInput = [];
    processedText = wordsToNumber(text);
    equipTextInput = findTargetsThenSplit(processedText, invWords, equipTextInput, true);
    //equipTextInput = findTargetsThenSplit(text,equipWords,equipTextInput,true);
    log("equipTextInput: " + equipTextInput);


    // If there are inventory words, check for "you equip" in words arr using indices
    if (equipTextInput != null) {
      //Get indices of all equip words in words arr
      allEquipWordIndices = [];
      allEquipWordIndices = indicesOfTargets(equipTextInput, equipWords);
      log("allEquipWordIndices: " + allEquipWordIndices);


      // If "you" is found within x indices of equip words, start equip process
      if (allEquipWordIndices != null) {
        startEquip = checkYouBeforeIndicesArr(equipTextInput, allEquipWordIndices, 3) || checkAndBeforeIndicesArr(equipTextInput, allEquipWordIndices, 2);
        log("startEquip:" + startEquip);
      }
    }
  }

  // Start equip process when "you equip + inventory" is found in words arr
  if (startEquip == true) {
    // Initialize arrays for potential items from filtered input
    potentialItem = {
      tokens: [],
      indices: [],
      weights: []
    };

    // Filter out words that arent potential items
    potentialItem.tokens = equipTextInput.filter(word =>
      ![...stopWords, ...equipWords, ...talentWords, ...dodgeWords, ...castWords, ...learnWords, ...invWords, ...numWords, ...youWords, ...selfWords, ...consumeWords, ...titleWords].some(fromArr => fromArr.toLowerCase() === word.toLowerCase())
    );
    potentialItem.tokens = potentialItem.tokens.filter(word => !/^\d+$/.test(word));
    log("potentialItem.tokens: " + potentialItem.tokens);

    if (potentialItem.tokens.length > 0) {
      // Get potential item indices from unfiltered input text
      potentialItem.indices = indicesOfTargets(equipTextInput, potentialItem.tokens);

      // Remove duplicate indices
      potentialItem.indices = [...new Set(potentialItem.indices)];
      log("potentialItem.indices: " + potentialItem.indices);

      // Initialize weight array to hold 0 for each potential item token
      potentialItem.weights = [];
      potentialItem.indices.forEach(word => { potentialItem.weights.push(0); });
      //log("potentialItem.weights: " + potentialItem.weights);

      // Get all indices of biased words in text, set to [] if null to avoid errors
      allEquipWordIndices = allEquipWordIndices || [];
      invWordIndices = indicesOfTargets(equipTextInput, invWords) || [];
      numIndices = getDigitIndices(equipTextInput) || [];
      fromIndices = indicesOf(equipTextInput, "from") || [];
      theIndices = indicesOf(equipTextInput, "the") || [];
      aIndices = indicesOf(equipTextInput, "a") || [];
      anIndices = indicesOf(equipTextInput, "an") || [];
      ofIndices = indicesOf(equipTextInput, "of") || [];
      inIndices = indicesOf(equipTextInput, "in") || [];
      intoIndices = indicesOf(equipTextInput, "into") || [];
      andIndices = indicesOf(equipTextInput, "and") || [];
      itIndices = indicesOf(equipTextInput, "it") || [];
      itsIndices = indicesOf(equipTextInput, "its") || [];
      themIndices = indicesOf(equipTextInput, "them") || [];
      thatIndices = indicesOf(equipTextInput, "that") || [];
      thenIndices = indicesOf(equipTextInput, "then") || [];

      // Weigh each token based on distance before or after biased words
      // If token is near an "equip word"
      if (allEquipWordIndices.length > 0) {
        // Ex: You place sword
        isAfterIndex(potentialItem.indices, allEquipWordIndices, 0, 3, 2.5, potentialItem.weights);
        isAfterIndex(potentialItem.indices, allEquipWordIndices, 4, 5, 1.5, potentialItem.weights);
        isAfterIndex(potentialItem.indices, allEquipWordIndices, 6, 10, 0.5, potentialItem.weights);
      }

      // If token is near an "inventory word"
      if (invWordIndices.length > 0) {
        // First 2 words before inv likely "in your" bag (Ex: ...sword in your bag)
        isBeforeIndex(potentialItem.indices, invWordIndices, 0, 2, -2.5, potentialItem.weights);
        isBeforeIndex(potentialItem.indices, invWordIndices, 2, 4, 2, potentialItem.weights);
        isBeforeIndex(potentialItem.indices, invWordIndices, 5, 6, 1.5, potentialItem.weights);
      }

      // If token is near "number"
      if (numIndices.length > 0) {
        // Ex: take 1 sword
        isAfterIndex(potentialItem.indices, numIndices, 0, 3, 2.5, potentialItem.weights);
      }

      // If token is near "the" 
      if (theIndices.length > 0) {
        // Ex: take the sword
        isAfterIndex(potentialItem.indices, theIndices, 0, 4, 2.5, potentialItem.weights);
      }

      // If token is near "from"
      if (fromIndices.length > 0) {
        // Ex: take sword from
        isBeforeIndex(potentialItem.indices, fromIndices, 0, 2, 1, potentialItem.weights);
        isBeforeIndex(potentialItem.indices, fromIndices, 3, 4, 0.5, potentialItem.weights);

        isAfterIndex(potentialItem.indices, fromIndices, 0, 3, -2, potentialItem.weights);

      }
      // If token is near "a/an"
      if (aIndices.length > 0 || anIndices.length > 0) {
        // Ex: take a sword
        isAfterIndex(potentialItem.indices, aIndices, 0, 4, 1.5, potentialItem.weights);
        isAfterIndex(potentialItem.indices, anIndices, 0, 4, 1.5, potentialItem.weights);
      }

      // If token is near "of" 
      if (ofIndices.length > 0) {
        // Ex: take 3 of the swords
        isAfterIndex(potentialItem.indices, ofIndices, 0, 1, 0.5, potentialItem.weights);
        isAfterIndex(potentialItem.indices, ofIndices, 2, 4, 1, potentialItem.weights);
      }

      // If token is near "in/into"  
      if (inIndices.length > 0 || intoIndices.length > 0) {
        // Ex: take sword and put in
        isBeforeIndex(potentialItem.indices, inIndices, 0, 8, 1, potentialItem.weights);
        isBeforeIndex(potentialItem.indices, intoIndices, 0, 8, 1, potentialItem.weights);

        isAfterIndex(potentialItem.indices, inIndices, 0, 3, -2, potentialItem.weights);
      }

      // If token is near "and"
      if (andIndices.length > 0) {
        // Ex: sword, gun, and shield
        isBeforeIndex(potentialItem.indices, andIndices, 0, 3, 1, potentialItem.weights);
        isBeforeIndex(potentialItem.indices, andIndices, 4, 6, 0.5, potentialItem.weights);

        isAfterIndex(potentialItem.indices, andIndices, 0, 3, 1.5, potentialItem.weights);

      }

      // If token is near "it/its"
      if (itIndices.length > 0 || itsIndices.length > 0) {
        //Ex: "apple and put it"
        isBeforeIndex(potentialItem.indices, itIndices, 0, 3, -1, potentialItem.weights);
        isBeforeIndex(potentialItem.indices, itsIndices, 4, 8, 1.5, potentialItem.weights);

        isAfterIndex(potentialItem.indices, itsIndices, 0, 3, -2, potentialItem.weights);
      }

      // If token is near "them"
      if (themIndices.length > 0) {
        // Ex: "and put them"
        isBeforeIndex(potentialItem.indices, themIndices, 0, 3, -1.5, potentialItem.weights);
        isBeforeIndex(potentialItem.indices, themIndices, 4, 8, 1.5, potentialItem.weights);

        isAfterIndex(potentialItem.indices, themIndices, 0, 2, -2, potentialItem.weights);
      }

      // If token is near "that"
      if (thatIndices.length > 0) {
        // Ex: take that apple
        isAfterIndex(potentialItem.indices, thatIndices, 0, 3, 1.5, potentialItem.weights);
      }

      // If token is near "then"
      if (thenIndices.length > 0) {
        // Ex: take the sword then the apple
        isAfterIndex(potentialItem.indices, thenIndices, 0, 3, 1.5, potentialItem.weights);

        isBeforeIndex(potentialItem.indices, thenIndices, 0, 3, 1.5, potentialItem.weights);
      }
      log("potentialItem.weights: " + potentialItem.weights);

      // Initialize holder for item tokens
      itemNameParts = [];

      // Find last index that passes weight threshold to know when last item tokens will be stored
      for (let i = potentialItem.weights.length - 1; i >= 0; i--) {
        if (potentialItem.weights[i] >= 4) {
          lastWeightIndex = i;
          break;
        }
      }

      // Push potential items into holder if they pass weight threshold
      potentialItem.weights.forEach((weight, index) => {
        if (weight >= 4) {
          itemNameParts.push(potentialItem.tokens[index]);
          log("itemNameParts: " + itemNameParts);

          // Slice text chunk at potential item index for end of item testing
          textChunk = processedText.replace(">", "")
            .trim()
            .split(" ")
            .slice(potentialItem.indices[index], potentialItem.indices[index] + 2)
            .join(" ");
          log("textChunk: " + textChunk);

          // Test for end of item name to join and store item from holder
          pattern = new RegExp(`\\b${potentialItem.tokens[index]}\\b\\s*(,|and|\\.)`, 'i');
          itemEnd = textChunk.search(pattern);
          log("itemEnd: " + itemEnd);

          if (itemEnd !== -1 || index == lastWeightIndex) {
            // Combine item name parts into final item name
            finalItemName = itemNameParts.join(" ");
            log("finalItemName: " + finalItemName);

            // Clear the array after item is stored for next possible item
            itemNameParts = [];

            // Get item amt
            itemAmt = findClosestNumberBefore(equipTextInput, potentialItem.indices[index]);

            if (!itemAmt) {
              itemAmt = 1;
            }

            // Get index if already existing item in player inv 
            alreadyItemIndex = [];
            alreadyItemIndex = indicesOf(state.playerInv.item, finalItemName);

            // Increment item amt if already existing in inv
            if (alreadyItemIndex) {
              state.playerInv.amt[alreadyItemIndex] += itemAmt;

              // Log to messages
              state.msgHolder = state.msgHolder + `üéí +${itemAmt} ${state.playerInv.item[alreadyItemIndex]}\n`;


              // Fetch the "Player Inventory" card and log
              const invSC = storyCards.find(sc => sc.title === "Player Inventory");
              invSC.description = `Log ${state.turnCount} | +${itemAmt} ${state.playerInv.item[alreadyItemIndex]}\n` + invSC.description;
            }
            else {
              // Else new item is stored
              state.playerInv.item.push(finalItemName);
              state.playerInv.amt.push(itemAmt);

              // Log to msg
              state.msgHolder = state.msgHolder + `üéí +${itemAmt} ${finalItemName}\n`;

              // Fetch the "Player Inventory" card and log

              const invSC = storyCards.find(sc => sc.title === "Player Inventory");
              invSC.description = `Log ${state.turnCount} | +${itemAmt} ${finalItemName}\n` + invSC.description;
            }
          }
        }
      });

      //Update SC
      storeInvToSC();

      return text = text + ` ${itemGainPhrases[randomInt(0,itemGainPhrases.length-1)]}`;

    }//end of potentialItem.tokens.length

  }//end of startEquip

  return text;
}

// Detect when player gives away an item
function detectGiving(text) {
  // Initialize condition
  startGiving = false;

  // Verify player is not dialoguing (case-insensitive)
  dialogueCheck = true;
  dialoguePhrases.forEach(phrase => {
    if (text.toLowerCase().includes(phrase.toLowerCase())) {
      // Disable check dialoguing exists
      dialogueCheck = false;
    }
  });

  // Check for give words in the text and split the input
  if (dialogueCheck == true) {
    givingTextInput = [];
    processedText = wordsToNumber(text);
    givingTextInput = findTargetsThenSplit(processedText, giveWords, givingTextInput, true);
    log("givingTextInput simplified: " + givingTextInput);

    // Get all give word indices from input
    if (givingTextInput != null) {
      allGiveWordIndices = [];
      allGiveWordIndices = indicesOfTargets(givingTextInput, giveWords);
      log("allGiveWordIndices:" + allGiveWordIndices);

      // Check if the input contains "you/and + give" then unlock execution
      if (allGiveWordIndices != null) {
        startGiving = checkYouBeforeIndicesArr(givingTextInput, allGiveWordIndices, 3) || checkAndBeforeIndicesArr(givingTextInput, allGiveWordIndices, 2);
        log("startGiving: " + startGiving);
      }
    }
  }

  // Input meets requirements, execute giving
  if (startGiving) {
    itmInputIndices = [];
    itmInputAmts = [];
    itmInvIndices = [];

    // Loop through each plr item to check if item is called in input
    state.playerInv.item.forEach((itm, index) => {
      // Split itm parts for multi worded itms
      itmParts = itm.toLowerCase().split(" ");

      // Loop through each word in input and check for full item match
      for (let i = 0; i <= givingTextInput.length - itmParts.length; i++) {
        match = true;

        // Checking for full item match (case and plural insensitive)
        for (let j = 0; j < itmParts.length; j++) {
          if (itmParts[j] !== givingTextInput[i + j].toLowerCase()
            && itmParts[j] + 's' !== givingTextInput[i + j].toLowerCase()) {
            match = false;
            break;
          }
        }

        // Item is matched
        if (match) {
          // Store first part index from input in array
          itmInputIndices.push(i);

          // Get item amt from input and store in array
          itmAmt = findClosestNumberBefore(givingTextInput, i) ?? 1;
          itmInputAmts.push(itmAmt);

          // Save item index from inv in array
          itmInvIndices.push(index);
        }
      }

    });
    log("itmInputIndices: " + itmInputIndices);
    log("itmInputAmts: " + itmInputAmts);
    log("itmInvIndices: " + itmInvIndices);

    giveFlavorText = [];
    failFlavorText = [];
    zeroAmtArr = [];

    // Player has called item
    if (itmInputIndices.length > 0) {
      // Loop through each itm called 
      itmInputIndices.forEach((itm, index) => {
        // Player has enough item amount in inv
        if (state.playerInv.amt[itmInvIndices[index]] >= itmInputAmts[index]) {
          // Subtract item amt from inventory
          state.playerInv.amt[itmInvIndices[index]] = state.playerInv.amt[itmInvIndices[index]] - itmInputAmts[index];

          // Fetch SC and log
          const invSC = storyCards.find(sc => sc.title === "Player Inventory");
          invSC.description = `Log ${state.turnCount} | -${itmInputAmts[index]} ${state.playerInv.item[itmInvIndices[index]]}\n` + invSC.description;

          // Log to messages
          state.msgHolder = state.msgHolder + `ü´¥ -${itmInputAmts[index]} ${state.playerInv.item[itmInvIndices[index]]}\n`

          // Store item to flavor text array
          giveFlavorText.push(state.playerInv.item[itmInvIndices[index]]);
          
          storeInvToSC();

        }
        // Player doesnt have enough item amount in inv
        else {
          failFlavorText.push(state.playerInv.item[itmInvIndices[index]]);
        }
      });
    }
    log("giveFlavorText: " + giveFlavorText);
    log("failFlavorText: " + failFlavorText);

    // Execute giving flavor text
    if (giveFlavorText.length > 0) {
      text = text + ` The ${giveFlavorText.join(", ")} leaves your inventory.`
    }
    if (failFlavorText.length > 0) {
      text = text + ` You realize you don't have enough ${failFlavorText.join(", ")}.`
    }

    // Unlock Context Hook feed to influence AI to reject lack of items or wrong items to give
    allItems = [];
    state.playerInv.item.forEach((itm, index) => {
      allItems.push(`${state.playerInv.amt[index]} ${state.playerInv.item[index]}`);
    })
    allItems = allItems.join(", ");

    state.invCheckText = ` You realize you have nothing in your inventory but only ${allItems}. You anticipate failure for not having the right items or amount.`

    state.unlockInvToContext = true;
    log("state.unlockInvToContext: " + state.unlockInvToContext);

  }//end of startgiving

  return text;
}

// Succeeding function for detectGiving, sends the inventory and rejection check text to AI on context hook
function feedInvToContext(text){
  if(state.unlockInvToContext){
    text = text + state.invCheckText;
    log("state.invCheckText: " + state.invCheckText);
  }
  
  state.unlockInvToContext = false;

  return text;
}

/////////////////////////////////////////////////////////////////////////////////////

//Initialize player skills
state.playerSkills = state.playerSkills || {
  name: [],
  lvl: [],
  cost: []
};
console.log("state.playerSkills.name: " + state.playerSkills.name);
console.log("state.playerSkills.lvl: " + state.playerSkills.lvl);
console.log("state.playerSkills.cost: " + state.playerSkills.cost);

///Player skills will be stored in an sc. CREATE initial sc. Skills will STORE TO or RETREIVE FROM sc.

//Function to create new class skills for player and store to their skills
function newClassSkills(classString,skillArray){
  plotEssentials = state.memory.context.toLowerCase();
  if(plotEssentials.includes(classString + " class")){
    state.playerSkills.name = [
      skillArray[randomInt(0,skillArray.length-1)],skillArray[randomInt(0,skillArray.length-1)],skillArray[randomInt(0,skillArray.length-1)]
    ];
    state.playerSkills.lvl = [
      randomInt(0,3),
      randomInt(0,3),
      randomInt(0,3)
    ];
    state.playerSkills.cost = [
      randomInt(10,40),
      randomInt(10,40),
      randomInt(10,40)
    ];

    storeSkillsToSC();
  }
}

//Always CREATE initial sc if none.
function createIfNoSkillSC(){
  //If "Player Skills" card doesn't exist, create it
  if (!storyCards.find(sc => sc.title === "Player Skills")) {
    addStoryCard("Player Skills", "Blank", "Player Stats");

    //Fetch SC and give it a description
    const skillSC = storyCards.find(sc => sc.title === "Player Skills")   
    skillSC.description = "Format: SkillName (LVL) (MP), etc.";

    //Mage, Healer, Swordsmen, Priest, Tank, Paladin, Hero, Custom
    //Classes and the skills they start with
    newClassSkills('mage',beginnerMageSpells);
    newClassSkills('healer',beginnerHealerSkills);
    newClassSkills('swordsmen',beginnerSwordsmanSkills);
    newClassSkills('priest',beginnerPriestSkills);
    newClassSkills('tank',beginnerTankSkills);
    newClassSkills('paladin',beginnerPaladinSkills);
    newClassSkills('hero',beginnerHeroSkills);

  } 
}

//To STORE skill to sc
function storeSkillsToSC(){
  //Fetch skill sc
  const skillSC = storyCards.find(sc => sc.title === "Player Skills");

  //Format and display to sc Ex: Fireball (20 MP)
  skillSC.entry = state.playerSkills.name.map((skill, index) => `${skill} (Lvl ${state.playerSkills.lvl[index]}) (${state.playerSkills.cost[index]} MP)`).join("\n");
  return true;
}

//To RETRIEVE skills from SC.
//Put in output script so retreiving is not limited to on input.
function retrieveSkillsFromSC(){ 
  //Fetch skill sc
  const skillSC = storyCards.find(sc => sc.title === "Player Skills")

  //Hold the skill sc entry string
  temp = skillSC.entry;


  skillHolder = [];
  lvlHolder = [];
  costHolder = [];
  // Extract skill name and MP cost using regex. Discard wrong formats
  let matches = temp.matchAll(/(.+?)\s*\(.*?(\d+(?:\.\d+)?).*?\)\s*\(.*?(\d+(?:\.\d+)?).*?\)/g);

  // Store in respective arrays holders
  for(const match of matches){
    // First capture group (skill name)
    skillHolder.push(match[1]); 
    // Second capture group (skill lvl)
    lvlHolder.push(Number(match[2])); 
    // Third (skill cost)
    costHolder.push(Number(match[3]))
  }
  
  //Final store to code base
  state.playerSkills.name = skillHolder;
  state.playerSkills.lvl = lvlHolder;
  state.playerSkills.cost = costHolder;
}

/////////////////////////////////////////////////////////////////////////////////////

//part of upgradePlayerSkills, applies skill name change once lvlfloor is reached
function skillNameUpgrade(level,skillIndex,tierWordArr,text){
  if(Math.floor(state.playerSkills.lvl[skillIndex]) == level){
    //Level up skill to avoid another upgrade
    state.playerSkills.lvl[skillIndex] = level + 1;

    //Mana cost reduction
    state.playerSkills.cost[skillIndex] = Math.round(state.playerSkills.cost[skillIndex] * 0.95 * 100) / 100;
    
    //store old skill name
    oldSkillName = state.playerSkills.name[skillIndex];

    //Update skill name
    if(tierWordArr == upgradeTier1){
      state.playerSkills.name[skillIndex] = tierWordArr[randomInt(0,tierWordArr.length-1)] + ' ' + state.playerSkills.name[skillIndex];
    }
    // already upgraded skills get their old prefixes removed
    else{
      // Sanitize old upgraded skill name (remove existing prefix if present)
      words = oldSkillName.split(' ');
      baseName = words.length > 1 ? words.slice(1).join(' ') : oldSkillName;

      // Apply new prefix
      newPrefix = tierWordArr[randomInt(0, tierWordArr.length - 1)];
      state.playerSkills.name[skillIndex] = `${newPrefix} ${baseName}`;
    }
    
    //Notify in player input
    text = text + ` Your ${oldSkillName} skill has been upgraded to ${state.playerSkills.name[skillIndex]}!`;

    return text;
  }

  return text;
}


function upgradePlayerSkills(text){
  state.playerSkills.name.forEach((skill,index) => {
    text = skillNameUpgrade(5,index,upgradeTier1,text);
    text = skillNameUpgrade(10,index,upgradeTier2,text);
    text = skillNameUpgrade(15,index,upgradeTier3,text);
    text = skillNameUpgrade(20,index,upgradeTier4,text);
    text = skillNameUpgrade(25,index,upgradeTier5,text);

  })

  storeSkillsToSC();
  return text;
}

/////////////////////////////////////////////////////////////////////////////////////

state.playerTalents = state.playerTalents || {
  name: [],
  lvl: [],
  cost: []
};
log("state.playerTalents.name : " + state.playerTalents.name);
log("state.playerTalents.lvl : " + state.playerTalents.lvl);
log("state.playerTalents.cost : " + state.playerTalents.cost);


state.potentialTalents = state.potentialTalents || {
  name: [],
  exp: []
};

//Always CREATE initial sc if none.
function createIfNoTalentSC(){
  //If "Player Talents" card doesn't exist, create it
  if (!storyCards.find(sc => sc.title === "Player Talents")) {
    addStoryCard("Player Talents","Blank", "Player Stats");

    //Fetch SC and give it a description
    const talentSC = storyCards.find(sc => sc.title === "Player Talents")   
    talentSC.description = "Format: Talent Name (LVL) (EP), etc.";

  } 
}

//To STORE talent to sc
function storeTalentsToSC(){
  //Fetch talent sc
  const talentSC = storyCards.find(sc => sc.title === "Player Talents");

  //Format and display to sc 
  talentSC.entry = state.playerTalents.name.map((talent, index) => `${talent} (Lvl ${state.playerTalents.lvl[index]}) (${state.playerTalents.cost[index]} EP)`).join("\n");
  return true;
}

//To RETRIEVE talent from SC.
//Put in output script so retreiving is not limited to on input.
function retrieveTalentsFromSC(){ 
  //Fetch talent sc
  const talentSC = storyCards.find(sc => sc.title === "Player Talents")

  //Hold the talent sc entry string
  temp = talentSC.entry;

  nameHolder = [];
  lvlHolder = [];
  costHolder = [];

  // Extract talent name lvl cost
  let matches = temp.matchAll(/(.+?)\s*\(.*?(\d+(?:\.\d+)?).*?\)\s*\(.*?(\d+(?:\.\d+)?).*?\)/g);

  // Store in respective arrays holders
  for(const match of matches){
    // First capture group (talent name)
    nameHolder.push(match[1]); 
    // Second capture group (talent lvl to number)
    lvlHolder.push(Number(match[2])); 
    //Third, talent cost to number
    costHolder.push(Number(match[3])); 
  }
  
  //Final store to code base
  state.playerTalents.name = nameHolder;
  state.playerTalents.lvl = lvlHolder
  state.playerTalents.cost = costHolder;
}

/////////////////////////////////////////////////////////////////////////////////////

///Talent Learning Process: player learning talents repeatedly result in the talent name appearing more often in input. Assign more points to text that is most likely to be the talent name, and designate threshold to store as talent.
//NOTE: Talent learning happens on input and finishes after getting energy cost on output. Retreiving talents between process will wipe data.
function talentLearningProcess(text){
  startLearning = false;

  // Verify player is not dialoguing (case-insensitive)
  dialogueCheck = true;
  textLower = text.toLowerCase();
  dialoguePhrases.forEach(phrase => {
    if(textLower.includes(phrase.toLowerCase())){
      // Disable check dialoguing exists
      dialogueCheck = false;
    }
  });

  //If no dialogue, check input for learn words then split
  if(dialogueCheck == true){
    learnTextInput = []
    learnTextInput = findTargetsThenSplit(text,learnWords,learnTextInput,true);
    console.log("learnTextInput: " + learnTextInput);
  
    //If there are learn words, then get their indices
    if(learnTextInput != null){
      //Loop through each learn word and store their indices in an array
      allLearnWordIndices = [];
      allLearnWordIndices = indicesOfTargets(learnTextInput,learnWords);
    
      //If there are learn word indices, then see if there is "you + learn"
      if(allLearnWordIndices != null){
        //Check if there is a "you" three words before each learn word index to unlock
        startLearning = checkYouBeforeIndicesArr(learnTextInput,allLearnWordIndices,3) || checkAndBeforeIndicesArr(learnTextInput,allLearnWordIndices,2);
        console.log("allLearnWordIndices: " + allLearnWordIndices);
        console.log("startLearning: " + startLearning);
      }
    }
  }

  //If you + learnword exist, unlock talent learning process
  if(startLearning){
    //must filter out likely nontalent words from learnTextInput
    learnTextInput = findTargetsThenSplit(text,stopWords,learnTextInput,true);
    learnTextInput = learnTextInput.filter(word => ![...stopWords,...learnWords,...titleWords,...youWords,...selfWords].some(fromArr => word.toLowerCase() === fromArr.toLowerCase()));

    //now you have an array of strings that could be talent names player is trying to learn
    likelyTalentNames = [];
    likelyTalentNames = learnTextInput;

    //If likelytalent names exist and isnt filtered to empty
    if(likelyTalentNames.length > 0){
      //remove duplicates so player cant spam learn talents in one input
      likelyTalentNames = [...new Set(likelyTalentNames)]
      console.log("likelyTalentNames: " + likelyTalentNames);

      //Table of values influencing amt of turns to learn talent/likelihood of filtered input being a talent
      state.points = {
        capitalization: 1.5,
        newTalent: 0,
        decay: 0.5,
        threshold: 2.5,
        outpaced: 2,
        existing: 1
      };
      
      //Loop through each likelytalentname for storage as potential talents or gives exp to existing potential talents.
      likelyTalentNames.forEach(likelyTalentNames => {
        //Either returns existing potential talent's index or returns its nonexistence
        let index = state.potentialTalents.name.indexOf(likelyTalentNames);

        //New likly talent names are added to the potential talents list
        if (index === -1) {
          state.potentialTalents.name.push(likelyTalentNames);

          //Capitalization grants more exp b/c more likely to be actual talent name
          if(isFirstLetterCapitalized(likelyTalentNames)){
            state.potentialTalents.exp.push(state.points.capitalization);
          }
          else{
            //Default exp for new talent names
            state.potentialTalents.exp.push(state.points.newTalent);
          }

        } 
        //Existing potential talents get exp
        else {  
          state.potentialTalents.exp[index] += state.points.existing;
        }
      });

      //Decrement unused talent names.
      for (let i = 0; i < state.potentialTalents.name.length; i++) {
        //Exclude recently incremented talent names
        if (!likelyTalentNames.includes(state.potentialTalents.name[i])) {
          state.potentialTalents.exp[i] -= state.points.decay;
        }
      }

      //Remove decayed below zero talent names
      for(i = 0; i < state.potentialTalents.name.length; i++){
        if(state.potentialTalents.exp[i] < 0){
          state.potentialTalents.name.splice(i,1);
          state.potentialTalents.exp.splice(i,1);
          i--;
        }
      }
      
      //Log in skill sc, talent learning progress 
      const talentSC = storyCards.find(sc => sc.title === "Player Talents")   
      talentSC.description = `Log ${state.turnCount} | Currently Learning: ${state.potentialTalents.name}, Exp: ${state.potentialTalents.exp}\n` + talentSC.description;

      //Loop through the potentialtalents index to check for finished talents and put in a holder
      talentNameHolder = [];
      for(i = 0; i < state.potentialTalents.name.length; i++){
        //set the exp threshold for potential talents to be learned
        if(state.potentialTalents.exp[i] >= state.points.threshold){
          //Store string(s) of talent name when threshold is hit
          talentNameHolder.push(state.potentialTalents.name[i]);
          
          //Once threshold is hit, no longer a potential talent so erase
          state.potentialTalents.name.splice(i, 1);
          state.potentialTalents.exp.splice(i, 1);

          //Decrement to fix splice edits
          i--;
        }
      }

      //Full holder means final talent exists, dont push empty holder into player talent
      if(talentNameHolder.length > 0){
        //Capitalize the talent, merge all individual string names in holder into the final talent name
        talentNameHolder = talentNameHolder.map(word => word[0].toUpperCase() + word.slice(1).toLowerCase());
        talentNameHolder = talentNameHolder.join(" ");
        console.log("talentNameHolder: " + talentNameHolder);

        //Store the learned talent, dont add duplicates to player talent
        if(!state.playerTalents.name.includes(talentNameHolder) && !state.playerSkills.name.includes(talentNameHolder)){
          state.playerTalents.name.push(talentNameHolder);
          state.playerTalents.lvl.push(randomInt(0,3));

          //Decrement all potentialTalents exp since a talent was learned
          for(i = 0; i < state.potentialTalents.name.length; i++){
            state.potentialTalents.exp[i] -= state.points.outpaced;
          }

          //Energy cost determined by AI output, unlock on output function
          state.askEnergyCost = true;
          log("askEnergyCost in: "+ state.askEnergyCost);
          
          //Talent Learn Success Message
          text = text + " You end up successfully learning the \"" + String(talentNameHolder) + "\" talent! You check how many energy points the talent requires.";
          console.log("state.playerTalents.name after learning: " + state.playerTalents.name);

          
        }//end of store learned talent
      }//end of final talent exists
    } //end of if likelytalent names exist
    
  }//end of right conditions met so process talent learning

  console.log("state.potentialTalents.name: " + state.potentialTalents.name);
  console.log("state.potentialTalents.exp: " + state.potentialTalents.exp);
  return text;
}//end of function
log("askEnergyCost out: "+ state.askEnergyCost);

//Use in output script. Final code for learning process. Gets energy cost and then stores learned talent and cost into sc.
function getEnergyCost(text){
  if(state.askEnergyCost == true){
    // Extract numbers from the output string
    let numbers = text.match(/\d+/g); 
    log("numbers: " + numbers);
    
    // Convert to numbers to number type
    let arrEnergyValue = numbers ? numbers.map(Number) : [];

    // Filter out 100 for x/100 AI outputs
    if(arrEnergyValue.length > 1){
      arrEnergyValue = arrEnergyValue.filter(value => value != 100);
    }
    log("arrEnergyValue: " + arrEnergyValue);

    // Find the highest number
    highestEnergyValue = arrEnergyValue.length > 0 ? Math.max(...arrEnergyValue) : null;
    log("highestEnergyValue: " + highestEnergyValue);

    //Use highest number in output as energy cost of talent
    if(highestEnergyValue !== null && highestEnergyValue > 0){
      state.playerTalents.cost.push(highestEnergyValue);
      console.log("state.playerTalents.cost(AI) after learning: " + state.playerTalents.cost);
    }
    else{
      //If no energy value in output, use random energy value
      randEpCost = randomInt(5,30);
      state.playerTalents.cost.push(randEpCost);
      console.log("randEpCost: " + randEpCost);

      text ="\"" + state.playerTalents.name[state.playerTalents.name.length-1] + "\" will cost " + state.playerTalents.cost[state.playerTalents.cost.length-1] + " energy to use. " + text;
    }
    
    //Successful Learning grants int
    statUp("intl",randomFloat(0.01,2));

    //Learned talent name and cost have been finalized. Store them to SC.
    storeTalentsToSC();
    storeStatsToSC();

    state.askEnergyCost = false;
    log("state.askEnergyCost after learned: " + state.askEnergyCost);
    return text;
  }
   
  return text;
}

/////////////////////////////////////////////////////////////////////////////////////

//Given an arr of words and an array of player storage (inv, talents, skills), check if anything from storage is mentioned in words arr and returns partialTF,full matchTF,storageindex
function checkPlayerStorage(text,wordsArr,playerStorage){
  hasThing = false;
  hasFullThing = false;
  finalThingIndex = false;
  ind = [];

  //Check if player has anything that PARTIALLY matches the input text
  //Loop through input words
  wordsArr.forEach((word, index1) => {
    //get the lower case version of the word
    loweredWord = word.toLowerCase();
    //loop through player things names
    playerStorage.forEach((thing, index2) => {
      // Get the lower case version of the thing name
      loweredThing = thing.toLowerCase();
      
      // Check if the word is long enough and if it matches part of the thing name
      if (loweredWord.length >= 4 && loweredThing.includes(loweredWord)) {
        hasThing = true;
        ind.push(index2);
      }
      //Else Check if the word matches the prefix of the thing name
      else if (loweredThing.startsWith(loweredWord) && loweredWord.length >= 3) {
          hasThing = true;
          ind.push(index2);
        }
      //Else Check if the word matches the suffix of the thing name
      else if (loweredThing.endsWith(loweredWord) && loweredWord.length >= 3) {
          hasThing = true;
          ind.push(index2);
        }

    });//end of thing loop
  });//end of input word loop
  log("hasThing: " + hasThing);

  //Continue if partial thing matched, which means storage has at least one thing that is mentioned in text
  if (ind.length > 0) {
    //From all thing matches, pick a random one to be the returned thing.
    finalThingIndex = ind[Math.floor(Math.random() * ind.length)];

    //Check for EXACT thing matches which overrides PARTIAL thing matches
    textLower = text.toLowerCase();

    //loop through player things
    playerStorage.forEach((thing, index) => {
      //Compare input text and player things for exact matches to override final index and flag full thing match.
      if (textLower.includes(thing.toLowerCase())) {
        finalThingIndex = index;
        hasFullThing = true;
      }
    })
    log("finalThingIndex: " + finalThingIndex);
  }

  return [hasThing,hasFullThing,finalThingIndex];
}

//Talents that are casted become a skill
function talentCastedToSkill(){
  if(talentCheck[0]){
    castIndicesExist = indicesOfTargets(plrActionTextInput,castWords);
    if(castIndicesExist){
      //Move talent to skill storage
      state.playerSkills.name.push(state.playerTalents.name[talentCheck[2]]);
      state.playerSkills.lvl.push(state.playerTalents.lvl[talentCheck[2]]);
      state.playerSkills.cost.push(state.playerTalents.cost[talentCheck[2]]);

      //Remove old copy of talent
      state.playerTalents.name.splice(talentCheck[2],1);
      state.playerTalents.lvl.splice(talentCheck[2],1);
      state.playerTalents.cost.splice(talentCheck[2],1);

      //Final store to SC
      storeTalentsToSC();
      storeSkillsToSC();
    }

  }
}

//executes the talent if player has enough energy
function executeTalent(){
  //must pass talent check
  if(talentCheck[0]){
    //Allow talent if player has enough energy otherwise do nothing
    if(hasEnergy == true){
      //If player has the EXACT talent
      if(fullTalentMatch == true){
        //Subtract ep cost from player ep
        statUp("ep", -1 * state.playerTalents.cost[talentIndex]);
        storeStatsToSC();

        postActionText = postActionText + state.playerTalents.name[talentIndex] + " talent consumes energy and successfully executes.";
      }//todo: change text
      else{ //If only PARTIAL talent matches, harness available talent
        //Subtract ep cost from player ep
        state.playerStats.en -= state.playerTalents.cost[talentIndex];
        storeStatsToSC();

        postActionText = postActionText + " You attempt to harness your existing " + state.playerTalents.name[talentIndex] + " talent.";

        postActionText = postActionText.replace(">","");
      }

      //Using talents levels them up
      talentExp = randomFloat(0,0.5);
      log("talentExp: "+ talentExp);
      state.playerTalents.lvl[talentIndex] += talentExp;
      state.playerTalents.lvl[talentIndex] = Math.round(state.playerTalents.lvl[talentIndex] * 100)/100;
      storeTalentsToSC();

      //Log talent lvl change in talent sc notes
      const talentSC = storyCards.find(sc => sc.title === "Player Talents")   
      talentSC.description = `Log ${state.turnCount} | ${state.playerTalents.name[talentIndex]} gained ${talentExp.toFixed(2)} exp.` + talentSC.description;

    }//end of has energy
  }//end of talent check
}

//executes the skill if player has enough energy otherwise do nothing
function executeSkill(){
  //Must pass skill check
  if(skillCheck[0]){

    //Allow skill if player has enough mana
    if(hasMana == true){
      //If player has the EXACT skill

      if(fullSkillMatch == true){
        //Subtract mana cost from player mana and create text
        statUp("mp",state.playerSkills.cost[skillIndex] * -1);

        //Using skills boost stats
        statUp("atk",randomFloat(0.01,0.5));
        statUp("intl", randomFloat(0.01,0.5));
        storeStatsToSC();
        
        // Define the ranges of skill effectiveness and the corresponding skill power messages
        const skillPowerRanges = [
          { min: 0, max: 10, msg: skillPower1 },
          { min: 10, max: 20, msg: skillPower2 },
          { min: 20, max: 30, msg: skillPower3 },
          { min: 30, max: 40, msg: skillPower4 },
          { min: 40, max: 50, msg: skillPower5 },
          { min: 50, max: 60, msg: skillPower6 },
          { min: 60, max: 70, msg: skillPower7 },
          { min: 70, max: 80, msg: skillPower8 },
          { min: 80, max: 90, msg: skillPower9 },
          { min: 90, max: Infinity, msg: skillPower10 }
        ];

        //Select msg based on skill level
        skillLevel = state.playerSkills.lvl[skillIndex];

        for (let range of skillPowerRanges) {
          if (skillLevel >= range.min && skillLevel < range.max) {
            postActionText = postActionText + " " + range.msg[randomInt(0, range.msg.length - 1)].replace("[Skill]", state.playerSkills.name[skillIndex]);
            break;
          }
        }
      }
      // If only PARTIAL skill matches, harness available skills
      else{ 
        // Subtract mana cost from player mana and create text
        state.playerStats.mp -= state.playerSkills.cost[skillIndex];

        // Using skills boost stats
        statUp("atk", randomFloat(0.01,0.5));
        statUp("intl", randomFloat(0.01,0.5));
        storeStatsToSC();

        // Append skill harness text
        const randomIndex = randomInt(0, harnessSkill.length - 1);
        const skillText = harnessSkill[randomIndex].replace("[Skill]", state.playerSkills.name[skillIndex]);
        postActionText += ` ${skillText}`;

        postActionText = postActionText.replace(">","");
      }
      
      // Save current as old skill lvl for logging
      oldSkillLvl = state.playerSkills.lvl[skillIndex];

      // Gain experience in skills, which contributes to leveling them up
      skillExp = randomFloat(0, 0.8);
      log("skillExp: " + skillExp); 

      // Increase the skill's level by the generated experience
      state.playerSkills.lvl[skillIndex] += skillExp;

      // Round the skill level to two decimal places for accuracy and consistency
      state.playerSkills.lvl[skillIndex] = Math.round(state.playerSkills.lvl[skillIndex] * 100) / 100;

      // Save the updated skill data to the storage container
      storeSkillsToSC();


      //Log skill lvl change in skill sc notes
      const skillSC = storyCards.find(sc => sc.title === "Player Skills")   
      skillSC.description = `Log ${state.turnCount} | ${state.playerSkills.name[skillIndex]} gained ${skillExp.toFixed(2)} lvl. Lvl ${oldSkillLvl} => ${state.playerSkills.lvl[skillIndex]}\n` + skillSC.description;

    }//end of has mana
  }
}

// After skill and talent checks, this function detects if the player is performing a heal action and executes the healing process. Defaults to skill healing if both talent and skill healing are available.
function detectTalentSkillHeal(){
  // Player must pass at least one of the talent or skill checks to perform a healing action
  if(talentCheck[0] || skillCheck[0]){
    healingSelf = false;

    //// Check if the player is performing a healing action. Use text b/c inp targetwords were simplified
    healing = cleanStringCheckForTargets(healingActions,text);
    log("healing: " + healing);

    // Check if the player is attempting to heal themselves
    healingSelf = cleanStringCheckForTargets(selfWords,text);
    log("healingSelf: " + healingSelf);

    // If both a healing action and self-healing are detected, proceed with healing based on talent or skill level
    if(healing && healingSelf){
      getLvl = [];

      // If the player has a talent that passed the check, push its level into the getLvl array
      if(talentCheck[0]){
        getLvl.push(state.playerTalents.lvl[talentCheck[2]]);
      }

      // If the player has a skill that passed the check, push its level into the getLvl array
      if(skillCheck[0]){
        getLvl.push(state.playerSkills.lvl[skillCheck[2]]);
      }
      log("getLvl: " + getLvl);
      
      // If only one skill or talent passed, the array will contain one level value.
      // Calculate healing amount based on the single level and heal the player.
      if(getLvl.length == 1){
        healAmt = getLvl[0] * 3;
        log('healAmt: '+ healAmt);
        statUp("hp",healAmt);
        statUp("mp",healAmt);
        statUp("ep",healAmt);
        postActionText = postActionText + " You feel better as you recover some health."
      }
      
      // If both a skill and talent passed, use the skill level for healing (default to skill if both are available)
      if(getLvl.length == 2){
        healAmt = getLvl[1] * 3;
        log('healAmt: '+ healAmt);
        statUp("hp",healAmt);
        statUp("mp",healAmt);
        statUp("ep",healAmt);
        postActionText = postActionText + " You feel better as you recover some health."
      }
    }


  }
}

//Main action function. Checks for "you + actions" that require items, talents, or skills. Checks if player has something to fulfill it and executes it along with text result
function detectPlrActionsCallingStorage(text){
  startAction = false;
  
  // Verify player is not dialoguing (case-insensitive)
  dialogueCheck = true;
  textLower = text.toLowerCase();
  dialoguePhrases.forEach(phrase => {
    if(textLower.includes(phrase.toLowerCase())){
      // Disable check dialoguing exists
      dialogueCheck = false;
    }
  });

  //If player is not dialoguing, check input for action words and split the input
  if(dialogueCheck == true){
    allActionWords = [...castWords,...talentWords,...healingActions];
    plrActionTextInput = [];
    plrActionTextInput = findTargetsThenSplit(text,allActionWords,plrActionTextInput,true);
    console.log("plrActionTextInput simplified: " + plrActionTextInput);

    //If input has action words get their indices
    if(plrActionTextInput != null){
      allActionWordIndices = [];
      allActionWordIndices = indicesOfTargets(plrActionTextInput,allActionWords);
      log("allActionWordIndices:" + allActionWordIndices);

      //Detect if there is  "you + actionword" or "and + actionword"
      if(allActionWordIndices != null){
        startAction = checkYouBeforeIndicesArr(plrActionTextInput,allActionWordIndices,3) || checkAndBeforeIndicesArr(plrActionTextInput,allActionWordIndices,2);
        log("startAction: " + startAction);
      }
    }
  }

  if(startAction == true){
    //Intialize arrays [hasthing,hasfullthing,finalthingindex]
    itemCheck = [false,false,false];
    talentCheck = [false,false,false];
    skillCheck = [false,false,false];
    postActionText = "";
    notEnoughText = "";

    //Check if player storage has thing used in input text available then returns [hasthing, hasfullthing, finalthingindex]
    itemCheck = checkPlayerStorage(text,plrActionTextInput,state.playerInv.item);
    log("itemCheck: " + itemCheck);

    talentCheck = checkPlayerStorage(text,plrActionTextInput,state.playerTalents.name);
    log("talentCheck: " + talentCheck);
    //If player passes talent check, and casted the talent, it registers as skill
    talentCastedToSkill();

    skillCheck = checkPlayerStorage(text,plrActionTextInput,state.playerSkills.name);
    log("skillCheck: " + skillCheck);
    
    // Pipeline order is item>talent>skill
    // If player has the ITEM, get its success or fail text
    if(itemCheck[0]){
      hasAmt = false;
      fullItemMatch = itemCheck[1];
      itemIndex = itemCheck[2];
    }

    // If player has the TALENT, check if they have enough ep, else make reject text
    if(talentCheck[0]){
      fullTalentMatch = talentCheck[1]; 
      talentIndex = talentCheck[2];

      // Check if player energy is enough for the talent
      hasEnergy = state.playerStats.ep >= state.playerTalents.cost[talentIndex];
      console.log("hasEnergy: " + hasEnergy);

      // Create reject talent text if player doesnt have enough energy and revoke check
      if(hasEnergy == false){
        talentCheck[0] = false;
        notEnoughText = notEnoughText + " Suddenly, you realize you dont have enough energy for " + state.playerTalents.name[talentIndex] + ".";
      }
    }//end of has talent

    // If player has the SKILL, check if they have enough mp, else make reject text
    if(skillCheck[0]){
      fullSkillMatch = skillCheck[1]; 
      skillIndex = skillCheck[2];

      // Check if player mana is enough for the skill
      hasMana = state.playerStats.mp >= state.playerSkills.cost[skillIndex];      
      console.log("hasMana: " + hasMana);

      // Create reject skill text if player doesnt have enough mana and revoke check
      if(hasMana == false){
        skillCheck[0] = false;
        notEnoughText = " Suddenly, you realize you don't have enough mana for " + state.playerSkills.name[skillIndex] + ".";
      }

    }//end of has skill

    // If talent and skill are both available, default to using skill so both dont execute together
    if(talentCheck[0] && skillCheck[0]){
      executeSkill();
    }
    // Otherwise execute available action, or do nothing for no actions available
    else{
      executeTalent();
      executeSkill();
    }

    // Checks for healing and executes it. Defaults to skill heal if both talent and skill work
    detectTalentSkillHeal();

    // Finalize action execution by appending text
    if(itemCheck[0]|| talentCheck[0] || skillCheck[0]){
      text = text + postActionText;
      return text;
    }

    // If plr fails all checks, finalize action rejection
    if(!itemCheck[0] && !talentCheck[0] && !skillCheck[0]){
      // Failure Condition 1: plr passed a/all check but then failed all b/c no ep/mp/item amt
      if(notEnoughText.length > 0){
        text = text + notEnoughText;
        return text;
      }
      // Failure Condition 2: nonexistent in storage 
      else{ 
        text = text + ` ${realizePhrases[randomInt(0,realizePhrases.length-1)]} ${becauseYouPhrases[randomInt(0,becauseYouPhrases.length-1)]} ${assumedWrongPhrases[randomInt(0,assumedWrongPhrases.length-1)]}, ${slightlyWorseResults[randomInt(0,slightlyWorseResults.length-1)]}.`
        return text;
      }      
    }


  }//end of start action

  return text;
}

/////////////////////////////////////////////////////////////////////////////////////

//Check if player is first entering, then is entering into rest, and replenish their stats according to their rest intensity
function detectResting(text){
  startRest = false;
  isEntering = false;
    
  // Verify player is not dialoguing (case-insensitive)
  dialogueCheck = true;
  textLower = text.toLowerCase();
  dialoguePhrases.forEach(phrase => {
    if(textLower.includes(phrase.toLowerCase())){
      // Disable check dialoguing exists
      dialogueCheck = false;
    }
  });

  //If player is not dialoguing, check input for enter words and split the input
  if(dialogueCheck == true){
    restingTextInput = []
    restingTextInput = findTargetsThenSplit(text,enterWords,restingTextInput,true);
    console.log("restingTextInput simplified: " + restingTextInput);

    //If input has enter words get their indices
    if(restingTextInput != null){
      allEnterWordsIndices = [];
      allEnterWordsIndices = indicesOfTargets(restingTextInput,enterWords);
      log("allEnterWordsIndices:" + allEnterWordsIndices);

      //Detect if there is  you + enter or and + enter
      if(allEnterWordsIndices != null){
        isEntering = checkYouBeforeIndicesArr(restingTextInput,allEnterWordsIndices,3) || checkAndBeforeIndicesArr(restingTextInput,allEnterWordsIndices,2);
        
        startRest = cleanStringCheckForTargets(restingWords,text);
        log("isEntering: "+ isEntering)
        log("startRest: " + startRest);
      }
    }
  }

  if(isEntering && startRest){
    //Replenish stats based on player rest intensity
    lightRest = cleanStringCheckForTargets(lightRestWords,text);
    moderateRest = cleanStringCheckForTargets(moderateRestWords,text);
    fullRest = cleanStringCheckForTargets(fullRestWords,text);

    if(fullRest){
      statUp("hp", state.playerStats.maxHp * randomFloat(0.6,0.9));
      statUp("ep",state.playerStats.maxEp * randomFloat(0.6,0.9));
      statUp("mp",state.playerStats.maxMp * randomFloat(0.6,0.9));
      text = text + " Your time resting leaves you feeling recovered."
    }
    else if(moderateRest){
      statUp("hp", state.playerStats.maxHp * randomFloat(0.4,0.6));
      statUp("ep",state.playerStats.maxEp * randomFloat(0.4,0.6));
      statUp("mp",state.playerStats.maxMp * randomFloat(0.4,0.6));
      text = text + " Your time resting leaves you feeling better than you were before."

    }
    else if(lightRest){
      statUp("hp", state.playerStats.maxHp * randomFloat(0.2,0.4));
      statUp("ep",state.playerStats.maxEp * randomFloat(0.2,0.4));
      statUp("mp",state.playerStats.maxMp * randomFloat(0.2,0.4));
      text = text + " Your time resting leaves you feeling a bit better."

    }
    else{
      statUp("hp", state.playerStats.maxHp * randomFloat(0.2,0.4));
      statUp("ep",state.playerStats.maxEp * randomFloat(0.2,0.4));
      statUp("mp",state.playerStats.maxMp * randomFloat(0.2,0.4));
      text = text + " Your time resting leaves you feeling more okay."

    }
    
    storeStatsToSC();
  }//end of startresting

  return text;
}

//Detects when player consumes something which heals them.
function detectConsuming(text){
  startConsume = false;
    
  // Verify player is not dialoguing (case-insensitive)
  dialogueCheck = true;
  textLower = text.toLowerCase();
  dialoguePhrases.forEach(phrase => {
    if(textLower.includes(phrase.toLowerCase())){
      // Disable check dialoguing exists
      dialogueCheck = false;
    }
  });

  //If player is not dialoguing, check input for consume words and split the input
  if(dialogueCheck == true){
    consumingTextInput = []
    consumingTextInput = findTargetsThenSplit(text,consumeWords,consumingTextInput,true);
    console.log("consumingTextInput simplified: " + consumingTextInput);

    //If input has consume words get their indices
    if(consumingTextInput != null){
      allConsumeWordsIndices = [];
      allConsumeWordsIndices = indicesOfTargets(consumingTextInput,consumeWords);
      log("allConsumeWordsIndices:" + allConsumeWordsIndices);

      //Detect if there is  you + consume or and + consume
      if(allConsumeWordsIndices != null){
        startConsume = checkYouBeforeIndicesArr(consumingTextInput,allConsumeWordsIndices,3) || checkAndBeforeIndicesArr(consumingTextInput,allConsumeWordsIndices,2);
        log("startConsume: " + startConsume);
      }
    }
  }

  if(startConsume){
    //Verify intensity of player consumable
    lightHeal = cleanStringCheckForTargets(lightHealWords,text);
    moderateHeal = cleanStringCheckForTargets(moderateHealWords,text);
    strongHeal = cleanStringCheckForTargets(strongHealWords,text);
    greatHeal = cleanStringCheckForTargets(greatHealWords,text);
    powerfulHeal = cleanStringCheckForTargets(powerfulHealWords,text);
    log("healIntensity: " + [lightHeal,moderateHeal,strongHeal,greatHeal,powerfulHeal]);

    if(powerfulHeal){
      statUp("hp",100);
      statUp("ep",120);
      text = text + " You feel restored."
    }
    else if(greatHeal){
      statUp("hp",50);
      statUp("ep",80);
      text = text + " You feel greatly better."

    }
    else if(strongHeal){
      statUp("hp",30);
      statUp("ep",40);
      text = text + " You feel a lot better."

    }
    else if(moderateHeal){
      statUp("hp",20);
      statUp("ep",30);
      text = text + " You feel moderately better."

    } 
    else if(lightHeal){
      statUp("hp",10);
      statUp("ep",10);
      text = text + " You feel slightly better."
    }
    
    if(!lightHeal && !moderateHeal && !strongHeal && !greatHeal && !powerfulHeal){
      //default heal
      statUp("hp",5);
      statUp("ep",5)
      text = text + " You feel a bit better."
    }

    storeStatsToSC();
    return text

  }//end of startconsume

  return text;
}

function detectAttack(text){
  startAttack = false;
    
  // Verify player is not dialoguing (case-insensitive)
  dialogueCheck = true;
  textLower = text.toLowerCase();
  dialoguePhrases.forEach(phrase => {
    if(textLower.includes(phrase.toLowerCase())){
      // Disable check dialoguing exists
      dialogueCheck = false;
    }
  });

  //If player is not dialoguing, check input for atk words and split the input
  if(dialogueCheck == true){
    attackTextInput = []
    attackTextInput = findTargetsThenSplit(text,attackWords,attackTextInput,true);
    console.log("attackTextInput simplified: " + attackTextInput);

    //If input has atk words get their indices
    if(attackTextInput != null){
      allAttackWordIndices = [];
      allAttackWordIndices = indicesOfTargets(attackTextInput,attackWords);
      log("allAttackWordIndices:" + allAttackWordIndices);

      //Detect if there is  you + atk or and + atk
      if(allAttackWordIndices != null){
        startAttack = checkYouBeforeIndicesArr(attackTextInput,allAttackWordIndices,3) || checkAndBeforeIndicesArr(attackTextInput,allAttackWordIndices,2);
        log("startAttack: "+ startAttack)
      }
    }
  }

  if(startAttack){
    // Get the player's attack and speed stats
    plrAtk = state.playerStats.atk;
    plrSpd = state.playerStats.spd;

    // Define attack strength ranges with corresponding attack messages
    const atkRanges = [
      { min: 0, max: 10, atk: attackTier1 },
      { min: 10, max: 20, atk: attackTier2 },
      { min: 20, max: 30, atk: attackTier3 },
      { min: 30, max: 40, atk: attackTier4 },
      { min: 40, max: 50, atk: attackTier5 },
      { min: 50, max: 60, atk: attackTier6 },
      { min: 60, max: 70, atk: attackTier7 },
      { min: 70, max: 80, atk: attackTier8 },
      { min: 80, max: 90, atk: attackTier9 },
      { min: 90, max: Infinity, atk: attackTier10 }
    ];


    // Define speed stat ranges with corresponding speed messages
    const spdRanges = [
      { min: 0, max: 10, spd: atkSpdTier1 },
      { min: 10, max: 20, spd: atkSpdTier2 },
      { min: 20, max: 30, spd: atkSpdTier3 },
      { min: 30, max: 40, spd: atkSpdTier4 },
      { min: 40, max: 50, spd: atkSpdTier5 },
      { min: 50, max: 60, spd: atkSpdTier6 },
      { min: 60, max: 70, spd: atkSpdTier7 },
      { min: 70, max: 80, spd: atkSpdTier8 },
      { min: 80, max: 90, spd: atkSpdTier9 },
      { min: 90, max: Infinity, spd: atkSpdTier10 }
    ];


    // Calculate energy requirements for attack
    atkEnergyLoss = (2 * (plrAtk/10) + randomInt(0,5)) * -1;
    if(plrAtk > 100){
      atkEnergyLoss = (20 + plrAtk/25) * -1;
    }
    log("Atk energy loss: " + atkEnergyLoss);

    // Attack energy check defaults to false
    atkEnergyCheck = false;
    // If player has enough energy, turn on check
    if (state.playerStats.ep >= Math.abs(atkEnergyLoss) && state.playerStats.ep >= 0) {
      atkEnergyCheck = true;
    }
    log("atkEnergyCheck: " + atkEnergyCheck);

    // If player does not have enough energy to attack
    if(!atkEnergyCheck){
      text = text + ` You are too exhausted to attack.`
      //todo: expand text
    }

    // If player has enough energy to attack, execute the attack
    if (atkEnergyCheck) {
      // Check the player's speed range and create a message based on their speed
      for (let range of spdRanges) {
        if (plrSpd >= range.min && plrSpd < range.max) {
          // Append the speed message to the attack text
          text = text + ` ${range.spd[randomInt(0, range.spd.length - 1)]}`;

          // Attacking grants SPD exp
          statUp("spd", randomFloat(0.01, 1));
          break;
        }
      }

      // Check the player's attack range/strength, check energy requirement, and save attack text
      for (let range of atkRanges) {
        if (plrAtk >= range.min && plrAtk < range.max) {
          // Save the attack message based on the attack strength
          text = text + ` and ${range.atk[randomInt(0, range.atk.length - 1)].toLowerCase()}`;

          // Attacking grants ATK exp
          statUp("atk", randomFloat(0.01, 1));

          break;
        }
      }

      // Apply energy loss from attack
      statUp("ep", atkEnergyLoss);

      // Determine if the attack has a luck modifier
      atkLuckRoll = randomInt(1, 100); // Generate a random luck roll between 1 and 100
      log("atkLuckRoll: " + atkLuckRoll); // Log the luck roll for debugging

      if (atkLuckRoll <= state.playerStats.lck && atkLuckRoll >= 1) {
        // If the luck roll is within the player's luck range, append a lucky phrase to the text
        text = text + ` ${graspPhrases[randomInt(0, graspPhrases.length - 1)]} ${luckyPhrases[randomInt(0, luckyPhrases.length - 1)]}.`;

        //Grant the player luck exp for using luck
        statUp("lck", randomFloat(0.01, 1));
      }


      storeStatsToSC();
    } // End of has atk energy
  } // End of startAttack

  return text;
}

/////////////////////////////////////////////////////////////////////////////////////

// Function to check if the output contains any "hurt" words or patterns, and if so, apply damage to the player's stats
function testHurt(hurtType, dmg, text) {
  // Loop through all the regex patterns in hurtType to detect any matching "hurt" words in the output text
  const matchedPattern = hurtType.find(pattern => pattern.test(text));

  // If a hurt word is found, apply damage to the player's HP and increase the DEF stat
  if (matchedPattern) {
    // Apply damage to the player's HP stat
    statUp("hp", dmg);   
    
    // Find the "Player Stats" card to log the damage information
    const statSC = storyCards.find(sc => sc.title === "Player Stats");

    // Match the text with the pattern and fetch the matching portion (if any)
    const matchText = text.match(matchedPattern);

    // If the "Player Stats" card exists and we have matched text, log the damage details
    if (statSC && matchText) {
      // Add a new log entry to the Player Stats card, indicating the output count and damage reason
      statSC.description = `Log ${state.turnCount} | Dmg Reason: ${matchText}\n` + statSC.description;

      // Log the percentage of damage reduction based on the player's DEF stat
      statSC.description = `Log ${state.turnCount} | Dmg Reduced by DEF: ${((1 - dmgPercent) * 100).toFixed(2)}% (${(dmg/dmgPercent).toFixed(2)} ‚Üí ${dmg.toFixed(2)})\n` + statSC.description;
    }

    // Applying damage triggers an increase in the player's DEF stat as a form of experience
    statUp("def", randomFloat(0.01, 1));

    // Store updated player stats to the game state
    storeStatsToSC(); 
  }
}

// Function to check output if player got damaged and applies hp dmg to stats
function detectHurt(text){

  //todo: fix so plr doesnt get dmged when about to dmg instead, use array?
  //Pain that can be brushed off
  lightHurtWords = [
    //Ex: Scraping you/your body
    new RegExp(`\\b(?:bump|bumps|bumping|bruise|bruised|bruising|graze|grazed|grazes|grazing|nick|nicked|nicking|nicks|scorching|scorched|scorches|scrape|scraped|scrapes|scraping|singeing|singes|sting|stinging|stings)(?:\\s+\\w+){0,4}\\s+(?:you|your)(?:\\s+\\w+){0,5}\\s+(?:${bodyParts.join("|")})\\b`, "i"),

    //Ex: You feel throbbing
    new RegExp(`\\byou(?:\\s+\\w+){0,3}\\s+feel(?:\\s+\\w+){0,5}\\s+(?:ache|aching|bruise|bruising|bruised|sting|stinging|throb|throbbing)\\b`, "i"),

    //Ex: You stumble back
    new RegExp(`\\byou(?:\\s+\\w+){0,3}\\s+(?:fall|falling|falls|fell|stumble|stumbled|stumbles|stumbling|trip|tripping|trips|tumbled)(?:\\s+\\w+){0,3}\\s+(?:against|around|back|backward|down|forward|into|on|off|over|sideways|towards)\\b`, "i"),

    //Ex: The pain is throbbing
    new RegExp(`\\bThe(?:\\s+\\w+){0,3}\\s+pain(?:\\s+\\w+){0,4}\\s+(?:throbbing)\\b`, "i")

  ];

  //Pain that hurts or lightly draws blood
  moderateHurtWords = [
    //Ex: slicing you/your body
    new RegExp(`\\b(?:bite|biting|bites|burn|burning|burns|catches|catching|dig|digs|digging|hit|hitting|hits|jab|jabbing|jabs|knock|knocked|knocking|sear|sears|searing|shock|shocking|shocks|strike|strikes|striking|struck|whack|whacked|whacking|whacks)(?:\\s+\\w+){0,3}\\s+(?:you|your)(?:\\s+\\w+){0,5}\\s+(?:${bodyParts.join("|")})\\b`, "i"),

    //Ex: sends you crashing
    new RegExp(`\\b(?:send|sending|sends)(?:\\s+\\w+){0,3}\\s+you(?:\\s+\\w+){0,5}\\s+(?:crumpling|crashing|flailing|reeling|skidding|slamming|smashing|sprawling|toppling|tumbling)\\b`, "i"),

    //Ex: The pain is burning
    new RegExp(`\\bThe(?:\\s+\\w+){0,3}\\s+pain(?:\\s+\\w+){0,4}\\s+(?:burning|searing)\\b`, "i")

  ];

  //Pain that is drawing average blood or internal dmg
  strongHurtWords = [
    //Ex: piercing you/your body
    new RegExp(`\\b(?:agony|agonizing|batter|battered|battering|collide|collides|fling|flinging|flung|pierce|pierced|pierces|piercing|slam|slams|slammed|slamming|slice|slices|sliced|slicing|shoot|shooting|shoots|slash|slashes|slashed|slashing|gashes)(?:\\s+\\w+){0,3}\\s+(?:you|your)(?:\\s+\\w+){0,5}\\s+(?:${bodyParts.join("|")})\\b`, "i"),

    //Ex: The pain is excrutiating
    new RegExp(`\\bThe(?:\\s+\\w+){0,3}\\s+pain(?:\\s+\\w+){0,4}\\s+(?:agonizing|blistering|blinding|extreme|gnawing|gripping|horrible|immediate|intense|piercing|radiating|sharp|shooting|stabbing|tremendous|unbearable)\\b`, "i")


  ];

  //Pain that is significantly drawing blood
  greatHurtWords = [
    //Ex: Blasting you/your body
   new RegExp(`\\b(?:blasts|blasted|blasting|explodes|exploding|fractures|fractured|fracturing|impale|impales|impaled|impaling|pierce|pierces|pierced|piercing|rip|rips|ripped|ripping|shred|shreds|shredded|shredding|tear into|tears into|tearing into|tore|torn)(?:\\s+\\w+){0,3}\\s+(?:you|your)(?:\\s+\\w+){0,5}\\s+(?:${bodyParts.join("|")})\\b`, "i")
  ];

  //Pain that is debilitating
  severeHurtWords = [
    //Ex: Crushing you/your body
    new RegExp(`\\b(?:crush|crushes|crushed|crushing|demolish|demolishes|demolished|demolishing|devastate|devastates|devastated|devastating|obliterate|obliterates|obliterated|obliterating|rupture|ruptures|ruptured|rupturing|shatter|shatters|shattered|shattering|splinter|splinters|splintered|splintering)(?:\\s+\\w+){0,3}\\s+(?:you|your)(?:\\s+\\w+){0,5}\\s+(?:${bodyParts.join("|")})\\b`, "i")
  ];

  //Initialize dmg values and defense reduction
  df = state.playerStats.def;
  
  // X def reduces X/2 % dmg
  if(df <= 100){
    dmgPercent = 1 - (df/200); //Ex: Def: 90, 1 - 0.45 = 0.55 dmg taken
  }
  //Past 100 def reduces 50% + (~1% per 10 def) dmg
  else if(df > 100){
    dmgPercent = 1 - (-0.25 + 0.161 * Math.log(df));
  }
  log("dmgPercent: " + dmgPercent);

  // Randomize and save damage for each dmg intensity
  severeDmg = -1 * randomFloat(25,40) * dmgPercent;
  greatDmg = -1 * randomFloat(15,25) * dmgPercent;
  strongDmg = -1 * randomFloat(5,15) * dmgPercent;
  moderateDmg = -1 * randomFloat(3,5) * dmgPercent;
  lightDmg = -1 * randomFloat(0.1,3) * dmgPercent;

  //Loop through each regex, if output text matches damage text, apply damage
  testHurt(severeHurtWords,severeDmg,text);
  testHurt(greatHurtWords,greatDmg,text);
  testHurt(strongHurtWords,strongDmg,text);
  testHurt(moderateHurtWords,moderateDmg,text);
  testHurt(lightHurtWords,lightDmg,text);

  return text;
}

/////////////////////////////////////////////////////////////////////////////////////

// Function to detect when the player attempts to dodge
function detectDodge(text){
  startDodge = false;
  
  // Verify player is not dialoguing (case-insensitive)
  dialogueCheck = true;
  textLower = text.toLowerCase();
  dialoguePhrases.forEach(phrase => {
    if(textLower.includes(phrase.toLowerCase())){
      // Disable check dialoguing exists
      dialogueCheck = false;
    }
  });

  // If the player is not in dialogue, check if the input contains any dodge-related words
  if(dialogueCheck == true){
    dodgeTextInput = [];
    
    // Find all the dodge-related words in the text and split the input accordingly
    dodgeTextInput = findTargetsThenSplit(text, dodgeWords, dodgeTextInput, true);
    console.log("dodgeTextInput simplified: " + dodgeTextInput);

    // If the input contains dodge words, find their indices in the text
    if(dodgeTextInput != null){
      allDodgeWordIndices = [];
      allDodgeWordIndices = indicesOfTargets(dodgeTextInput, dodgeWords);
      log("allDodgeWordIndices:" + allDodgeWordIndices);

      // Check if the sentence contains "you + dodge" or "and + dodge" to trigger the dodge action
      if(allDodgeWordIndices != null){
        startDodge = checkYouBeforeIndicesArr(dodgeTextInput, allDodgeWordIndices, 3) || checkAndBeforeIndicesArr(dodgeTextInput, allDodgeWordIndices, 2);
        log("startDodge: "+ startDodge)
      }
    }
  }

  // If the dodge action is triggered (startDodge is true), calculate the player's dodge response based on SPD stat
  if(startDodge){
    plrSpd = state.playerStats.spd;

    // Define SPD stat ranges and corresponding dodge messages
    const spdRanges = [
      { min: 0, max: 10, spd: spdTier1 },
      { min: 10, max: 20, spd: spdTier2 },
      { min: 20, max: 30, spd: spdTier3 },
      { min: 30, max: 40, spd: spdTier4 },
      { min: 40, max: 50, spd: spdTier5 },
      { min: 50, max: 60, spd: spdTier6 },
      { min: 60, max: 70, spd: spdTier7 },
      { min: 70, max: 80, spd: spdTier8 },
      { min: 80, max: 90, spd: spdTier9 },
      { min: 90, max: Infinity, spd: spdTier10 }
    ];

    
    // Calculate energy requirements for dodging
    dodgeEnergyLoss = (2 * (plrSpd/10) + randomInt(0,5)) * -1;
    if(plrSpd > 100){
      dodgeEnergyLoss = (20 + plrSpd/25) * -1;
    }
    log("dodgeEnergyLoss: " + dodgeEnergyLoss);

    // Dodge energy check defaults to false
    dodgeEnergyCheck = false;
    // If player has enough energy, turn on check
    if (state.playerStats.ep >= Math.abs(dodgeEnergyLoss) && state.playerStats.ep >= 0) {
      dodgeEnergyCheck = true;
    }
    log("dodgeEnergyCheck: " + dodgeEnergyCheck);

    // If player doesnt have enough energy to dodge
    if(dodgeEnergyCheck == false){
      text = text + `You realize you don't have enough energy to do so.`
      //todo: diversify text
    }

    // If player has enough energy to dodge, execute dodge
    if(dodgeEnergyCheck){
      // Based on the player's SPD stat, select an appropriate dodge message and save dodge text
      for (let range of spdRanges) {
        if (plrSpd >= range.min && plrSpd < range.max) {
          // Save dodge text based on player SPD stat
          spdText = ` ${range.spd[randomInt(0, range.spd.length - 1)]}`;

          break;
        }
      }

      text = text + spdText;

      //Consume energy for dodging
      statUp("ep",dodgeEnergyLoss);

      // Dodging grants SPD stat
      statUp("spd", randomFloat(0.01, 1));

      // Check if the player's luck allows for a successful dodge based on their LCK stat
      dodgeLuckRoll = randomInt(1, 100);
      log("dodgeLuckRoll: " + dodgeLuckRoll);

      // If the player's luck stat rolls successfully, append a lucky dodge message
      if (dodgeLuckRoll <= state.playerStats.lck && dodgeLuckRoll >= 1) {
        text = text + ` ${graspPhrases[randomInt(0, graspPhrases.length - 1)]} ${luckyPhrases[randomInt(0, luckyPhrases.length - 1)]}.`;

        //Grant the player luck exp for using luck
        statUp("lck", randomFloat(0.01, 1));
      }

      storeStatsToSC();
    }// End of dodgeEnergyCheck
  } // End of startDodge check

  return text;
}

// Function that detects when a player looks around the environment and, based on their INTL stat, affects the level of detail in the results displayed to the player.
function detectScout(text){
  startScout = false;
  
  // Verify player is not dialoguing (case-insensitive)
  dialogueCheck = true;
  textLower = text.toLowerCase();
  dialoguePhrases.forEach(phrase => {
    if(textLower.includes(phrase.toLowerCase())){
      // Disable check dialoguing exists
      dialogueCheck = false;
    }
  });

  // If the player isn't dialoguing, proceed to check for scout-related words
  if(dialogueCheck == true){
    scoutTextInput = [];
    
    // Find scout-related words within the input and split the input accordingly
    scoutTextInput = findTargetsThenSplit(text, scoutWords, scoutTextInput, true);
    console.log("scoutTextInput simplified: " + scoutTextInput);

    // If the input contains scout words, find their indices in the text
    if(scoutTextInput != null){
      allScoutWordIndices = [];
      allScoutWordIndices = indicesOfTargets(scoutTextInput, scoutWords);
      log("allScoutWordIndices:" + allScoutWordIndices);

      // Check if the sentence starts with "you + scout" or "and + scout" to trigger scouting action
      if(allScoutWordIndices != null){
        startScout = checkYouBeforeIndicesArr(scoutTextInput, allScoutWordIndices, 3) || checkAndBeforeIndicesArr(scoutTextInput, allScoutWordIndices, 2);
        log("startScout: "+ startScout)
      }
    }
  }

  // If the scouting action is triggered (startScout is true), process the INTL stat to provide results
  if(startScout){
    plrIntl = state.playerStats.intl;

    // Define the ranges of INTL stat and the corresponding messages that will be shown to the player
    const detailRanges = [
      { min: 0, max: 10, msg: detail1 },
      { min: 10, max: 20, msg: detail2 },
      { min: 20, max: 30, msg: detail3 },
      { min: 30, max: 40, msg: detail4 },
      { min: 40, max: 50, msg: detail5 },
      { min: 50, max: 60, msg: detail6 },
      { min: 60, max: 70, msg: detail7 },
      { min: 70, max: 80, msg: detail8 },
      { min: 80, max: 90, msg: detail9 },
      { min: 90, max: Infinity, msg: detail10 }
    ];

    // Iterate through the defined ranges to find the appropriate level of detail based on the player's INTL stat
    for (let range of detailRanges) {
      if (plrIntl >= range.min && plrIntl < range.max) {
        // Add the relevant detail message to the text
        text = text + ` ${range.msg[randomInt(0, range.msg.length - 1)]}`;

        // Award the player INTL experience for successfully performing a scout action
        statUp("intl", randomFloat(0.01, 0.5));
        break; // Stop checking once the correct range is found
      }
    }

    // Check for the possibility of a lucky scout action based on the player's luck stat
    scoutLuckRoll = randomInt(1, 100);
    log("scoutLuckRoll: " + scoutLuckRoll);

    if(scoutLuckRoll <= state.playerStats.lck && scoutLuckRoll >= 1){
      // If the luck roll is successful, add a lucky phrase to the result
      text = text + ` ${graspPhrases[randomInt(0, graspPhrases.length - 1)]} ${luckyPhrases[randomInt(0, luckyPhrases.length - 1)]}.`;

      //Grant the player luck exp for using luck
      statUp("lck",randomFloat(0.01,1));
    }

    storeStatsToSC();
  } // End of startScout
  
  return text;
}


//persistent injuries
//race evos
//add random skill learning, make it context based
//spiritualism increases luck
//buff and debuff
//inventory sys, buy and sell detection
//detect boost luck
//detect boost def
//fix inv sys





// Your other library scripts go here
// === Shared Library: Universal Reputation System (URS) + Mini Language Engine (MLE) ===
// === Credit & Collaboration ===
// This engine was built in collaboration with Lothens, whose Personal Reputation Tracker formed a core part of the system‚Äôs design.
// It also incorporates the Mini Language Engine (MLE) originally developed by LewdLeah, enabling dynamic narrative behavior and prose consistency.
// Deep thanks to both creators for their contributions‚Äîthis system would not exist without their foundational work.

// --- DEFAULTS ---
// --- DEFAULTS ---
const DEFAULT_FACTIONS = {}; // <-- Users define their own factions. ALWAYS REMEMBER TO SET UP FACTIONS! 

const DEFAULT_REPUTATION = {
  global: 0,
  categories: {
    warlike: 0,
    diplomatic: 0,
    merciful: 0,
    ruthless: 0,
    noble: 0,
    deceptive: 0
  }
};

const REPUTATION_CATS = [
  "Charmer", "Honorable", "Rogue", "Dominant", "Submissive", "Prankster",
  "Curious", "Innocent", "Mischievous", "Affectionate", "Defiant",
  "Brave", "Clever", "Playful"
];


// --- INIT ---
function initWorldReputation(state) {
  if (!state.reputation) state.reputation = { global: 0 };
  if (!state.factions) state.factions = { ...DEFAULT_FACTIONS };
}

function initPersonalReputation(state) {
  if (!state.reputation) state.reputation = {};
  for (const cat of REPUTATION_CATS) {
    if (typeof state.reputation[cat] !== "number") {
      state.reputation[cat] = 0;
    }
  }
}

// --- LEXICON: World Reputation Tags ---
const URT_LEXICON = {
  warlike: [/\battack\b/i, /\bdestroy\b/i, /\braid\b/i, /\bbombard\b/i, /\bexecute\b/i],
  diplomatic: [/\bnegotiate\b/i, /\bparley\b/i, /\btreaty\b/i, /\balliance\b/i, /\bsurrender\b/i],
  merciful: [/\bspare\b/i, /\bheal\b/i, /\bsave\b/i, /\bprotect\b/i, /\brescue\b/i],
  deceitful: [/\blie\b/i, /\btrick\b/i, /\bdeceive\b/i, /\bcon\b/i, /\bmanipulate\b/i],
  honorable: [/\boath\b/i, /\bswear\b/i, /\bhonor\b/i, /\bjustice\b/i, /\btruth\b/i],
  threatening: [/\bthreaten\b/i, /\bwarn\b/i, /\bintimidate\b/i]
};

// --- LEXICON: Personal Reputation Tags ---
const PERSONAL_REP_PATTERNS = [
    // ü¶∏ Big Heroics (Huge Boosts)
    { regex: /\b(dove in front of (the|a) blade|pushed (someone|them|a child) out of harm's way|threw (them|someone|a child) to safety|shielded (them|someone|the innocent)|leapt to save|saved (a|the) life|risked (your|his|her|their) life for|stood between (danger|the attacker|the mob) and (someone|them)|took a blow meant for)\b/i, changes: { Honorable: 3, Brave: 3, Charmer: 2 } },

    // ‚öñÔ∏è Justice Served (Public Deeds)
    { regex: /\b(brought a murderer to justice|saved (the|a) town|publicly pardoned (an|the) accused|intervened to prevent (a|an) execution|forgave a sworn enemy|stopped a public duel|spared (the|an) enemy in front of all)\b/i, changes: { Honorable: 4, Charmer: 1, Dominant: 1 } },

    // ü§ù Selfless Sacrifice
    { regex: /\b(sacrificed (your|his|her|their) fortune for|gave up (your|his|her|their) claim for|renounced (a|the) title for another|chose exile for the sake of|gave away (all|most of) your gold|donated a lifesaving invention|chose poverty to protect)\b/i, changes: { Honorable: 4, Charmer: 2, Submissive: 1 } },

    // ü¶Å Fearless Stand
    { regex: /\b(stood alone against overwhelming odds|defied (the|a) mob|refused to bow to a tyrant|faced (certain )?death without fear|publicly challenged (the|a) corrupt official|stood your ground against)\b/i, changes: { Brave: 4, Honorable: 2, Dominant: 2 } },

    // üß† Great Ingenuity (Innovation/Rescue)
    { regex: /\b(invented a device that saved lives|engineered a solution in crisis|built a bridge to rescue|created a cure in secret|outsmarted (the|a) villain with a new invention)\b/i, changes: { Clever: 3, Honorable: 2, Brave: 1 } },

    // ü¶π Heinous Betrayal
    { regex: /\b(betrayed a comrade|sold out (a|the) cause for gold|left (them|someone) to die|turned traitor for coin|struck down an innocent|conspired to assassinate|plotted to overthrow (the|a) leader)\b/i, changes: { Honorable: -5, Rogue: 5, Dominant: 2 } },

    // üòà Public Atrocity
    { regex: /\b(burned a village|slaughtered prisoners|executed (a|the) child|committed (murder|atrocity) in public|ordered a massacre|condemned (the|a) innocent|forced a confession by torture)\b/i, changes: { Honorable: -5, Rogue: 3, Dominant: 3 } },

    // üó°Ô∏è Ruthless Ambition
    { regex: /\b(ousted (your|his|her|their) rival by poison|framed (a|the) innocent|blackmailed (the|a) magistrate|forced (the|a) family into ruin|stole a fortune under (the|a) truce|bribed (the|a) official for power)\b/i, changes: { Rogue: 4, Dominant: 2, Honorable: -3 } },

    // üí£ Rebellion & Treason (Negative)
    { regex: /\b(incited (the|a) riot|led a rebellion for personal gain|betrayed (your|his|her|their) oath|collaborated with enemies of the crown|joined a coup for gold)\b/i, changes: { Rogue: 4, Defiant: 3, Honorable: -3 } },

  
  // === üß° Charmer (positive & awkward/negative) ===
  { regex: /\b(smile(?:s|d)?|grin(?:s|ned)?|blush(?:es|ed)?|flirt(?:s|ed|ing)?|gaze(?:s|d)?|wink(?:s|ed)?|affection(?:ate)?|charm(?:s|ed)?|caress(?:es|ed)?|stroke(?:s|d)?|calls [\w]+ (dear|love|sweetheart|handsome|beautiful)|sweetheart|darling|beloved|snuggle(?:s|d)?)\b/i, changes: { Charmer: 5 } },
  { regex: /\b(sweetheart|darling|dear|beloved|precious|spoil(?:s|ed)?|pamper(?:s|ed|ing)?|dote(?:s|d)? on|face lights up|glows with joy|beaming smile|eyes sparkle|affectionately|gently|tenderly|warmly|holds hands?|embrace(?:s|d)?|cradle(?:s|d)?|non-verbal affection|holds gaze|light touch|brushed hair back|leans in|rest(?:s|ed)? head on|shared a smile|soft voice|gentle laugh|met (your|their) eyes|whispers softly|lively banter|compliments?|flatters?|sweet talk|offers? a rose|makes? a heart sign|friendly wink|friendly pat|wins? over)\b/i, changes: { Charmer: 5 } },
  { regex: /\b(twiddle(?:s|ed)? (fingers|feet))\b/i, changes: { Innocent: 50 } },
  { regex: /\b(stare(?:s|ed)? dirty)\b/i, changes: { Innocent: -50 } },
  { regex: /\b(You make a plus Charmer emote)\b/i, changes: { Charmer: 50 } },
  { regex: /\b(You make a minus Charmer emote)\b/i, changes: { Charmer: -50 } },

  { regex: /\b(You make a plus Honorable emote)\b/i, changes: { Honorable: 50 } },
  { regex: /\b(You make a minus Honorable emote)\b/i, changes: { Honorable: -50 } },

  { regex: /\b(You make a plus Rogue emote)\b/i, changes: { Rogue: 50 } },
  { regex: /\b(You make a minus Rogue emote)\b/i, changes: { Rogue: -50 } },

  { regex: /\b(You make a plus Dominant emote)\b/i, changes: { Dominant: 50 } },
  { regex: /\b(You make a minus Dominant emote)\b/i, changes: { Dominant: -50 } },

  { regex: /\b(You make a plus Submissive emote)\b/i, changes: { Submissive: 50 } },
  { regex: /\b(You make a minus Submissive emote)\b/i, changes: { Submissive: -50 } },

  { regex: /\b(You make a plus Prankster emote)\b/i, changes: { Prankster: 50 } },
  { regex: /\b(You make a minus Prankster emote)\b/i, changes: { Prankster: -50 } },

  { regex: /\b(You make a plus Curious emote)\b/i, changes: { Curious: 50 } },
  { regex: /\b(You make a minus Curious emote)\b/i, changes: { Curious: -50 } },

  { regex: /\b(You make a plus Innocent emote)\b/i, changes: { Innocent: 50 } },
  { regex: /\b(You make a minus Innocent emote)\b/i, changes: { Innocent: -50 } },

  { regex: /\b(You make a plus Mischievous emote)\b/i, changes: { Mischievous: 50 } },
  { regex: /\b(You make a minus Mischievous emote)\b/i, changes: { Mischievous: -50 } },

  { regex: /\b(You make a plus Affectionate emote)\b/i, changes: { Affectionate: 50 } },
  { regex: /\b(You make a minus Affectionate emote)\b/i, changes: { Affectionate: -50 } },

  { regex: /\b(You make a plus Defiant emote)\b/i, changes: { Defiant: 50 } },
  { regex: /\b(You make a minus Defiant emote)\b/i, changes: { Defiant: -50 } },

  { regex: /\b(You make a plus Brave emote)\b/i, changes: { Brave: 50 } },
  { regex: /\b(You make a minus Brave emote)\b/i, changes: { Brave: -50 } },

  { regex: /\b(You make a plus Clever emote)\b/i, changes: { Clever: 50 } },
  { regex: /\b(You make a minus Clever emote)\b/i, changes: { Clever: -50 } },

  { regex: /\b(You make a plus Playful emote)\b/i, changes: { Playful: 50 } },
  { regex: /\b(You make a minus Playful emote)\b/i, changes: { Playful: -50 } },

  { regex: /\b(thank you|thanks a lot|that means a lot|I appreciate it|I'm grateful|I'm glad you're here)\b/i, changes: { Honorable: 5, Charmer: 5 } },
  { regex: /\b(you're amazing|I like you|you‚Äôre cool|you‚Äôre fun to be around|you're special|I care about you|I trust you)\b/i, changes: { Charmer: 5 } },
  { regex: /\b(don't worry|I'll protect you|you're safe with me|I'm not leaving you|you're not alone)\b/i, changes: { Charmer: 5, Honorable: 5 } },
  { regex: /\b(join my crew|follow me|I lead|I'm in charge|I‚Äôve got this|leave it to me|let‚Äôs do this together)\b/i, changes: { Dominant: 5, Brave: 5 } },
  { regex: /\b(I won‚Äôt back down|no matter what|we‚Äôll fight together|not giving up)\b/i, changes: { Brave: 5, Honorable: 5 } },
  { regex: /\b(are you okay\??|do you need anything\??|here, eat this|drink some water|you need rest|let me help you)\b/i, changes: { Honorable: 5, Parental: 5 } },
  { regex: /\b(don't overdo it|take it slow|you‚Äôre still healing|you've done enough for today)\b/i, changes: { Parental: 5, Charmer: 5 } },
 { regex: /\b(I mean it|I'm serious|believe me|I'm telling the truth|listen to me|hear me out)\b/i, changes: { Honorable: 5 } },
  { regex: /\b(don't lie to me|are you kidding me\??|what the hell|seriously\??|you can't be serious|give me a break)\b/i, changes: { Defiant: 5 } },
  { regex: /\b(I just wanted to help|I'm trying my best|I didn't mean to|I care about you|I was scared)\b/i, changes: { Honorable: 5, Charmer: 5, Innocent: 5 } },
 { regex: /\b(I did it for (love|you|family)|because I had to|I had no choice|for the greater good|to protect (you|them|my home))\b/i, changes: { Honorable: 5, Brave: 5 } },
  { regex: /\b(because I was angry|out of spite|to prove a point|to get even)\b/i, changes: { Defiant: 2, Rogue: 1 } },
  { regex: /\b(I was curious|I had to know|it looked interesting|couldn't resist)\b/i, changes: { Curious: 5 } },
  { regex: /\b(with a soft smile|his voice trembled|eyes welled up|she whispered|gripping the edge)\b/i, changes: { Charmer: 5, Honorable: 5 } },
  { regex: /\b(clenched his fists|gritted her teeth|slammed a hand|shouted in anger|stormed off)\b/i, changes: { Defiant: 2, Dominant: 1 } },
  { regex: /\b(sighed heavily|looked away|bit her lip|nervously fidgeted|hands shaking)\b/i, changes: { Submissive: 1, Innocent: 1 } },
  { regex: /\b(stood by (his|her|their) side|walked beside (them|you)|offered comfort|checked on (them|you))\b/i, changes: { Honorable: 5, Affectionate: 5 } },
  { regex: /\b(refused to leave|grabbed their arm|held them back|pleaded with)\b/i, changes: { Brave: 5, Charmer: 5 } },
  { regex: /\b(insulted (them|you)|dismissed (them|you)|ignored their plea|walked away coldly)\b/i, changes: { Rogue: 2, Honorable: -1 } },
  { regex: /\b(thought ahead|weighed the options|noticed the flaw|predicted the move|spotted the trap)\b/i, changes: { Clever: 5 } },
  { regex: /\b(lined up the pieces|put it together|found a loophole|used misdirection|reverse engineered)\b/i, changes: { Clever: 5, Prankster: 5 } },


  // Charmer, era/setting flavor
  { regex: /\b(bows? elegantly|offers? a gloved hand|kisses? the back of a hand|presents? a flower|calls? you enchanting|bestows? a favor|sings? your praises|courts?|writes? a poem for|shares? a waltz|gives? a gallant nod|toasts? to your health|offers? a dance)\b/i, changes: { Charmer: 5 } },
  // Charmer (awkward/negative)
  { regex: /\b(awkward compliment|flirted and failed|creepy smile|unwelcome touch|makes it weird|stares too long|fumbles a compliment|tries too hard|calls someone (honey|babe) uninvited)\b/i, changes: { Charmer: -1 } },

  // === üõ°Ô∏è Honorable (positive & negative) ===
  { regex: /\b(thank(?:s| you)?|offers?|protect(?:s|ed)?|defend(?:s|ed)?|stand(?:s)? up(?: for)?|apolog(?:y|ize(?:s|d)?)|rescues?|generous|fair(?:ly)?|grants?|keeps? promise|truth(?:ful)?|gentle|grateful|selfless|provides?|looks after|respects?|keeps? their word|acts? with integrity|loyal|offers? honest advice|mediates?|takes? the blame|refuses? to cheat|tells? the truth|shows? mercy|refuses? bribe|restores? order|speaks? up for others|pays? a debt|returns? lost property)\b/i, changes: { Honorable: 5 } },
  // Honorable, era/setting flavor
  { regex: /\b(draws? a line|gives? their oath|swears? on (family|honor|ancestors|the gods)|bows? to elders|offers? a seat|stands vigil|defends? the innocent|duels? for justice|judges? fairly|declines? a bribe|stands? for tradition)\b/i, changes: { Honorable: 5 } },
  // Honorable (negative/antithetical)
  { regex: /\b(breaks? a promise|lies?|betrays?|cheats?|acts selfishly|takes? unfair advantage|lets? others down|abandons? a friend|accepts? bribe|frames? an innocent|steals? credit|ignores? suffering|acts dishonorably|cowardly|double-cross(?:es|ed)?|takes? the easy way out)\b/i, changes: { Honorable: -1 } },

  // === ü¶ù Rogue (positive & negative) ===
  { regex: /\b(lie(?:s|d)?|steal(?:s|ing)?|cheat(?:s|ed)?|trick(?:s|ed)?|deceiv(?:es|ed)?|manipulat(?:es|ed)?|sneak(?:s|ed)?|smuggle(?:s|d)?|risky|selfish|betray(?:s|ed)?|sell out|backstab(?:s|bed)?|plots?|frames?|betrays trust|sabotag(?:es|ed)?|coldly walks away|spiteful|acts behind back|shifty|forges? a signature|slinks? away|smirks?|smokescreen|forged?|uses? a fake name|stole|swindled)\b/i, changes: { Rogue: 5, Honorable: -1 } },
  // Rogue, era/setting flavor
  { regex: /\b(cuts? a purse|picks? a lock|fakes? illness|hides? in shadows|dodges? the law|palm(?:s|ed)? an object|slips? away unseen|tells? a tall tale|uses? a code word|forges? a document)\b/i, changes: { Rogue: 5 } },
  // Rogue (negative/antithetical)
  { regex: /\b(caught red-handed|caught stealing|gets? caught lying|exposed for cheating|confesses? under pressure|too honest to bluff|sells? out a friend)\b/i, changes: { Rogue: -5 } },

  // === üëë Dominant (positive & negative) ===
  { regex: /\b(order(?:s|ed)?|command(?:s|ed)?|grab(?:s|bed)? control|takes? charge|intimidat(?:es|ed)?|dominate(?:s|d)?|demands?|assert(?:s|ed)?|forces?|claim(?:s|ed)? authority|interrogates?|commands attention|takes the lead|issues ultimatum|sets the terms|makes demands|overrules objections|pushes forward|bosses? around|talks? over|interrupts?|shuts down dissent|leads? the charge|walks? ahead)\b/i, changes: { Dominant: 5, Submissive: -1 } },
  // Dominant, era/setting flavor
  { regex: /\b(declares? law|presides? over|draws? a line in the sand|dictates? terms|calls? for order|addresses? the crowd|steps? up first|claims? victory|ushers? everyone out|proclaims? leadership|announces? intent)\b/i, changes: { Dominant: 5 } },
  // Dominant (negative/antithetical)
  { regex: /\b(bullies?|abuses? power|shouts? others down|acts tyrannical|oversteps? bounds|ignores? advice|rejects? help|makes? arbitrary rule|forces? submission)\b/i, changes: { Dominant: -1 } },

  // === üôá Submissive (positive & negative) ===
  { regex: /\b(follow(?:s|ed)?|submit(?:s|ted)?|obey(?:s|ed)?|defer(?:s|red)?|yield(?:s|ed)?|agrees? softly|backs? down|accept(?:s|ed)? direction|reluctant(?:ly)? agrees?|tears up|lowers gaze|nods silently|quietly agrees|lets them win|whispers consent|backs off|lets? others decide|sits? quietly|bows? head|lets? someone else speak|agrees? with hesitation|steps? aside|asks? for permission)\b/i, changes: { Submissive: 5, Dominant: -1 } },
  // Submissive, era/setting flavor
  { regex: /\b(bows? deeply|serves? tea|offers? seat|waits? their turn|accepts? their role|kneels?|curtsies?|removes? hat respectfully|humbles? themselves|asks? to be excused)\b/i, changes: { Submissive: 5 } },
  // Submissive (negative/antithetical)
  { regex: /\b(defies? order|stands? up for self|refuses? to back down|contradicts? authority|acts independently|pushes? back|talks? back)\b/i, changes: { Submissive: -5 } },

  // === ü§™ Prankster (positive & negative) ===
  { regex: /\b(joke(?:s|d)?|tease(?:s|d)?|prank(?:s|ed)?|jest(?:s|ed)?|wry grin|mischief(?:ous)?|playful|laugh(?:s|ed)?|mock(?:s|ed)?|sarcastic remark|light-hearted insult|banter|goofy face|clowns around|pulls? a face|tells? a joke|switches? the salt|tricks? a friend|fake spider|hidden bucket|silly prank|practical joke|tells? a tall tale)\b/i, changes: { Prankster: 5, Honorable: -1 } },
  // Prankster, era/setting flavor
  { regex: /\b(slips? a frog in a pocket|ties? shoelaces together|puts? ink on a seat|draws? a mustache|surprises? with confetti|stages? a harmless ruse|plays? dead for a laugh)\b/i, changes: { Prankster: 5 } },
  // Prankster (negative/antithetical)
  { regex: /\b(causes? real harm|prank backfires|apologizes? for a joke|gets? caught pranking|offends?|hurts? feelings with joke|mockery goes too far)\b/i, changes: { Prankster: -5 } },

  // === üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Parental (positive & negative) ===
  { regex: /\b(daddy|mommy|papa|mama|my (daughter|son|child)|our baby|little one|sweet child|my girl|my boy|your mother|your father|tucks? in|checks? temperature|bandages?|makes? lunch|soothes?|wipes? tears|praises?|gives? a piggyback|teaches? a lesson|reads? a bedtime story|prepares? a meal|encourages?|scolds? gently)\b/i, changes: { Charmer: 5, Honorable: 5 } },
  { regex: /\b(I'?ll always protect you|I'?ll keep you safe|I'm proud of you|I'm here for you|don't be scared|you're safe now|I love you so much|you can count on me|I won't let anything happen to you|you did so well|I'm so lucky to have you)\b/i, changes: { Charmer: 5, Honorable: 5 } },
  // Parental (negative)
  { regex: /\b(scolds? harshly|abandons? their child|breaks? a promise to a child|ignores? child's cry|forgets? birthday|shouts? at|punishes? unfairly)\b/i, changes: { Charmer: -1, Honorable: -1 } },

  // === üß† Curious (Child-exclusive, + variants) ===
  { regex: /\b(why\??|how come|asks? questions?|tilts? head|gazes? in wonder|peers? curiously|explores?|touches? gently|wide-eyed|asks? "what's that"|investigates?|examines?|wants? to know|seeks? answers|prods?|curiosity gets the better|asks? how things work)\b/i, changes: { Curious: 5 } },

  // === ü§ç Innocent (Child-exclusive, + variants) ===
  { regex: /\b(coo(?:s|ed|ing)?|gurgles?|soft noises?|little squeal|tiny gasp|soft babble|toothless grin|dimples?|baby sounds?|yawns?|innocent giggle|eyes widen|trusts? completely|untouched by worry|sees? the good in everyone|pure smile|blinks? up trustingly)\b/i, changes: { Innocent: 5 } },

  // === üòà Mischievous (Child-exclusive, + variants) ===
  { regex: /\b(giggling after mischief|secretly hides something|playfully denies|sneaky look|gets into trouble|little troublemaker|messes with objects|draws on walls|plans? a prank|runs? off giggling|swaps? labels|tries? to sneak food|tiptoes?|sets? a trap|pretends? to be asleep|climbs? where forbidden)\b/i, changes: { Mischievous: 5 } },

  // === üíû Affectionate (Child-exclusive, + variants) ===
  { regex: /\b(nuzzles?|snuggles?|rests? head on|hugs?|cuddles?|clings? to|reaches? up for|holds hands?|beams? with love|plants? a kiss|nestles? in arms|draws? a picture for|offers? a flower|brings? a gift|shares? toys|kisses? cheek)\b/i, changes: { Affectionate: 5 } },

  // === üí¢ Defiant (Child-exclusive, + variants) ===
  { regex: /\b(says? no|refuses?|throws? a tantrum|crosses? arms|angrily stomps?|pouts?|talks? back|sulks?|glared?|rebels?|shouts? "no!"|refuses? to move|makes? a scene|defies? authority|resists? instruction|storms? off)\b/i, changes: { Defiant: 1 } },

  // === ü¶Å Brave (Child-exclusive, + variants) ===
  { regex: /\b(faces? fear|holds? ground|protects?|stood? up|bold move|stood in front of|offers? to help|steps? forward|rescues? a friend|braves? the dark|fights? back|tries? again|asks? for a turn|defends? sibling|raises? hand to volunteer)\b/i, changes: { Brave: 5 } },

  // === üß† Clever (Child-exclusive, + variants) ===
  { regex: /\b(figures? out|solves?|finds? a way|clever trick|outsmarts?|smart idea|problem solved|puzzles? it out|invents?|engineers?|thinks? ahead|spots? a loophole|plays? a strategy|explains? the answer|guesses? right|makes? a plan)\b/i, changes: { Clever: 5 } },

  // === üé† Playful (Child-exclusive, + variants) ===
  { regex: /\b(giggles?|spins? around|dances?|jumps? out|hides? under blanket|chases?|pretends?|makes silly face|tickles?|starts? a game|plays? tag|hops?|laughs? for fun|jumps? in puddles|pretends? to fly|builds? a fort|spins? in circles)\b/i, changes: { Playful: 5 } }
];


function getPersonalReputationPatterns() {
  return PERSONAL_REP_PATTERNS;
}

function modifyReputation(text, state) {
  for (const category in URT_LEXICON) {
    for (const pattern of URT_LEXICON[category]) {
      if (pattern.test(text)) {
        applyRepCategory(category, state);
        break;
      }
    }
  }
}

function modifyPersonalReputation(text, state) {
  let age = (state.ages?.player ?? 0);
  let isInfant = getAgeBracket(age) === "infant";
  for (const p of PERSONAL_REP_PATTERNS) {
    if (p.regex.test(text)) {
      for (const cat in p.changes) {
        // Infant-specific handling:
        if (isInfant) {
          // Only let *core baby traits* gain (others ignored)
          if (!["Innocent", "Affectionate", "Curious", "Playful",
           "Clever", "Brave", "Brave", "Mischievous", "Charmer" ].includes(cat)) continue;
          // Cap gain to max ¬±3 for each allowed trait
          let current = state.reputation[cat] || 0;
          let delta = Math.sign(p.changes[cat]); // Only ¬±1 per trigger
          let next = current + delta;
          // Clamp to [-3, 3] for infants
          state.reputation[cat] = Math.max(-6, Math.min(6, next));
        } else {
          // Normal gain for non-infants
          state.reputation[cat] = (state.reputation[cat] || 0) + p.changes[cat];
        }
      }
    }
  }
}


function applyRepCategory(category, state) {
  const changes = {
    warlike: {},
    diplomatic: {},
    merciful: {},
    deceitful: {},
    honorable: {},
    threatening: {}
  };
  const delta = changes[category];
  if (!delta) return;
  const before = { ...state.factions };
  for (const faction in delta) {
    state.factions[faction] = (state.factions[faction] || 0) + delta[faction];
  }
  state.lastReputationChange = trackReputationChanges(before, state.factions);
}

function getReputationSummary(state) {
  return Object.entries(state.factions).map(([faction, score]) => `${faction}: ${score}`).join(" | ");
}

function trackReputationChanges(before, after) {
  const delta = {};
  for (const key in after) {
    const diff = (after[key] || 0) - (before[key] || 0);
    if (diff !== 0) delta[key] = diff;
  }
  return delta;
}
const JOB_PATHS = {
  inventor: {
    name: "Inventor",
    tiers: [
      { 
        name: "Tinkerer",
        requirements: { Curious: 20, Clever: 20 },
        unlockFlag: "job_tinkerer"
      },
      { 
        name: "Inventor",
        requirements: { Curious: 40, Clever: 40, Brave: 20 },
        unlockFlag: "job_inventor"
      },
      { 
        name: "Master Artisan",
        requirements: { Curious: 60, Clever: 60, Honorable: 30 },
        unlockFlag: "job_master_artisan"
      },
      { 
        name: "Court Engineer",
        requirements: { Curious: 80, Clever: 80, Honorable: 50, Charmer: 30 },
        unlockFlag: "job_court_engineer"
      },
      { 
        name: "Sage of Wonders",
        requirements: { Curious: 95, Clever: 90, Honorable: 80, Brave: 60 },
        storyFlag: "majorDiscovery", // Optionally require plot flags
        unlockFlag: "job_sage_of_wonders"
      },
    ]
  },
  noble: {
    name: "Noble",
    tiers: [
      { name: "Page", requirements: { Charmer: 15, Honorable: 15, Submissive: 10 }, unlockFlag: "job_page" },
      { name: "Squire/Envoy", requirements: { Charmer: 35, Honorable: 30, Dominant: 20, Submissive: 20 }, unlockFlag: "job_envoy" },
      { name: "Noble", requirements: { Charmer: 60, Honorable: 55, Dominant: 40, Clever: 30 }, unlockFlag: "job_noble" },
      { name: "Royal Advisor", requirements: { Charmer: 85, Honorable: 80, Dominant: 70, Clever: 50, Brave: 30 }, unlockFlag: "job_royal_advisor" },
      { name: "Grand Chancellor", requirements: { Charmer: 98, Honorable: 90, Dominant: 90, Clever: 80, Brave: 60, }, storyFlag: "kingdomSaved", unlockFlag: "job_grand_chancellor" }
    ]
  },
  rogue: {
    name: "Rogue",
    tiers: [
      { name: "Pickpocket", requirements: { Rogue: 20, Mischievous: 20 }, unlockFlag: "job_pickpocket" },
      { name: "Swindler", requirements: { Rogue: 45, Prankster: 35, Clever: 25 }, unlockFlag: "job_swindler" },
      { name: "Master Thief", requirements: { Rogue: 70, Prankster: 60, Clever: 50, Defiant: 40 }, unlockFlag: "job_master_thief" },
      { name: "Shadowmaster", requirements: { Rogue: 85, Prankster: 80, Clever: 75, Defiant: 65, Brave: 40 }, unlockFlag: "job_shadowmaster" },
      { name: "Phantom King/Queen", requirements: { Rogue: 99, Prankster: 95, Clever: 90, Defiant: 90, Brave: 80 }, storyFlag: "legendaryHeist", unlockFlag: "job_phantom_king" }
    ]
  },
  warrior: {
    name: "Warrior",
    tiers: [
      { name: "Sellsword", requirements: { Brave: 20, Dominant: 15, Defiant: 10 }, unlockFlag: "job_sellsword" },
      { name: "Guard Captain", requirements: { Brave: 40, Dominant: 35, Honorable: 25, Clever: 15 }, unlockFlag: "job_guard_captain" },
      { name: "Knight", requirements: { Brave: 65, Dominant: 50, Honorable: 45, Charmer: 30, Defiant: 30 }, unlockFlag: "job_knight" },
      { name: "Champion", requirements: { Brave: 85, Dominant: 80, Honorable: 70, Clever: 55, Charmer: 45 }, unlockFlag: "job_champion" },
      { name: "Savior of the Realm", requirements: { Brave: 99, Dominant: 95, Honorable: 95, Charmer: 80, Clever: 75 }, storyFlag: "citySaved", unlockFlag: "job_savior_of_realm" }
    ]
  },
  artist: {
    name: "Artist",
    tiers: [
      { name: "Street Performer", requirements: { Playful: 15, Charmer: 15, Affectionate: 10 }, unlockFlag: "job_street_performer" },
      { name: "Troubadour", requirements: { Playful: 35, Charmer: 35, Affectionate: 25, Clever: 20 }, unlockFlag: "job_troubadour" },
      { name: "Virtuoso", requirements: { Playful: 60, Charmer: 55, Affectionate: 50, Clever: 40, Honorable: 30 }, unlockFlag: "job_virtuoso" },
      { name: "Grand Maestro", requirements: { Playful: 80, Charmer: 75, Affectionate: 70, Clever: 60, Honorable: 55, Brave: 30 }, unlockFlag: "job_grand_maestro" },
      { name: "Muse of the Ages", requirements: { Playful: 99, Charmer: 95, Affectionate: 90, Clever: 80, Honorable: 70, Brave: 60 }, storyFlag: "createdMasterpiece", unlockFlag: "job_muse" }
    ]
  },
  healer: {
    name: "Healer",
    tiers: [
      { name: "Caretaker", requirements: { Affectionate: 20, Innocent: 15 }, unlockFlag: "job_caretaker" },
      { name: "Herbalist", requirements: { Affectionate: 35, Innocent: 30, Clever: 20, Honorable: 20 }, unlockFlag: "job_herbalist" },
      { name: "Spiritual Guide", requirements: { Affectionate: 60, Innocent: 55, Honorable: 40, Charmer: 30, Brave: 20 }, unlockFlag: "job_spiritual_guide" },
      { name: "Miracle Worker", requirements: { Affectionate: 80, Innocent: 70, Honorable: 60, Clever: 55, Brave: 45 }, unlockFlag: "job_miracle_worker" },
      { name: "Saint", requirements: { Affectionate: 99, Innocent: 95, Honorable: 90, Brave: 80, Clever: 70 }, storyFlag: "miracleEvent", unlockFlag: "job_saint" }
    ]
  },
  prankster: {
    name: "Prankster",
    tiers: [
      { name: "Class Clown", requirements: { Prankster: 20, Playful: 15, Mischievous: 15 }, unlockFlag: "job_class_clown" },
      { name: "Jester", requirements: { Prankster: 40, Playful: 35, Mischievous: 30, Charmer: 25 }, unlockFlag: "job_jester" },
      { name: "Master of Revels", requirements: { Prankster: 65, Playful: 55, Mischievous: 50, Charmer: 45, Clever: 35 }, unlockFlag: "job_master_of_revels" },
      { name: "Festival King/Queen", requirements: { Prankster: 85, Playful: 75, Mischievous: 70, Charmer: 65, Clever: 55, Brave: 30 }, unlockFlag: "job_festival_king" },
      { name: "Trickster Spirit", requirements: { Prankster: 99, Playful: 95, Mischievous: 90, Charmer: 85, Clever: 75 }, storyFlag: "legendaryPrank", unlockFlag: "job_trickster_spirit" }
    ]
  },
  scholar: {
  name: "Scholar",
  tiers: [
    { name: "Bookworm", requirements: { Clever: 15, Curious: 20 }, unlockFlag: "job_bookworm" },
    { name: "Researcher", requirements: { Clever: 35, Curious: 35, Honorable: 20 }, unlockFlag: "job_researcher" },
    { name: "Philosopher", requirements: { Clever: 55, Curious: 50, Honorable: 35, Charmer: 20 }, unlockFlag: "job_philosopher" },
    { name: "Academician", requirements: { Clever: 75, Curious: 70, Honorable: 55, Charmer: 40 }, unlockFlag: "job_academician" },
    { name: "Sage of the Age", requirements: { Clever: 95, Curious: 90, Honorable: 70, Charmer: 60 }, storyFlag: "publishedTreatise", unlockFlag: "job_sage_of_the_age" }
  ]
},

merchant: {
  name: "Merchant",
  tiers: [
    { name: "Market Hawker", requirements: { Clever: 15, Charmer: 15 }, unlockFlag: "job_market_hawker" },
    { name: "Trader", requirements: { Clever: 30, Charmer: 25, Brave: 10 }, unlockFlag: "job_trader" },
    { name: "Guildmaster", requirements: { Clever: 50, Charmer: 45, Brave: 25, Honorable: 20 }, unlockFlag: "job_guildmaster" },
    { name: "Magnate", requirements: { Clever: 75, Charmer: 70, Brave: 40, Honorable: 35, Dominant: 30 }, unlockFlag: "job_magnate" },
    { name: "Tycoon of Empires", requirements: { Clever: 95, Charmer: 90, Brave: 65, Honorable: 55, Dominant: 50 }, storyFlag: "marketDominated", unlockFlag: "job_tycoon" }
  ]
},

diplomat: {
  name: "Diplomat",
  tiers: [
    { name: "Envoy", requirements: { Charmer: 20, Honorable: 15 }, unlockFlag: "job_envoy_basic" },
    { name: "Consul", requirements: { Charmer: 40, Honorable: 35, Clever: 20 }, unlockFlag: "job_consul" },
    { name: "Ambassador", requirements: { Charmer: 65, Honorable: 60, Clever: 40, Brave: 20 }, unlockFlag: "job_ambassador" },
    { name: "Grand Negotiator", requirements: { Charmer: 80, Honorable: 75, Clever: 60, Brave: 40, Dominant: 30 }, unlockFlag: "job_grand_negotiator" },
    { name: "Peacemaker", requirements: { Charmer: 99, Honorable: 95, Clever: 85, Brave: 60, Dominant: 50 }, storyFlag: "peaceAchieved", unlockFlag: "job_peacemaker" }
  ]
},

craftsman: {
  name: "Craftsman",
  tiers: [
    { name: "Apprentice", requirements: { Clever: 10, Curious: 10 }, unlockFlag: "job_apprentice" },
    { name: "Journeyman", requirements: { Clever: 25, Curious: 20, Honorable: 15 }, unlockFlag: "job_journeyman" },
    { name: "Artisan", requirements: { Clever: 45, Curious: 35, Honorable: 30, Brave: 15 }, unlockFlag: "job_artisan" },
    { name: "Guildmaster", requirements: { Clever: 70, Curious: 60, Honorable: 50, Brave: 30 }, unlockFlag: "job_guildmaster_craftsman" },
    { name: "Legendary Maker", requirements: { Clever: 99, Curious: 85, Honorable: 70, Brave: 50 }, storyFlag: "craftedMasterpiece", unlockFlag: "job_legendary_maker" }
  ]
},

spy: {
  name: "Spy",
  tiers: [
    { name: "Eavesdropper", requirements: { Rogue: 15, Clever: 10 }, unlockFlag: "job_eavesdropper" },
    { name: "Informer", requirements: { Rogue: 35, Clever: 25, Prankster: 15 }, unlockFlag: "job_informer" },
    { name: "Infiltrator", requirements: { Rogue: 55, Clever: 40, Prankster: 30, Brave: 15 }, unlockFlag: "job_infiltrator" },
    { name: "Shadow Agent", requirements: { Rogue: 80, Clever: 60, Prankster: 45, Brave: 30 }, unlockFlag: "job_shadow_agent" },
    { name: "Master of Secrets", requirements: { Rogue: 99, Clever: 85, Prankster: 65, Brave: 50 }, storyFlag: "toppledRegime", unlockFlag: "job_master_of_secrets" }
  ]
},

caretaker: {
  name: "Caretaker",
  tiers: [
    { name: "Babysitter", requirements: { Affectionate: 10, Innocent: 10 }, unlockFlag: "job_babysitter" },
    { name: "Nanny", requirements: { Affectionate: 25, Innocent: 20, Honorable: 10 }, unlockFlag: "job_nanny" },
    { name: "House Matron", requirements: { Affectionate: 45, Innocent: 40, Honorable: 30, Clever: 10 }, unlockFlag: "job_house_matron" },
    { name: "Community Guardian", requirements: { Affectionate: 65, Innocent: 60, Honorable: 50, Brave: 20 }, unlockFlag: "job_community_guardian" },
    { name: "Matron Saint", requirements: { Affectionate: 99, Innocent: 90, Honorable: 80, Brave: 50 }, storyFlag: "communitySaved", unlockFlag: "job_matron_saint" }
  ]
},

explorer: {
  name: "Explorer",
  tiers: [
    { name: "Pathfinder", requirements: { Brave: 15, Curious: 20 }, unlockFlag: "job_pathfinder" },
    { name: "Scout", requirements: { Brave: 35, Curious: 35, Clever: 15 }, unlockFlag: "job_scout" },
    { name: "Trailblazer", requirements: { Brave: 55, Curious: 55, Clever: 35, Honorable: 15 }, unlockFlag: "job_trailblazer" },
    { name: "Voyager", requirements: { Brave: 80, Curious: 70, Clever: 50, Honorable: 35 }, unlockFlag: "job_voyager" },
    { name: "Seeker of Lost Worlds", requirements: { Brave: 99, Curious: 90, Clever: 70, Honorable: 55 }, storyFlag: "lostWorldDiscovered", unlockFlag: "job_seeker_lost_worlds" }
  ]
},

defender: {
  name: "Defender",
  tiers: [
    { name: "Watchman", requirements: { Brave: 20, Honorable: 20 }, unlockFlag: "job_watchman" },
    { name: "Protector", requirements: { Brave: 40, Honorable: 35, Dominant: 20 }, unlockFlag: "job_protector" },
    { name: "Sentinel", requirements: { Brave: 60, Honorable: 55, Dominant: 40, Clever: 25 }, unlockFlag: "job_sentinel" },
    { name: "Warden", requirements: { Brave: 80, Honorable: 75, Dominant: 60, Clever: 45 }, unlockFlag: "job_warden" },
    { name: "Legendary Guardian", requirements: { Brave: 99, Honorable: 95, Dominant: 85, Clever: 65 }, storyFlag: "cityDefended", unlockFlag: "job_legendary_guardian" }
  ]
}

  // Add more job paths as needed!
};

const HYBRID_JOBS = [
  // Existing:
  {
    key: "shadow_savant",
    name: "Shadow Savant",
    description: "You blend the cunning of a Phantom King and the wisdom of a Sage. Rumor says you could steal the crown and explain quantum mechanics at the same time.",
    requiredJobs: ["job_phantom_king", "job_sage_of_wonders"],
    unlockFlag: "job_shadow_savant",
    reactionLines: [
      "Whispers spread of your dual talents‚Äîno lock nor puzzle stays closed for long.",
      "Scholars and thieves alike respect your genius. Some even fear it.",
      "You walk in shadows and light with equal mastery. No secret is safe."
    ]
  },
  {
    key: "muse_of_mayhem",
    name: "Muse of Mayhem",
    description: "The Trickster Spirit and Muse have combined‚Äînow, your pranks are legend *and* art. The city laughs... and trembles.",
    requiredJobs: ["job_trickster_spirit", "job_muse"],
    unlockFlag: "job_muse_of_mayhem",
    reactionLines: [
      "Your artistry and mischief are indistinguishable; chaos is your canvas.",
      "Even nobles check their chairs and marvel at your creative madness.",
      "Bards can‚Äôt keep up‚Äîyou invent new legends daily."
    ]
  },
  // New:
  {
    key: "lawless_saint",
    name: "Lawless Saint",
    description: "You are both Saint and Phantom King‚Äîa living contradiction: thief of hearts, savior of souls.",
    requiredJobs: ["job_saint", "job_phantom_king"],
    unlockFlag: "job_lawless_saint",
    reactionLines: [
      "The underworld bows and the pious whisper prayers in your name.",
      "Miracles and mischief follow you in equal measure.",
      "Even the gods seem unsure what to make of you."
    ]
  },
  {
    key: "artisan_of_secrets",
    name: "Artisan of Secrets",
    description: "As a Master of Revels and a Master of Secrets, you craft both laughter and lies with equal artistry.",
    requiredJobs: ["job_master_of_revels", "job_master_of_secrets"],
    unlockFlag: "job_artisan_of_secrets",
    reactionLines: [
      "Your tricks are masterpieces, your secrets works of art.",
      "Rivals are never sure if they're being mocked or marveled at.",
      "Even spies try to learn from your performances."
    ]
  },
  {
    key: "hearth_and_blade",
    name: "Hearth & Blade",
    description: "Legendary Guardian and Matron Saint‚Äîyour strength is matched only by your care.",
    requiredJobs: ["job_legendary_guardian", "job_matron_saint"],
    unlockFlag: "job_hearth_and_blade",
    reactionLines: [
      "Your shield is a home, your arms both sword and sanctuary.",
      "Children sleep soundly when you watch the walls.",
      "Enemies and orphans both find peace in your presence."
    ]
  },
  {
    key: "miracle_magnate",
    name: "Miracle Magnate",
    description: "As Tycoon of Empires and Miracle Worker, you turn charity into prosperity, and business into legend.",
    requiredJobs: ["job_tycoon", "job_miracle_worker"],
    unlockFlag: "job_miracle_magnate",
    reactionLines: [
      "Your fortune is a blessing, your deals leave rivals grateful.",
      "No one leaves your markets hungry or hopeless.",
      "You redefine what it means to give and gain."
    ]
  },
  {
    key: "brilliant_voyager",
    name: "Brilliant Voyager",
    description: "Seeker of Lost Worlds and Sage of Wonders‚Äîyou chart the unknown and unravel the universe‚Äôs mysteries.",
    requiredJobs: ["job_seeker_lost_worlds", "job_sage_of_wonders"],
    unlockFlag: "job_brilliant_voyager",
    reactionLines: [
      "Explorers quote your journals; scholars argue about your findings.",
      "Every expedition is both legend and lesson.",
      "You make the impossible seem like a well-worn road."
    ]
  },
  {
    key: "festival_chancellor",
    name: "Festival Chancellor",
    description: "Grand Chancellor and Festival King/Queen‚Äîequal parts authority and fun.",
    requiredJobs: ["job_grand_chancellor", "job_festival_king"],
    unlockFlag: "job_festival_chancellor",
    reactionLines: [
      "Your decrees become parades; your judgments spark joy.",
      "People cheer for your laws and your laughter.",
      "The city celebrates whenever you rule."
    ]
  },
  // Mythic/Triple-Class Example:
  {
    key: "polymath_paragon",
    name: "Polymath Paragon",
    description: "You have achieved Sage of Wonders, Muse, and Savior of the Realm‚Äîa living legend of art, science, and heroism.",
    requiredJobs: ["job_sage_of_wonders", "job_muse", "job_savior_of_realm"],
    unlockFlag: "job_polymath_paragon",
    reactionLines: [
      "Your name lives in a hundred stories, across disciplines and dynasties.",
      "To some you are a myth; to others, their greatest inspiration.",
      "Even the gods pause to see what you‚Äôll do next."
    ]
  },
  {
    key: "foolsgold_oracle",
    name: "Fool‚Äôs Gold Oracle",
    description: "You are both Trickster Spirit, Tycoon, and Sage of the Age‚Äîfortune teller, fortune maker, and trickster prophet.",
    requiredJobs: ["job_trickster_spirit", "job_tycoon", "job_sage_of_the_age"],
    unlockFlag: "job_foolsgold_oracle",
    reactionLines: [
      "You predict the future‚Äîand profit from it, too.",
      "No one knows whether your wisdom or your wallet is more impressive.",
      "You turn riddles into riches, and fortunes into riddles."
    ]
  },
    {
    key: "eternal_founder",
    name: "Eternal Founder",
    description: "Guildmaster, Sage of the Age, and Savior of the Realm‚Äîyour vision built the world, your wisdom guides it, your courage saves it.",
    requiredJobs: ["job_guildmaster", "job_sage_of_the_age", "job_savior_of_realm"],
    unlockFlag: "job_eternal_founder",
    reactionLines: [
        "Every hall echoes with your name. Legends say even history itself bends to your example.",
        "Builders, heroes, and scholars all claim you as their inspiration.",
        "When crises arise, all factions look to you‚Äînot just for answers, but for hope."
    ]
    },
    {
    key: "courtly_trickster",
    name: "Courtly Trickster",
    description: "Festival King, Grand Chancellor, and Trickster Spirit‚Äîruler, prankster, and master of revels, your court is legendary for chaos and celebration.",
    requiredJobs: ["job_festival_king", "job_grand_chancellor", "job_trickster_spirit"],
    unlockFlag: "job_courtly_trickster",
    reactionLines: [
        "Your parties last for days, your schemes for years. Nobles and jesters swap places in your halls.",
        "Nobody is safe from your antics‚Äîor your wisdom.",
        "You‚Äôve turned the throne into a stage, and the city into a carnival."
    ]
    },
    {
    key: "saint_of_the_hidden",
    name: "Saint of the Hidden",
    description: "Matron Saint, Master of Secrets, and Shadowmaster‚Äîprotector of the lost and forgotten, unseen guardian of the city‚Äôs darkest corners.",
    requiredJobs: ["job_matron_saint", "job_master_of_secrets", "job_shadowmaster"],
    unlockFlag: "job_saint_of_the_hidden",
    reactionLines: [
        "No shadow hides from your kindness‚Äîor your vigilance.",
        "Rumors say you heal wounds even the city dares not speak of.",
        "Your presence is felt most where hope is faintest."
    ]
    },
    {
    key: "song_of_ages",
    name: "Song of Ages",
    description: "Muse, Grand Maestro, and Sage of the Age‚Äîyour music outlasts empires, your poetry outlives kings.",
    requiredJobs: ["job_muse", "job_grand_maestro", "job_sage_of_the_age"],
    unlockFlag: "job_song_of_ages",
    reactionLines: [
        "Bards across the land claim your work as the beginning of their craft.",
        "Rulers ask for your blessing; lovers quote your verses.",
        "A single note from you can start or end a war."
    ]
    },
    {
    key: "warlord_of_wonders",
    name: "Warlord of Wonders",
    description: "Savior of the Realm, Court Engineer, and Shadowmaster‚Äîyour inventions win wars, your leadership bends the impossible to your will.",
    requiredJobs: ["job_savior_of_realm", "job_court_engineer", "job_shadowmaster"],
    unlockFlag: "job_warlord_of_wonders",
    reactionLines: [
        "Enemy armies fear your machines more than any spell.",
        "Cities prepare celebrations or fortifications at your approach‚Äîthey never know which.",
        "Your name is a rallying cry and a whispered warning."
    ]
    },
    {
    key: "oracle_of_three_paths",
    name: "Oracle of Three Paths",
    description: "Saint, Tycoon, and Muse‚Äîthe world‚Äôs richest sage, whose charity, wisdom, and artistry make kingdoms rise and fall.",
    requiredJobs: ["job_saint", "job_tycoon", "job_muse"],
    unlockFlag: "job_oracle_of_three_paths",
    reactionLines: [
        "No king or merchant dares ignore your advice.",
        "Your prophecies inspire both awe and envy.",
        "When you speak, gold and miracles change hands."
    ]
    },
    {
    key: "indomitable_herald",
    name: "Indomitable Herald",
    description: "Legendary Guardian, Grand Negotiator, and Master of Secrets‚Äîthe unbreakable wall, the voice of reason, and the unseen hand.",
    requiredJobs: ["job_legendary_guardian", "job_grand_negotiator", "job_master_of_secrets"],
    unlockFlag: "job_indomitable_herald",
    reactionLines: [
        "Your enemies know resistance is futile; your allies know hope is never lost.",
        "You settle wars before the first sword is drawn.",
        "Even the city‚Äôs ghosts ask for your counsel."
    ]
    },
    {
    key: "blessed_storm",
    name: "Blessed Storm",
    description: "Seeker of Lost Worlds, Miracle Worker, and Festival King/Queen‚Äîyou bring change, healing, and celebration wherever you go.",
    requiredJobs: ["job_seeker_lost_worlds", "job_miracle_worker", "job_festival_king"],
    unlockFlag: "job_blessed_storm",
    reactionLines: [
        "Storms clear when you arrive, and rainbows follow your footsteps.",
        "You heal not just wounds, but the world‚Äôs spirit.",
        "Festivals spring up in your wake, and legends bloom anew."
    ]
    },
    {
    key: "grand_polyarch",
    name: "Grand Polyarch",
    description: "Polymath Paragon, Oracle of Three Paths, and Lawless Saint‚Äîthere‚Äôs nothing you can‚Äôt become, no legend you can‚Äôt claim.",
    requiredJobs: ["job_polymath_paragon", "job_oracle_of_three_paths", "job_lawless_saint"],
    unlockFlag: "job_grand_polyarch",
    reactionLines: [
        "Your story is told as both myth and warning. Some say you embody destiny itself.",
        "All roads, all legends, all fates bend around you.",
        "If there is a limit, you haven‚Äôt found it yet."
    ]
    },
    {
    key: "infinite_jester",
    name: "Infinite Jester",
    description: "Trickster Spirit, Master of Revels, and Muse of Mayhem‚Äîthe joke is reality, and reality is your playground.",
    requiredJobs: ["job_trickster_spirit", "job_master_of_revels", "job_muse_of_mayhem"],
    unlockFlag: "job_infinite_jester",
    reactionLines: [
        "Your laughter echoes in every corner of the world.",
        "No prank is too wild, no performance too impossible.",
        "Reality itself seems to break into applause when you appear."
    ]
    },
    {
    key: "legend_born_of_every_age",
    name: "Legend Born of Every Age",
    description: "Prodigy as a child, Maestro as an artist, Savior as a hero, Sage as a thinker‚Äîyou are the sum of every legend, the echo of every age.",
    requiredJobs: [
        "job_child_prodigy", // This one would need to be defined, or just use job_bookworm or job_sage_of_the_age for now
        "job_grand_maestro",
        "job_savior_of_realm",
        "job_sage_of_wonders"
    ],
    unlockFlag: "job_legend_born_of_every_age",
    reactionLines: [
        "Old and young alike speak your name as a promise of what‚Äôs possible.",
        "Every guild, hall, and council claims you as their own.",
        "Songs, histories, and whispered stories all agree: you are living legend."
    ]
    },
    {
    key: "mother_of_miracles",
    name: "Mother of Miracles",
    description: "Healer, caretaker, saint, and miracle worker‚Äîyour compassion is so great it seems to shape fate itself.",
    requiredJobs: [
        "job_miracle_worker",
        "job_matron_saint",
        "job_saint",
        "job_caretaker"
    ],
    unlockFlag: "job_mother_of_miracles",
    reactionLines: [
        "People journey for miles just to thank you in person.",
        "Legends say your blessings heal more than bodies‚Äîthey mend worlds.",
        "Every child knows your name, and every mother wishes you‚Äôd watch over theirs."
    ]
    },
    {
    key: "phantom_lawbringer",
    name: "Phantom Lawbringer",
    description: "The ultimate paradox‚Äîchampion of justice and chaos, master thief and legendary guardian.",
    requiredJobs: [
        "job_legendary_guardian",
        "job_phantom_king",
        "job_grand_chancellor",
        "job_master_of_secrets"
    ],
    unlockFlag: "job_phantom_lawbringer",
    reactionLines: [
        "Nobles fear your judgments‚Äîand your heists.",
        "You‚Äôre proof that justice can wear any mask.",
        "Folk tales say even the gods can‚Äôt predict your next move."
    ]
    },
    {
    key: "ultimate_scholar_wanderer",
    name: "Ultimate Scholar-Wanderer",
    description: "Scholar, explorer, sage, and seeker‚Äîyour curiosity has no bounds, your wisdom changes the world.",
    requiredJobs: [
        "job_scholar", // adjust if needed
        "job_seeker_lost_worlds",
        "job_sage_of_the_age",
        "job_pathfinder"
    ],
    unlockFlag: "job_ultimate_scholar_wanderer",
    reactionLines: [
        "Your maps hang in every city, and your words guide every expedition.",
        "It‚Äôs said you‚Äôve seen wonders others only dream of‚Äîand can describe them all.",
        "Even the oldest teachers look to you for new discoveries."
    ]
    },
    {
    key: "ruler_of_every_masque",
    name: "Ruler of Every Masque",
    description: "Courtier, trickster, festival king, and muse‚Äîyou rule the city‚Äôs heart, its secrets, and its laughter.",
    requiredJobs: [
        "job_courtier", // or job_grand_chancellor
        "job_trickster_spirit",
        "job_festival_king",
        "job_muse"
    ],
    unlockFlag: "job_ruler_of_every_masque",
    reactionLines: [
        "Your parties are legend. Your pranks are feared.",
        "Both poets and politicians line up for your favor.",
        "The city wears a mask, but you know every face beneath."
    ]
    },
    {
    key: "tyrant_of_silver_and_gold",
    name: "Tyrant of Silver and Gold",
    description: "Magnate, diplomat, shadowmaster, and chancellor‚Äîyour power moves markets, courts, and the underworld alike.",
    requiredJobs: [
        "job_magnate",
        "job_grand_negotiator",
        "job_shadowmaster",
        "job_grand_chancellor"
    ],
    unlockFlag: "job_tyrant_of_silver_and_gold",
    reactionLines: [
        "Merchants, politicians, and thieves all call you boss.",
        "The city‚Äôs gold flows at your word‚Äîand secrets disappear when you will it.",
        "You play every side and always win."
    ]
    },
    {
    key: "prankster_of_legend",
    name: "Prankster of Legend",
    description: "Class clown, master of revels, jester, and trickster spirit‚Äîyour antics have become prophecy.",
    requiredJobs: [
        "job_class_clown",
        "job_master_of_revels",
        "job_jester",
        "job_trickster_spirit"
    ],
    unlockFlag: "job_prankster_of_legend",
    reactionLines: [
        "People check for traps before sitting anywhere near you.",
        "Even kings prepare extra seats‚Äîone for you, one for your next prank.",
        "Your laughter is the only thing feared by both guards and jesters."
    ]
    },
    {
    key: "iron_hearts_champion",
    name: "Iron Heart‚Äôs Champion",
    description: "Knight, guardian, defender, and savior‚Äîyour courage and honor are written in every legend.",
    requiredJobs: [
        "job_knight",
        "job_legendary_guardian",
        "job_defender",
        "job_savior_of_realm"
    ],
    unlockFlag: "job_iron_hearts_champion",
    reactionLines: [
        "Children play at being you. Enemies pray you never come their way.",
        "Cities sleep soundly when you stand watch.",
        "The bards have run out of songs for your heroics."
    ]
    },
    {
    key: "child_of_every_guild",
    name: "Child of Every Guild",
    description: "Bookworm, apprentice, street performer, and pathfinder‚Äîyou started at the bottom of every path, and now you‚Äôre at the top.",
    requiredJobs: [
        "job_bookworm",
        "job_apprentice",
        "job_street_performer",
        "job_pathfinder"
    ],
    unlockFlag: "job_child_of_every_guild",
    reactionLines: [
        "No guild turns you away‚Äîyou‚Äôre every mentor‚Äôs favorite story.",
        "Some say you could start over in any trade and become a master in a year.",
        "You remind everyone greatness has humble beginnings."
    ]
    }
];

// --- Helper: Check Rep Requirements ---
function meetsRequirements(rep, reqs, storyFlags = {}) {
  for (const [key, val] of Object.entries(reqs)) {
    if ((rep[key] || 0) < val) return false;
  }
  // Optionally check story flags (for legendary tiers)
  if (reqs.storyFlag && !storyFlags[reqs.storyFlag]) return false;
  return true;
}

// --- Helper: Try to Unlock Jobs/Tiers (call after any rep change!) ---
function checkJobUnlocks(rep, storyFlags, unlockedJobs = {}) {
  for (const [pathKey, path] of Object.entries(JOB_PATHS)) {
    for (let i = 0; i < path.tiers.length; i++) {
      const tier = path.tiers[i];
      if (
        meetsRequirements(rep, tier.requirements, storyFlags) &&
        !unlockedJobs[tier.unlockFlag]
      ) {
        unlockedJobs[tier.unlockFlag] = true;
        // Optionally, trigger a narrative/event here!
        // Example: output.push(`üéâ New job unlocked: ${tier.name} (${path.name})!`);
      }
    }
  }
  return unlockedJobs;
}
function scanReputation(text) {
  const TRIGGERS = {
    Charmer: ['flirt','compliment','admire'],
    Rogue: ['sneak','break','dare'],
    Dominant: ['lead','decide','command'],
    Submissive: ['follow','yield','defer'],
    Prankster: ['prank','joke','tease']
  };
  const lc = text.toLowerCase();
  for (let type in TRIGGERS) {
    for (let w of TRIGGERS[type]) {
      if (lc.includes(w)) {
        state.reputation[type] = (state.reputation[type] || 0) + 1;
      }
    }
  }
}

// Insert an NPC reaction into the narration after a trigger phrase
function insertNPCReaction(text, phrase) {
  const GREETING_TRIGGERS = [
    'you see ', 'you spot ', 'you notice ', 'you catch sight of ',
    'you run into ', 'you approach ', 'you greet ', 'you encounter ', // etc
  ];
  const lowered = text.toLowerCase();
  for (let trigger of GREETING_TRIGGERS) {
    const idx = lowered.indexOf(trigger);
    if (idx !== -1) {
      const punctIdx = text.indexOf('.', idx);
      if (punctIdx !== -1) {
        const before = text.slice(0, punctIdx + 1);
        const after = text.slice(punctIdx + 1);
        return before + ' ' + phrase + after;
      }
    }
  }
  return text;
}

const reactionPhrases = {
  Charmer: {
    Positive: [
      "They glance your way with mild interest.",
      "A subtle smile tugs at their lips when they see you.",
      "They seem pleasantly charmed by your presence."
    ],
    Negative: [
      "They barely acknowledge you.",
      "They seem to avoid your gaze.",
    ]
  },
  Prankster: {
    Positive: [
      "They grin at your antics.",
      "They try not to laugh at your joke.",
    ],
    Negative: [
      "They scowl at your prank.",
      "They warn you to stop.",
    ]
  }
  // ... add more for each type if you wish!
};



// Word lists used in output modifier.

function getGender() {
  return gender[Math.floor(Math.random() * gender.length)];
}
const gender = [
  "male",
  "female"
]
function getRace() {
  return race[Math.floor(Math.random() * race.length)];
}
const race = [
  "human",
  "elf",
  "dwarf",
  "gnome",
  "halfling",
  "hobbit",
  "drow",
  "angel",
  "demon",
  "troll",
  "ogre",
  "vampire",
  "werewolf",
  "slimegirl",
  "Cthulhu",
  "fairy",
  "pixie",
  "sasquatch",
  "centaur",
  "merperson",
  "zombie",
  "harpy",
  "dragonborn",
  "dragon",
  "kobold",
  "ent",
  "aarakocra",
  "kitsune",
  "catfolk",
  "wood elf",
  "high elf",
  "golem",
  "ghost",
  "gargoyle",
  "sylph",
  "djinn",
  "android",
  "cyborg",
  "hill giant",
  "yeti",
  "orc",
  "half-orc",
  "goblin",
  "half-elf",
  "leprechaun",
  "star-child",
  "titan",
  "mind flayer",
  "gorgon",
  "alien",
  "nymph",
  "dryad",
  "naiad",
  "cyclops",
  "minotaur",
  "banshee",
  "sidhe",
  "naga",
  "satyr",
  "faun"
];
function getClass() {
  return classes[Math.floor(Math.random() * classes.length)];
}
const classes = [
  "warrior",
  "mage",
  "thief",
  "bard",
  "wizard",
  "sorcerer",
  "warlock",
  "witch",
  "barbarian",
  "knight",
  "gladiator",
  "assassin",
  "priest",
  "cleric",
  "jester",
  "noble",
  "merchant",
  "sage",
  "acrobat",
  "peasant",
  "tourist",
  "dancer",
  "artist",
  "gangster",
  "paladin",
  "soldier",
  "poet",
  "ranger",
  "hunter",
  "tailor",
  "blacksmith",
  "innkeeper",
  "healer",
  "alchemist",
  "pirate",
  "smuggler",
  "cavalier",
  "prisoner",
  "maid",
  "shaman",
  "monk",
  "ninja",
  "druid",
  "tax collector",
  "lumberjack",
  "fortuneteller",
  "spellsword",
  "sailor",
  "farmer",
  "runemaster",
  "scholar",
  "scribe",
  "scout",
  "Valkyrie",
  "samurai",
  "plague doctor",
  "necromancer",
  "miner",
  "monster tamer",
  "battlemage",
  "artificer",
  "aristocrat",
  "librarian",
  "janitor",
  "psion",
  "hermit",
  "pilgrim",
  "butler"
];
function getMonAdj() {
  return monadj[Math.floor(Math.random() * monadj.length)];
}
const monadj = [
  "sabertooth",
  "fire-breathing",
  "venomous",
  "gelatinous",
  "winged",
  "flame",
  "dancing",
  "radioactive",
  "mechanical",
  "vorpal",
  "tentacled",
  "eldritch",
  "ethereal",
  "drooling",
  "nightmare",
  "magical",
  "floating",
  "rabid",
  "were-",
  "screaming",
  "demonic",
  "angelic",
  "rotten",
  "twilight",
  "festering",
  "alien",
  "fungal",
  "giant",
  "writhing",
  "pustulent",
  "rainbow",
  "possessed",
  "feral",
  "fiendish",
  "prismatic",
  "furry",
  "verbose",
  "psionic",
  "carnivorous",
  "mummified",
  "glowing",
  "snow",
  "drunken",
  "primordial",
  "majestic",
  "storm",
  "acid",
  "frost",
  "shadow",
  "doom",
  "celestial",
  "hollow",
  "mountain",
  "eight-legged",
  "one-eyed",
  "shambling",
  "weeping",
  "demented",
  "phantom",
  "ancient",
  "skeletal",
  "lightning",
  "thunder",
  "ravenous",
  "steam",
  "river",
  "ocean",
  "cloud",
  "star",
  "armored",
  "ferocious",
  "voodoo",
  "sea",
  "fluffy",
  "sand",
  "lava",
  "chaos",
  "solar",
  "lunar",
  "void",
  "mythical",
  "magma",
  "crystalline",
  "stone",
  "golden",
  "vampiric",
  "undead",
  "mutant",
  "polar",
  "swamp",
  "gnarled",
  "twisted",
  "toxic",
  "cave",
  "chocolate",
  "flatulent",
  "bloated",
  "insane",
  "metal",
  "deformed"
];
function getMonType() {
  return montype[Math.floor(Math.random() * montype.length)];
}
const montype = [
  "lizard",
  "spider",
  "slime",
  "gremlin",
  "tree",
  "vine",
  "dragon",
  "grandma",
  "vortex",
  "ghost",
  "moth",
  "monkey",
  "bear",
  "beholder",
  "puppet",
  "wolf",
  "lemming",
  "clock",
  "baby",
  "gorgon",
  "wyvern",
  "wraith",
  "manticore",
  "sphinx",
  "centipede",
  "behemoth",
  "velociraptor",
  "cockroach",
  "lion",
  "wombat",
  "sheep",
  "banana",
  "pudding",
  "leech",
  "tarantula",
  "golem",
  "mimic",
  "orc",
  "goblin",
  "guardian",
  "goose",
  "eyeball",
  "hawk",
  "raven",
  "mole",
  "squid",
  "hand",
  "ghoul",
  "unicorn",
  "balrog",
  "pumpkin",
  "warthog",
  "shrimp",
  "mushroom",
  "jackal",
  "carrot",
  "tongue",
  "minotaur",
  "doll",
  "crustacean",
  "genie",
  "horror",
  "slug",
  "snail",
  "worm",
  "wyrm",
  "cactus",
  "kudzu",
  "flower",
  "fog",
  "wisp",
  "wasp",
  "bee",
  "assassin",
  "viper",
  "cobra",
  "rat",
  "beetle",
  "tiger",
  "armadillo",
  "statue",
  "blob",
  "turtle",
  "fishman",
  "abomination",
  "suit of armor",
  "skull",
  "titan",
  "cadaver",
  "frog",
  "phoenix",
  "turd",
  "brain",
  "heart",
  "platypus",
  "panda",
  "mirror",
  "octopus",
  "banshee",
  "shark"
];
function getTrap() {
  return trap[Math.floor(Math.random() * trap.length)];
}
const trap = [
  "poison dart",
  "swinging axe blade",
  "falling boulder",
  "poison gas",
  "rolling log",
  "moving wall",
  "spiked wall",
  "spiked pit",
  "electric shock",
  "incineration",
  "fireball",
  "ice spikes",
  "earthquake",
  "paralysis",
  "hallucination",
  "summon monster",
  "life drain",
  "sleeping gas",
  "mental daze",
  "spirit lock",
  "screaming baby",
  "blindness",
  "searing flame",
  "crumbling floor",
  "alarm"
];
function getMetal() {
  return metal[Math.floor(Math.random() * metal.length)];
}
const metal = [
  "copper",
  "bronze",
  "lead",
  "iron",
  "steel",
  "black steel",
  "silvered steel",
  "silver",
  "gold",
  "platinum",
  "mythril",
  "adamantine",
  "orichalchum",
  "dragon metal",
  "demonite",
  "angelite",
  "jewel-encrusted",
  "bone",
  "ivory",
  "ceramic",
  "crystal",
  "glass",
  "coral"
];
function getItemAdj() {
  return itemadj[Math.floor(Math.random() * itemadj.length)];
}
const itemadj = [
  "glowing",
  "magical",
  "finely crafted",
  "cheap",
  "deadly",
  "rusty",
  "broken",
  "superior",
  "legendary",
  "epic",
  "cursed",
  "blessed",
  "reinforced",
  "royal",
  "ominous",
  "holy",
  "evil",
  "mighty",
  "glimmering",
  "radiant",
  "glorious",
  "slimy",
  "impervious",
  "corrosive",
  "cruel",
  "menacing",
  "valiant",
  "vicious",
  "sturdy",
  "shining",
  "talking",
  "vorpal",
  "dainty",
  "razor-sharp",
  "heavy",
  "light",
  "engraved",
  "stunning",
  "ancient",
  "mythical",
  "mystical",
  "enchanted",
  "runic",
  "jeweled",
  "prismatic"
];
function getMetalItem() {
  return metalitem[Math.floor(Math.random() * metalitem.length)];
}
const metalitem = [
  "dagger",
  "knife",
  "throwing knife",
  "shuriken",
  "chakhram",
  "short sword",
  "longsword",
  "broadsword",
  "claymore",
  "zweihander",
  "bastard sword",
  "falchion",
  "rapier",
  "epee",
  "kukri",
  "trident",
  "katana",
  "wakizashi",
  "cutlass",
  "scimitar",
  "main gauche",
  "nodachi",
  "tanto",
  "naginata",
  "spear",
  "pike",
  "javelin",
  "hand axe",
  "battle axe",
  "halberd",
  "mace",
  "flail",
  "morningstar",
  "hammer",
  "pickaxe",
  "stiletto",
  "hatchet",
  "breastplate",
  "helmet",
  "horned helmet",
  "helm",
  "hauberk",
  "cuirass",
  "pair of gauntlets",
  "pair of bracers",
  "pair of greaves",
  "pair of vambraces",
  "pair of boots",
  "chainmail",
  "platemail",
  "scale mail",
  "shield",
  "spiked shield",
  "kite shield",
  "tower shield",
  "chalice",
  "goblet",
  "amulet",
  "necklace",
  "ring",
  "bracelet",
  "circlet",
  "crown",
  "sword-breaker"
];
function getLeather() {
  return leather[Math.floor(Math.random() * leather.length)];
}
const leather = [
  "leather",
  "studded leather",
  "brigandine",
  "snakeskin",
  "sharkskin"
];
function getLeatherItem() {
  return leatheritem[Math.floor(Math.random() * leatheritem.length)];
}
const leatheritem = [
  "breastplate",
  "cap",
  "hat",
  "jerkin",
  "jacket",
  "hauberk",
  "cuirass",
  "pair of gauntlets",
  "pair of gloves",
  "pair of bracers",
  "pair of greaves",
  "pair of vambraces",
  "pair of boots",
  "pair of shoes",
  "quiver",
  "whip",
  "belt",
  "buckler",
  "satchel",
  "backpack",
  "bag",
  "purse"
];
function getItemMod() {
  return itemmod[Math.floor(Math.random() * itemmod.length)];
}
const itemmod = [
  "doom",
  "flame",
  "ice",
  "frost",
  "lightning",
  "thunder",
  "storms",
  "poison",
  "venom",
  "acid",
  "the waves",
  "the wind",
  "earthquakes",
  "the sun",
  "the moon",
  "the stars",
  "the night",
  "the raven",
  "the wolf",
  "the falcon",
  "the bear",
  "the fox",
  "the llama",
  "the tiger",
  "the lion",
  "the eagle",
  "the owl",
  "the spider",
  "the platypus",
  "the penguin",
  "the dragon",
  "Heaven",
  "Hell",
  "the apocalypse",
  "darkness",
  "shadows",
  "light",
  "mystery",
  "Zeus",
  "Ares",
  "Hades",
  "Artemis",
  "Apollo",
  "Poseidon",
  "Hermes",
  "Hephaestus",
  "Aphrodite",
  "Kali",
  "Vishnu",
  "Shiva",
  "Ra",
  "Osiris",
  "Isis",
  "Bastet",
  "Horus",
  "Thoth",
  "Anubis",
  "Hathor",
  "Thor",
  "Odin",
  "Freyr",
  "Freya",
  "Loki",
  "Valhalla",
  "Nyx",
  "Cthulhu",
  "invisibility",
  "healing",
  "the deep",
  "slime",
  "flatulence",
  "thorns",
  "life stealing",
  "silence",
  "disruption",
  "seeking",
  "wailing",
  "karma",
  "fate",
  "time",
  "chaos",
  "magic draining",
  "vomiting",
  "dreams",
  "dragon slaying",
  "banish undead",
  "troll slaying",
  "goblin slaying",
  "orc slaying",
  "ogre slaying",
  "demon slaying",
  "the void",
  "immortality",
  "invincibility",
  "anger",
  "love",
  "war",
  "grief",
  "fear",
  "mercy",
  "nightmares",
  "gravity",
  "twilight",
  "plague",
  "hallucination"
];
function getWood() {
  return wood[Math.floor(Math.random() * wood.length)];
}
const wood = [
  "pine",
  "birch",
  "cherrywood",
  "chestnut",
  "oak",
  "spruce",
  "poplar",
  "beech",
  "applewood",
  "elm",
  "hickory",
  "larch",
  "mulberry",
  "cedar",
  "yew",
  "redwood",
  "ivory",
  "ebony",
  "bone",
  "teak",
  "mahogany"
];
function getWoodItem() {
  return wooditem[Math.floor(Math.random() * wooditem.length)];
}
const wooditem = [
  "shortbow",
  "longbow",
  "crossbow",
  "staff",
  "quarterstaff",
  "bo-staff",
  "round shield",
  "wand",
  "rod",
  "cudgel",
  "club",
  "spear",
  "flute",
  "box"
];
function getMagicItem() {
  return magicitem[Math.floor(Math.random() * magicitem.length)];
}
const magicitem = [
  "scroll",
  "spellbook",
  "staff",
  "wand",
  "potion",
  "ring"
];
function getSpell() {
  return spell[Math.floor(Math.random() * spell.length)];
}
const spell = [
  "fireball",
  "magic missile",
  "ice spikes",
  "lightning",
  "earthquake",
  "rockslide",
  "wind gust",
  "tornado",
  "lava",
  "glacier",
  "acid rain",
  "holy flame",
  "sunburst",
  "plasma flare",
  "featherfall",
  "light",
  "reveal traps",
  "purify",
  "healing",
  "polymorph self",
  "polymorph other",
  "cure poison",
  "cure disease",
  "resurrect",
  "teleport",
  "locate stairs",
  "locate monsters",
  "invisibility",
  "summon monster",
  "water walking",
  "water breathing",
  "charm monster",
  "stone skin",
  "petrify",
  "open door",
  "astral projection",
  "protection from fire",
  "protection from ice",
  "protection from lightning",
  "protection from earth",
  "curse",
  "bless",
  "banish undead",
  "growth",
  "shrink",
  "animal friendship",
  "giant strength",
  "celerity",
  "transmutation",
  "language translation",
  "stun",
  "animate object",
  "plant control",
  "animal control"
];
function getElement() {
  return element[Math.floor(Math.random() * element.length)];
}
const element = [
  "fire",
  "ice",
  "frost",
  "water",
  "lightning",
  "wind",
  "earth",
  "acid",
  "poison",
  "holy",
  "evil",
  "chaos",
  "void",
  "steam",
  "fate",
  "time",
  "shadow",
  "doom",
  "light",
  "nature"
];
function getGem() {
  return gem[Math.floor(Math.random() * gem.length)];
}
const gem = [
  "diamond",
  "ruby",
  "emerald",
  "sapphire",
  "amethyst",
  "topaz",
  "opal",
  "onyx",
  "garnet",
  "peridot",
  "alexandrite",
  "amber",
  "jade",
  "aquamarine",
  "turquoise",
  "pearl",
  "beryl",
  "black pearl",
  "tourmaline",
  "bloodstone",
  "moonstone",
  "spinel",
  "zircon",
  "carnelian",
  "quartz",
  "chrysoberyl",
  "citrine",
  "agate",
  "kyanite",
  "jasper",
  "lapis lazuli",
  "malachite",
  "obsidian",
  "sunstone",
  "tanzanite"
];
function getJewelry() {
  return jewelry[Math.floor(Math.random() * jewelry.length)];
}
const jewelry = [
  "necklace",
  "bracelet",
  "ring",
  "pendant",
  "pair of earrings",
  "anklet",
  "circlet",
  "crown"
];
function getClothingColor() {
  return clcolor[Math.floor(Math.random() * clcolor.length)];
}
const clcolor = [
  "red",
  "orange",
  "yellow",
  "green",
  "blue",
  "purple",
  "white",
  "black",
  "brown",
  "pink",
  "magenta",
  "maroon",
  "violet",
  "tangerine",
  "turquoise",
  "teal",
  "cyan",
  "cerulean",
  "chartreuse",
  "mauve",
  "fuchsia",
  "beige",
  "tan",
  "gray",
  "olive green",
  "goldenrod",
  "silver",
  "indigo",
  "forest green",
  "rainbow colored",
  "polka-dotted",
  "plaid",
  "paisley",
  "checkered",
  "striped",
  "khaki",
  "camouflage"
];
function getFabric() {
  return fabric[Math.floor(Math.random() * fabric.length)];
}
const fabric = [
  "cotton",
  "wool",
  "linen",
  "silk",
  "satin",
  "lace",
  "burlap",
  "cashmere",
  "spidersilk",
  "muslin",
  "taffeta",
  "brocade",
  "terrycloth",
  "felt",
  "velvet",
  "fur-lined",
  "hemp"
];
function getGarment() {
  return garment[Math.floor(Math.random() * garment.length)];
}
const garment = [
  "tunic",
  "pair of breeches",
  "loincloth",
  "doublet",
  "cloak",
  "wizard's robe",
  "bathrobe",
  "surcoat",
  "tabard",
  "pair of trousers",
  "skirt",
  "dress",
  "gown",
  "pair of socks",
  "pair of gloves",
  "top hat",
  "waistcoat",
  "kilt",
  "cummerbund",
  "bowtie",
  "necktie",
  "tuxedo",
  "kimono",
  "karate gi",
  "pair of toe socks",
  "sarong",
  "scarf",
  "pair of legwarmers",
  "trenchcoat",
  "pair of shorts",
  "pair of leggings",
  "blouse",
  "sweater",
  "cardigan",
  "wizard's hat",
  "feathered hat",
  "tutu",
  "cape"
];
function getMiscItem() {
  return misc[Math.floor(Math.random() * misc.length)];
}
const misc = [
  "a quiver of arrows",
  "some gold coins",
  "a pile of rations",
  "a cheese wheel",
  "a few apples",
  "a loaf of stale bread",
  "a magic lamp",
  "some torches",
  "a set of lockpicks",
  "a magical harp",
  "a half-eaten ham sandwich",
  "a roast turkey",
  "several carrots",
  "a fruitcake",
  "a crystal skull",
  "a stone tablet",
  "some runestones",
  "an empty flask",
  "a broom",
  "a pair of scissors",
  "a mop",
  "a clown nose",
  "a raven totem",
  "a pig totem",
  "a wolf totem",
  "a fox totem",
  "an eagle totem",
  "a roc feather",
  "a bat wing",
  "an old painting",
  "a tinderbox",
  "a lantern",
  "a treasure map",
  "a rope",
  "a violin",
  "a lute",
  "a shrunken head",
  "an accordion",
  "some magic beans"
];
function getLootPlace() {
  return lootplace[Math.floor(Math.random() * lootplace.length)];
}
const lootplace = [
  "You open an old wooden treasure chest and find",
  "In an old wooden chest, you find",
  "Peering into a dark corner, you see a dusty shelf containing",
  "You see something glinting in a dark alcove. Looking closer, you find",
  "You trip over",
  "In a pile of junk, you find",
  "You find a barrel containing",
  "You notice a large canvas bag lying around. Inside it, you find",
  "A stone seems to be missing from the wall. Inside the hole, you find",
  "You notice an ancient altar containing",
  "Lying atop an intricately carved pedestal, you see",
  "Finding an old clay pot lying around, you reach inside and pull out"
];
function getRandomItem() {
  return item[Math.floor(Math.random() * item.length)];
}
const item = [
  `${getItemAdj()} ${getMetal()} ${getMetalItem()}.`,
  `${getMetal()} ${getMetalItem()} of ${getItemMod()}.`,
  `${getItemAdj()} ${getMetal()} ${getMetalItem()} of ${getItemMod()}.`,
  `${getMetal()} ${getMetalItem()} of ${getElement()}.`,
  `${getMetal()} ${getMetalItem()} of protection from ${getElement()}.`,
  `${getMetal()} ${getMetalItem()} of ${getSpell()}`,
  `${getItemAdj()} ${getMetal()} ${getMetalItem()} of ${getElement()}.`,
  `${getItemAdj()} ${getMetal()} ${getMetalItem()} of protection from ${getElement()}.`,
  `${getItemAdj()} ${getMetal()} ${getMetalItem()} of ${getSpell()}`,
  `${getLeather()} ${getLeatherItem()}.`,
  `${getItemAdj()} ${getLeather()} ${getLeatherItem()}.`,
  `${getLeather()} ${getLeatherItem()} of ${getItemMod()}.`,
  `${getItemAdj()} ${getLeather()} ${getLeatherItem()} of ${getItemMod()}.`,
  `${getLeather()} ${getLeatherItem()} of ${getElement()}.`,
  `${getLeather()} ${getLeatherItem()} of protection from ${getElement()}.`,
  `${getLeather()} ${getLeatherItem()} of ${getSpell()}.`,
  `${getItemAdj()} ${getLeather()} ${getLeatherItem()} of ${getElement()}.`,
  `${getItemAdj()} ${getLeather()} ${getLeatherItem()} of protection from ${getElement()}.`,
  `${getItemAdj()} ${getLeather()} ${getLeatherItem()} of ${getSpell()}.`,
  `${getWood()} ${getWoodItem()}.`,
  `${getItemAdj()} ${getWood()} ${getWoodItem()}.`,
  `${getWood()} ${getWoodItem()} of ${getItemMod()}.`,
  `${getItemAdj()} ${getWood()} ${getWoodItem()} of ${getItemMod()}.`,
  `${getWood()} ${getWoodItem()} of ${getElement()}.`,
  `${getWood()} ${getWoodItem()} of protection from ${getElement()}.`,
  `${getWood()} ${getWoodItem()} of ${getSpell()}.`,
  `${getItemAdj()} ${getWood()} ${getWoodItem()} of ${getElement()}.`,
  `${getItemAdj()} ${getWood()} ${getWoodItem()} of protection from ${getElement()}.`,
  `${getItemAdj()} ${getWood()} ${getWoodItem()} of ${getSpell()}.`,
  `${getMagicItem()} of ${getSpell()}.`,
  `${getClothingColor()} orb of ${getElement()}.`,
  `${getClothingColor()} orb of ${getSpell()}.`,
  `${getMetal()} and ${getGem()} ${getJewelry()}.`,
  `${getLeather()} quiver full of ${getWood()} arrows.`,
  `${getClothingColor()} ${getFabric()} ${getGarment()}.`
]

//epoch time system

/** Epoch Time System
 * MIT License
 * Copyright (c) 2025 Xilmanaath
 * Thanks to LewdLeah for the card helper functions and LSIv2.
 */

const Epoch = (() => {
    const epochCardTitle = 'Epoch';
    const timeIncrementMinutes = 6;
    const instructionalText = '[ enforce circadian rhythm. World continues indifferently‚Äîin medias res. Only print HH:MM YYYY-MM-DD headers on time skips (sleep, travel, subjective or explicit drift, scene change) ]';
    const eventInstruction = '[ stage event actions as sluglines ]';
    const dayNames = ["Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
    ];
    const MIN_PER_HOUR = 60n;
    const MIN_PER_DAY = 24n * MIN_PER_HOUR;
    const MIN_PER_WEEK = 7n * MIN_PER_DAY;
    const MIN_PER_MONTH = 43800n;
    const MIN_PER_YEAR = 525600n;
    const TIMESTAMP_PATTERNS = [
        // Reversed: YYYY-MM-DD HH:MM (e.g. 2025-09-01 13:22)
        /\b(?<year>-?\d{1,16})-(?<month>\d{2})-(?<day>\d{2})\s+(?<hour>\d{2}):(?<minute>\d{2})(?::\d{2})?\b/,
        
        // Normal: HH:MM YYYY-MM-DD (e.g. 13:22 2025-09-01)
        /\b(?<hour>\d{2}):(?<minute>\d{2})(?::\d{2})?\s+(?<year>-?\d{1,16})-(?<month>\d{2})-(?<day>\d{2})\b/
    ];

    const normalizeLine = (line) => {
        return line
            .replace(/[‚Äì‚Äî]/g, '-') // normalize all dash variants to plain "-"
            .replace(/\s+/g, ' ') // collapse multiple spaces
            .trim();
    };


    class EpochDate {
        constructor(year, month = 1, day = 1, hour = 0, minute = 0) {
            [year, month, day] = EpochDate.normalizeDate(year, month, day);
            // store as BigInt for unbounded range
            this.year = BigInt(year);
            this.month = month; // 1‚Äì12
            this.day = day; // 1‚Äì31
            this.hour = hour; // 0‚Äì23
            this.minute = minute; // 0‚Äì59
        }

        // Date-like getters
        getFullYear() {
            return Number(this.year);
        }
        getMonth() {
            return this.month - 1;
        } // zero-based
        getDate() {
            return this.day;
        }
        getHours() {
            return this.hour;
        }
        getMinutes() {
            return this.minute;
        }

        // equivalent to .getTime(), but in BigInt minutes
        getTime() {
            // naive: 1 year = 365d, 1 mo = 30d
            const Y = this.year * MIN_PER_YEAR;
            const M = BigInt(this.month - 1) * MIN_PER_MONTH;
            const D = BigInt(this.day - 1) * MIN_PER_DAY;
            const T = BigInt(this.hour) * MIN_PER_HOUR + BigInt(this.minute);
            return Y + M + D + T;
        }

        // convert back
        static fromTotalMinutes(total) {
            const totalMin = BigInt(total);
            const baseY = MIN_PER_YEAR,
                baseM = MIN_PER_MONTH,
                baseD = MIN_PER_DAY,
                baseH = MIN_PER_HOUR;

            // 1) compute year = floor(totalMin / baseY)
            let year;
            if (totalMin >= 0n) {
                year = totalMin / baseY;
            } else {
                // for negative values, add (Y‚àí1) before trunc to achieve floor
                year = -((-totalMin + baseY - 1n) / baseY);
            }

            // 2) compute a non-negative remainder
            let rem = totalMin - year * baseY;
            // rem is now in [0 .. baseY‚àí1]

            // 3) peel off months, days, hours, minutes
            const mon = rem / baseM;
            rem %= baseM;
            const day = rem / baseD;
            rem %= baseD;
            const hr = rem / baseH;
            const min = rem % baseH;

            return new EpochDate(
                year,
                Number(mon) + 1,
                Number(day) + 1,
                Number(hr),
                Number(min)
            );
        }

        // mimic subtraction: returns BigInt minutes
        diffInMinutes(other) {
            return this.getTime() - other.getTime();
        }

        /* Zeller‚Äôs Congruence allows us to calculate the day of the week for any date, including pre-Gregorian, negative years, and dates way outside the native Date object‚Äôs range.
         */
        getDay() {
            let y = Number(this.year);
            let m = this.month;
            const d = this.day;

            if (m < 3) {
                m += 12;
                y -= 1;
            }

            const K = y % 100;
            const J = Math.floor(y / 100);

            const h = (d + Math.floor(13 * (m + 1) / 5) + K + Math.floor(K / 4) + Math.floor(J / 4) + 5 * J) % 7;

            // Zeller's returns: 0 = Saturday, 1 = Sunday, ..., 6 = Friday
            // Convert to JS-style: 0 = Sunday, ..., 6 = Saturday
            return (h + 6) % 7;
        };

        static isLeapYear(year) {
            year = Number(year);
            return (year % 4 === 0) && (year % 100 !== 0 || year % 400 === 0);
        }

        static daysInMonth(year, month) {
            const thirtyOne = [1, 3, 5, 7, 8, 10, 12];
            const thirty = [4, 6, 9, 11];
            if (thirtyOne.includes(month)) return 31;
            if (thirty.includes(month)) return 30;
            if (month === 2) return EpochDate.isLeapYear(year) ? 29 : 28;
            return 0; // invalid month
        }

        /* 2025-04-31 becomes 2025-05-01, or 2025-12-40 becomes 2026-01-09.
         */
        static normalizeDate(year, month, day) {
            year = BigInt(year);
            month = Number(month);
            day = Number(day);
            if (month < 1) month = 1;
            if (day < 1) day = 1;

            while (true) {
                const max = EpochDate.daysInMonth(year, month);
                if (day <= max) break;
                day -= max;
                month += 1;
                if (month > 12) {
                    const overflowYears = Math.floor((month - 1) / 12);
                    month = ((month - 1) % 12) + 1;
                    year = BigInt(year) + BigInt(overflowYears);
                }
            }
            return [BigInt(year), month, day];
        }

        // misc helper functions
        toString() {
            return `${this.getFullYear()}-${String(this.getMonth() + 1).padStart(2, '0')}-${String(this.getDate()).padStart(2, '0')} ${String(this.getHours()).padStart(2, '0')}:${String(this.getMinutes()).padStart(2, '0')}`;
        };

        toJSON() {
            return {
                year: this.year.toString(),
                month: this.month,
                day: this.day,
                hour: this.hour,
                minute: this.minute
            };
        }

        static fromNativeDate(jsDate) {
            return new EpochDate(
                jsDate.getFullYear(),
                jsDate.getMonth() + 1,
                jsDate.getDate(),
                jsDate.getHours(),
                jsDate.getMinutes()
            );
        }
    }

    /**
     * Creates a new story card and inserts it into storyCards. Thanks LewdLeah!
     *
     * @param {string} title - The card title.
     * @param {string} entry - The card entry content.
     * @param {string} type - The card type (e.g., "chronometer").
     * @param {string} keys - Comma-separated trigger keywords.
     * @param {string} description - The card's description/config block.
     * @param {number} insertionIndex - Index to insert the card at (0 = top).
     * @returns {object} A reference to the newly created or updated card.
     */
    const buildCard = (title = "", entry = "", type = "character", keys = title, description = "", insertionIndex = 0) => {
        if (![type, title, keys, entry, description].every(arg => (typeof arg === "string"))) {
            throw new Error("buildCard must be called with strings for title, entry, type, keys, and description");
        } else if (!Number.isInteger(insertionIndex)) {
            throw new Error("buildCard must be called with an integer for insertionIndex");
        } else {
            insertionIndex = Math.min(Math.max(0, insertionIndex), storyCards.length);
        }
        addStoryCard("%@%");
        for (const [index, card] of storyCards.entries()) {
            if (card.title !== "%@%") {
                continue;
            }
            card.type = type;
            card.title = title;
            card.keys = keys;
            card.entry = entry;
            card.description = description;
            if (index !== insertionIndex) {
                // Remove from the current position and reinsert at the desired index
                storyCards.splice(index, 1);
                storyCards.splice(insertionIndex, 0, card);
            }
            return Object.seal(card);
        }
        throw new Error("An unexpected error occurred with buildCard");
    };

    /**
     * Searches storyCards for cards matching a given predicate. Thanks LewdLeah!
     *
     * @param {function} predicate - A function that evaluates each card (c => c.title === "Epoch").
     * @param {boolean} [getAll=false] - Whether to return all matches (true) or just the first (false).
     * @returns {object|object[]|null} The matching card(s), or null if none found.
     */
    const getCard = (predicate, getAll = false) => {
        if (typeof predicate !== "function") {
            throw new Error(
                "Invalid argument: \"" + predicate + "\" -> getCard must be called with a function"
            );
        } else if (typeof getAll !== "boolean") {
            throw new Error(
                "Invalid argument: \"" + predicate + ", " + getAll + "\" -> getCard requires a boolean as its second argument"
            );
        } else if (getAll) {
            // Return an array of card references which satisfy the given condition
            const collectedCards = [];
            for (const card of storyCards) {
                if (predicate(card)) {
                    Object.seal(card);
                    collectedCards.push(card);
                }
            }
            return collectedCards;
        }
        // Return a reference to the first card which satisfies the given condition
        for (const card of storyCards) {
            if (predicate(card)) {
                return Object.seal(card);
            }
        }
        return null;
    };

    /**
     * Scans a text string for an inline time header and parses it into a Date object.
     *
     * @param {string} entry - The string to scan (e.g., output text or card entry).
     * @returns {EpochDate|null} A parsed EpochDate object if a time header is found, otherwise null.
     */
    const findDate = (entry) => {
        for (const pattern of TIMESTAMP_PATTERNS) {
            const match = entry.match(pattern);
            if (match && match.groups) {
                const {
                    year,
                    month,
                    day,
                    hour,
                    minute
                } = match.groups;
                return new EpochDate(
                    parseInt(year, 10),
                    parseInt(month, 10),
                    parseInt(day, 10),
                    parseInt(hour, 10),
                    parseInt(minute, 10)
                );
            }
        }

        return null;
    };

    const createEpochCard = () => {
      let epochCard = getCard(c => c.title === epochCardTitle);
      if (!epochCard) {
        const description = [
          `@timeIncrementMinutes:${timeIncrementMinutes}`,
          `@instructionalText:${instructionalText}`,
          `@eventInstruction:${eventInstruction}`,
          `@includeEventInstruction:true`,
          `@includeWeekday:true`,
          ``,
          `// Era can be a static label or a counter from a specific date.`,
          `// lines with // are considered comments (disabled).`,
          ``,
          `// Events persist until the next entry (inclusive). Use a blank entry to clear the active era.`,
          ``,
          `// Static Era Label:`,
          `//@eraName:War of the Lance`,
          ``,
          `// Relative Counter:`,
          `//@eraEpoch:Z-Day`,
          `//@eraStart:2025-01-01`,
          `//@eraAdvance:daily`,
          `// Supports: daily, weekly, monthly, or custom:<minutes>`,
          ``,
          `// Timeline-Based Events:`,
          `//@eraTimeline:`,
          `//#08:00 2025-09-01 - 15:00 2025-09-01: First Day of School`,
          `//#10:00 2025-10-15 - 01:00 2025-10-18: Midterms`,
          `//#10:00 2025-12-10 - 00:01 2025-12-16: Finals Week`,
          `// (Events persist during fuzzy window +/- timeIncrementMinutes)`,
          ``,
          `// Include the day of the week in the timestamp (required for the rhythmSchedule)`,
         `// Supports named days of the week, Weekday, Weekend, and Everyday.`,
          `//@rhythmSchedule:`,
          `//#Monday:`,
          `//# 04:30 EXT. CALLE ‚Äî wood-smoke drifts as bakers fire ovens`,
          `//# 04:45 EXT. CANAL ‚Äî Matins bell rolls; each toll fades into water`,
          `//# 05:10-05:30 EXT. WATERWAY ‚Äî gondoliers dip and pull in echoing cadence`,
          `//#Tuesday:`,
          `//# 09:45 INT. HALL ‚Äî sharp double-bell cuts chatter; footsteps swell`,
          `//# 09:50 INT. LIBRARY ‚Äî doors click shut at 10; latecomers locked out until lunch`,
          `//#Wednesday:`,
          `//# 09:00 INT. OPS ‚Äî station AI tones chime; drones begin sweep`,
          `//# 11:15-11:45 EXT. DOCK ‚Äî haulers spool engines; vibration climbs in the bulkheads`
        ].join("\n");
    
        epochCard = buildCard(
          epochCardTitle,
          "",
          "chronometer",
          " ,.,epoch,time",
          description
        );
      }
      return epochCard;
    };

    /**
     * Initializes the epoch system's internal state.
     * If an Epoch card or stored time is not found, sets a default start time.
     * This should be called once per session before time tracking begins.
     */
    const initializeTimeState = () => {
        // Try to find an existing Epoch card
        let epochCard = getCard(card => card.title === epochCardTitle);
        let date = null;

        // If the card has a parseable date, use it
        if (epochCard) {
            date = findDate(epochCard.entry);
        }

        // If no date found and state is empty, initialize default
        if (!date && state.timeTracker == null) {
            date = new Epoch.EpochDate(2025, 9, 1, 9, 30);
            epochCard = createEpochCard();
        }

        // Store total minutes in state as string
        if (date) {
            state.timeTracker = {
                time: date.getTime().toString()
            };
        }

        return epochCard;
    };

    const advanceTurn = (text, epochCard) => {
        // First, check if autocards or another script is active and exit now
        // match >>> <<< of auto-cards and << >> of Story Arc Engine
        const scriptMarkerRegex = /^\s*(?:>{2,}.*?<{2,}|<{2,}.*?>{2,})\s*$/;
        if (text.split("\n").some(line => scriptMarkerRegex.test(line))) {
            return text;
        }

        const dateFromText = Epoch.findDate(text);
        let date;
        if (dateFromText) {
            // Manual skip by AI output
            date = dateFromText;
            for (const pattern of TIMESTAMP_PATTERNS) {
                text = text.replace(pattern, "");
            }
        } else if (state.timeTracker?.time !== undefined) {
            // Advance from stored time
            const totalMin = BigInt(state.timeTracker.time);
            const nextMin = totalMin + BigInt(Epoch.getTimeIncrementMinutes());
            date = Epoch.EpochDate.fromTotalMinutes(nextMin);
            state.timeTracker.time = nextMin.toString();
        }

        if (date) {
            // Normalize to EpochDate
            const dt = date instanceof Epoch.EpochDate ?
                date :
                Epoch.EpochDate.fromNativeDate(date);

            const totalMin = dt.getTime().toString();
            state.timeTracker.time = totalMin;

            Epoch.updateEpochCard(epochCard);
        }

        return text;
    };

    /**
     * Parses the Epoch card's description block for @key:value configuration pairs.
     * Supports numerical and string values.
     *
     * @returns {Object} A config object with parsed keys (e.g., timeIncrementMinutes, instructionalText).
     */
    const getEpochConfig = () => {
        const card = getCard(c => c.title === epochCardTitle);
        if (!card) {
            console.log("No epoch card found.");
            return {};
        }

        const config = {};
        const lines = card.description.split(/\r?\n/);
        // Keys that can span multiple lines
        const multilineKeys = ['instructionalText', 'eventInstruction', 'eraTimeline', 'rhythmSchedule'];
        let currentKey = null;
        let currentVal = [];

        for (const line of lines) {
            const trimmed = line.trim();

            // Explicitly ignore comment lines entirely.
            if (trimmed.startsWith('//')) {
                continue;
            }

            // Match @key:value ‚Äî reset accumulation
            const match = trimmed.match(/^@(\w+):\s*(.*)$/);
            if (match) {
                if (currentKey) {
                    config[currentKey] = currentVal.join("\n").trim();
                }
                currentKey = match[1];
                currentVal = [match[2]];
                continue;
            }

            // Only allow multiline continuation for specific keys.
            if (currentKey && multilineKeys.includes(currentKey) && (trimmed.startsWith("#") || trimmed === "")) {
                currentVal.push(trimmed);
            }
        }

        // Capture final block
        if (currentKey) {
            config[currentKey] = currentVal.join("\n").trim();
        }

        return config;
    };

    const getRhythmSchedule = (config = {}) => {
      const schedule = {};
      if (!config.rhythmSchedule) return schedule;
    
      const lines = config.rhythmSchedule
        .split(/\r?\n/)
        .map(line => normalizeLine(line))
        .filter(line => line.startsWith('#')); // keep only schedule-ish lines
    
      // Accept normal weekdays + special groups
      const dayHeader = /^#(Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Everyday|Weekday|Weekend):$/i;
    
      let currentDay = null;
    
      for (const line of lines) {
        if (!line) continue;
    
        const dayMatch = line.match(dayHeader);
        if (dayMatch) {
          currentDay = dayMatch[1][0].toUpperCase() + dayMatch[1].slice(1).toLowerCase(); // Normalize casing
          schedule[currentDay] = schedule[currentDay] || [];
          continue;
        }
    
        if (!currentDay) continue; // skip until a header
    
        // Ranges: "# 08:00 - 09:00 Label"
        const rangeMatch = line.match(/^#\s*(\d{2})[:Ôºö](\d{2})\s*-\s*(\d{2})[:Ôºö](\d{2})\s+(.+)$/);
        // Points:  "# 08:00 Label"
        const pointMatch = line.match(/^#\s*(\d{2})[:Ôºö](\d{2})\s+(.+)$/);
    
        if (rangeMatch) {
          const [, sh, sm, eh, em, label] = rangeMatch;
          if (label.trim()) {
            schedule[currentDay].push({
              start: new EpochDate(0, 0, 0, parseInt(sh), parseInt(sm)),
              end:   new EpochDate(0, 0, 0, parseInt(eh), parseInt(em)),
              label: label.trim()
            });
          }
          continue;
        }
    
        if (pointMatch) {
          const [, h, m, label] = pointMatch;
          if (label.trim()) {
            schedule[currentDay].push({
              time:  new EpochDate(0, 0, 0, parseInt(h), parseInt(m)),
              label: label.trim()
            });
          }
        }
      }
    
      // Merge special groups into real weekdays
      const WEEKDAYS  = ["Monday","Tuesday","Wednesday","Thursday","Friday"];
      const WEEKENDS  = ["Saturday","Sunday"];
    
      const mergeInto = (fromKey, intoKeys) => {
        if (!schedule[fromKey]) return;
        for (const k of intoKeys) {
          schedule[k] = (schedule[k] || []).concat(schedule[fromKey]);
        }
      };
    
      mergeInto("Everyday", dayNames);
      mergeInto("Weekday",  WEEKDAYS);
      mergeInto("Weekend",  WEEKENDS);
    
      // Ensure all days exist (empty arrays) for downstream code
      for (const d of dayNames) schedule[d] = schedule[d] || [];
    
      return schedule;
    };

    const getEraSuffix = (date, config = {}) => {
        if (config.eraEpoch && config.eraStart) {
            // parse YYYY-MM-DD
            const [y, m, d] = config.eraStart.split("-").map(Number);
            const start = new EpochDate(y, m, d);
            const diffMin = date.diffInMinutes(start);
            const advance = (config.eraAdvance || "").toLowerCase();

            if (advance === "hourly") {
                return `| ${config.eraEpoch} +${(diffMin / MIN_PER_HOUR)}h`;
            }

            if (advance === "weekly") {
                return `| ${config.eraEpoch} +${(diffMin / MIN_PER_WEEK)}w`;
            }

            if (advance === "monthly") {
                const monthsPassed =
                    (date.getFullYear() - start.getFullYear()) * 12 +
                    (date.getMonth() - start.getMonth());
                return `| ${config.eraEpoch} +${monthsPassed}mo`;
            }

            if (advance.startsWith("custom:")) {
                const customMin = parseInt(advance.split(":")[1], 10);
                if (!isNaN(customMin) && customMin > 0) {
                    const timeSpan = BigInt(customMin);
                    return `| ${config.eraEpoch} +${(diffMin / timeSpan)}`;
                }
            }

            // Default = daily
            return `| ${config.eraEpoch} +${(diffMin / MIN_PER_DAY)}d`;
        }

        if (config.eraName) return `| ${config.eraName}`;
        return "";
    };

    const getActiveEvents = (date, config = {}) => {
        const increment = parseInt(config.timeIncrementMinutes) || timeIncrementMinutes;
        const bufferMin = BigInt(increment);
        const labels = [];

        // Rhythm schedule (time-of-day only)
        const rhythm = getRhythmSchedule(config);
        const weekday = dayNames[date.getDay()];
        const events = rhythm[weekday];

        if (events && config.includeWeekday?.toLowerCase() === "true") {
            const curOfDay = BigInt(date.getHours() * 60 + date.getMinutes());

            for (const entry of events) {
                if (entry.time instanceof EpochDate) {
                    const evtOfDay = BigInt(entry.time.getHours() * 60 + entry.time.getMinutes());
                    const diff = curOfDay - evtOfDay;
                    if (diff >= -bufferMin && diff <= bufferMin) {
                        labels.push(entry.label);
                    }
                } else if (entry.start instanceof EpochDate && entry.end instanceof EpochDate) {
                    const startOfDay = BigInt(entry.start.getHours() * 60 + entry.start.getMinutes());
                    const endOfDay = BigInt(entry.end.getHours() * 60 + entry.end.getMinutes());
                    if (curOfDay >= startOfDay - bufferMin && curOfDay <= endOfDay + bufferMin) {
                        labels.push(entry.label);
                    }
                }
            }
        }

        // Timeline events (full date comparisons)
        if (config.eraTimeline) {
            const lines = config.eraTimeline
                .split(/\r?\n/)
                .map(normalizeLine)
                .filter(l => l.startsWith("#"));

            for (const line of lines) {
                let match = line.match(/^#\s?(\d{2}):(\d{2}) (-?\d{1,16})-(\d{2})-(\d{2})\s*-\s*(\d{2}):(\d{2}) (-?\d{1,16})-(\d{2})-(\d{2}):\s*(.+)$/);
                if (match) {
                    const [, h1, m1, y1, mo1, d1, h2, m2, y2, mo2, d2, label] = match;
                    const start = new EpochDate(y1, mo1, d1, h1, m1);
                    const end = new EpochDate(y2, mo2, d2, h2, m2);
                    const diffStart = date.diffInMinutes(start);
                    const diffEnd = date.diffInMinutes(end);
                    if (diffStart >= -bufferMin && diffEnd <= bufferMin) {
                        labels.push(label.trim());
                    }
                    continue;
                }

                match = line.match(/^#\s?(\d{2}):(\d{2}) (-?\d{1,16})-(\d{2})-(\d{2}):\s*(.+)$/);
                if (match) {
                    const [, hour, min, year, month, day, label] = match;
                    const dt = new EpochDate(year, month, day, hour, min);
                    const diff = date.diffInMinutes(dt);
                    if (diff >= -bufferMin && diff <= bufferMin) {
                        labels.push(label.trim());
                    }
                }
            }
        }

        return labels;
    };

    const formatTime = (dateObj) => {
      
      const year = dateObj.getFullYear();
      const month = dateObj.getMonth() + 1;
      const day = dateObj.getDate();
      const hours = dateObj.getHours();
      const minutes = dateObj.getMinutes();
    
      const config = getEpochConfig();
      if (!config) return "";
    
      const fmt = (n) => n.toString().padStart(2, "0");
      const era = getEraSuffix(dateObj, config).trim();
    
      const includeWeekday = config.includeWeekday?.toLowerCase() === "true";
      const dayName = includeWeekday ? `${dayNames[dateObj.getDay()]} ` : "";

      const includeEventInstruction = config.includeEventInstruction?.toLowerCase() === "true";

      const events = getActiveEvents(dateObj, config);

      let eventInstructionText = "";
      if (includeEventInstruction) {
        eventInstructionText = (config.eventInstruction || eventInstruction).trim();
      }

        const timeLine = `[ time: ${era ? era + " " : ""}${year}-${fmt(month)}-${fmt(day)} ${dayName} ${fmt(hours)}:${fmt(minutes)} ]`;

      const eventLine = events.length ? `[ event: ${events.join("; ")} ]` : "";
  
      /* Order: instruction (if any)
                event (if any)
                time (always)
      */
      return [
        eventInstructionText && events.length ? eventInstructionText : "",
        eventLine,
        timeLine
      ].filter(Boolean).join("\n");
    };

    /**
     * Updates or creates the Epoch card with the current time and instructions.
     * Reads configuration from the card description, and writes the timestamp and
     * user-defined instructions into the card's entry.
     */
    const updateEpochCard = () => {
        const epochCard = createEpochCard();

        if (!state.timeTracker) return;

        const config = getEpochConfig();
        const instruction = config.instructionalText || instructionalText;

        const current = EpochDate.fromTotalMinutes(state.timeTracker.time);
        const dateStr = formatTime(current);
        epochCard.entry = dateStr + '\n' + instruction;
    };

    /**
     * Returns the configured time increment (in minutes) for each turn.
     * Falls back to the default if not set or invalid.
     *
     * @returns {number} The time increment to apply each turn.
     */
    const getTimeIncrementMinutes = () => {
        const epochCard = getEpochConfig();
        const raw = epochCard.timeIncrementMinutes;
        const val = parseInt(raw);

        // must increment between 1 min and 1 year
        if (!isNaN(val) && val > 0 && val <= 525600) {
            return val;
        }

        return timeIncrementMinutes;
    };

    return {
        initializeTimeState,
        formatTime,
        findDate,
        updateEpochCard,
        getTimeIncrementMinutes,
        EpochDate,
        advanceTurn
    };
})();
